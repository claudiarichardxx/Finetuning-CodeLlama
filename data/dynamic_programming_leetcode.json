[
     {
          "instruction": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"babad \"\n**Output:**  \"bab \"\n**Explanation:**  \"aba \" is also a valid answer.\n\n**Example 2:**\n\n**Input:** s =  \"cbbd \"\n**Output:**  \"bb \"\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consist of only digits and English letters.",
          "output": "def longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n"
     },
     {
          "instruction": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"a\\* \"\n**Output:** true\n**Explanation:** '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \".\n\n**Example 3:**\n\n**Input:** s =  \"ab \", p =  \".\\* \"\n**Output:** true\n**Explanation:**  \".\\* \" means  \"zero or more (\\*) of any character (.) \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= p.length <= 20`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'.'`, and `'*'`.\n*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.",
          "output": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n"
     },
     {
          "instruction": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"()\"\\]\n\n**Constraints:**\n\n*   `1 <= n <= 8`",
          "output": "def generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n"
     },
     {
          "instruction": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.",
          "output": "def longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result\n"
     },
     {
          "instruction": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n",
          "input": "**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`",
          "output": "def trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n"
     },
     {
          "instruction": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.",
          "output": "def is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n"
     },
     {
          "instruction": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[2,3,0,1,4\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.",
          "output": "def jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n"
     },
     {
          "instruction": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[-2,1,-3,4,-1,2,1,-5,4\\]\n**Output:** 6\n**Explanation:** The subarray \\[4,-1,2,1\\] has the largest sum 6.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:** The subarray \\[1\\] has the largest sum 1.\n\n**Example 3:**\n\n**Input:** nums = \\[5,4,-1,7,8\\]\n**Output:** 23\n**Explanation:** The subarray \\[5,4,-1,7,8\\] has the largest sum 23.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle.",
          "output": "def maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n"
     },
     {
          "instruction": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n**Example 2:**\n\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`",
          "output": "def canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True\n"
     },
     {
          "instruction": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.\n\n",
          "input": "**Example 1:**\n\n**Input:** m = 3, n = 7\n**Output:** 28\n\n**Example 2:**\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n\n**Constraints:**\n\n*   `1 <= m, n <= 100`",
          "output": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n"
     },
     {
          "instruction": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.\n\n",
          "input": "**Example 1:**\n\n**Input:** obstacleGrid = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n**Example 2:**\n\n**Input:** obstacleGrid = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.",
          "output": "def uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]\n"
     },
     {
          "instruction": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`",
          "output": "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n"
     },
     {
          "instruction": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n\n**Constraints:**\n\n*   `1 <= n <= 45`",
          "output": "def climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n"
     },
     {
          "instruction": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character\n\n",
          "input": "**Example 1:**\n\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:** \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n**Example 2:**\n\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:** \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\n**Constraints:**\n\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.",
          "output": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n"
     },
     {
          "instruction": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.\n\n",
          "input": "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
          "output": "def maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area\n"
     },
     {
          "instruction": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s1 =  \"great \", s2 =  \"rgeat \"\n**Output:** true\n**Explanation:** One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"abcde \", s2 =  \"caebd \"\n**Output:** false\n\n**Example 3:**\n\n**Input:** s1 =  \"a \", s2 =  \"a \"\n**Output:** true\n\n**Constraints:**\n\n*   `s1.length == s2.length`\n*   `1 <= s1.length <= 30`\n*   `s1` and `s2` consist of lowercase English letters.",
          "output": "def isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False\n"
     },
     {
          "instruction": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\n**Example 2:**\n\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\n**Example 3:**\n\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \").\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).",
          "output": "def numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n"
     },
     {
          "instruction": "Given an integer `n`, return _all the structurally unique **BST'**s (binary search trees), which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`. Return the answer in **any order**.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\\[1,null,2,null,3\\],\\[1,null,3,2\\],\\[2,1,3\\],\\[3,1,null,null,2\\],\\[3,2,null,1\\]\\]\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 8`",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef generate_trees(start, end):\n    trees = []\n    if start > end:\n        trees.append(None)\n        return trees\n\n    for i in range(start, end + 1):\n        left_subtrees = generate_trees(start, i - 1)\n        right_subtrees = generate_trees(i + 1, end)\n\n        for left in left_subtrees:\n            for right in right_subtrees:\n                new_node = TreeNode(i)\n                new_node.left = left\n                new_node.right = right\n                trees.append(new_node)\n\n    return trees\n\ndef generate_trees(n):\n    if n == 0:\n        return []\n    return generate_trees(1, n)\n"
     },
     {
          "instruction": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 19`",
          "output": "def numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n"
     },
     {
          "instruction": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n*   `s = s1 + s2 + ... + sn`\n*   `t = t1 + t2 + ... + tm`\n*   `|n - m| <= 1`\n*   The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbcbcac \"\n**Output:** true\n**Explanation:** One way to obtain s3 is:\nSplit s1 into s1 =  \"aa \" +  \"bc \" +  \"c \", and s2 into s2 =  \"dbbc \" +  \"a \".\nInterleaving the two splits, we get  \"aa \" +  \"dbbc \" +  \"bc \" +  \"a \" +  \"c \" =  \"aadbbcbcac \".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n**Example 2:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbbaccc \"\n**Output:** false\n**Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n**Example 3:**\n\n**Input:** s1 =  \" \", s2 =  \" \", s3 =  \" \"\n**Output:** true\n\n**Constraints:**\n\n*   `0 <= s1.length, s2.length <= 100`\n*   `0 <= s3.length <= 200`\n*   `s1`, `s2`, and `s3` consist of lowercase English letters.\n\n**Follow up:** Could you solve it using only `O(s2.length)` additional memory space?",
          "output": "def isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n"
     },
     {
          "instruction": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"rabbbit \", t =  \"rabbit \"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`\n\n**Example 2:**\n\n**Input:** s =  \"babgbag \", t =  \"bag \"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 1000`\n*   `s` and `t` consist of English letters.",
          "output": "def numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n"
     },
     {
          "instruction": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n",
          "input": "**Example 1:**\n\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n\n**Example 2:**\n\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]\n\n**Constraints:**\n\n*   `1 <= numRows <= 30`",
          "output": "def generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle\n"
     },
     {
          "instruction": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:\n\n",
          "input": "**Example 1:**\n\n**Input:** rowIndex = 3\n**Output:** \\[1,3,3,1\\]\n\n**Example 2:**\n\n**Input:** rowIndex = 0\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** rowIndex = 1\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `0 <= rowIndex <= 33`\n\n**Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?",
          "output": "def get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row\n"
     },
     {
          "instruction": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.\n\n",
          "input": "**Example 1:**\n\n**Input:** triangle = \\[\\[2\\],\\[3,4\\],\\[6,5,7\\],\\[4,1,8,3\\]\\]\n**Output:** 11\n**Explanation:** The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n**Example 2:**\n\n**Input:** triangle = \\[\\[-10\\]\\]\n**Output:** -10\n\n**Constraints:**\n\n*   `1 <= triangle.length <= 200`\n*   `triangle[0].length == 1`\n*   `triangle[i].length == triangle[i - 1].length + 1`\n*   `-104 <= triangle[i][j] <= 104`\n\n**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?",
          "output": "def minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n"
     },
     {
          "instruction": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n**Example 2:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`",
          "output": "def maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n"
     },
     {
          "instruction": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.\n\n",
          "input": "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`",
          "output": "def max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n"
     },
     {
          "instruction": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n",
          "input": "**Example 1:**\n\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0.\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`",
          "output": "def maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2\n"
     },
     {
          "instruction": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.\n\n",
          "input": "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\n**Example 2:**\n\n**Input:** root = \\[-10,9,20,null,null,15,7\\]\n**Output:** 42\n**Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 3 * 104]`.\n*   `-1000 <= Node.val <= 1000`",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef maxPathSum(root: TreeNode) -> int:\n    def helper(root):\n        nonlocal maxSum\n        if not root:\n            return 0\n\n        left = max(0, helper(root.left))\n        right = max(0, helper(root.right))\n\n        maxSum = max(maxSum, left + right + root.val)\n\n        return max(left, right) + root.val\n\n    maxSum = float('-inf')\n    helper(root)\n    return maxSum\n"
     },
     {
          "instruction": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return _all possible palindrome partitioning of_ `s`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s = \"aab\"\n**Output:** \\[\\[\"a\",\"a\",\"b\"\\],\\[\"aa\",\"b\"\\]\\]\n\n**Example 2:**\n\n**Input:** s = \"a\"\n**Output:** \\[\\[\"a\"\\]\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 16`\n*   `s` contains only lowercase English letters.",
          "output": "def isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results\n"
     },
     {
          "instruction": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn _the **minimum** cuts needed for a palindrome partitioning of_ `s`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aab \"\n**Output:** 1\n**Explanation:** The palindrome partitioning \\[ \"aa \", \"b \"\\] could be produced using 1 cut.\n\n**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 0\n\n**Example 3:**\n\n**Input:** s =  \"ab \"\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters only.",
          "output": "def minCut(s):\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for j in range(1, n):\n        for i in range(j, -1, -1):\n            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):\n                is_palindrome[i][j] = True\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n                \n    return dp[n]\n"
     },
     {
          "instruction": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n\n**Example 2:**\n\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n\n**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.",
          "output": "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n"
     },
     {
          "instruction": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"catsanddog \", wordDict = \\[ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"\\]\n**Output:** \\[ \"cats and dog \", \"cat sand dog \"\\]\n\n**Example 2:**\n\n**Input:** s =  \"pineapplepenapple \", wordDict = \\[ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"\\]\n**Output:** \\[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"\\]\n**Explanation:** Note that you are allowed to reuse a dictionary word.\n\n**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 10`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\n*   Input is generated in a way that the length of the answer doesn't exceed 105.",
          "output": "def word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)\n"
     },
     {
          "instruction": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,3,-2,4\\]\n**Output:** 6\n**Explanation:** \\[2,3\\] has the largest product 6.\n\n**Example 2:**\n\n**Input:** nums = \\[-2,0,-1\\]\n**Output:** 0\n**Explanation:** The result cannot be 2, because \\[-2,-1\\] is not a subarray.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-10 <= nums[i] <= 10`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.",
          "output": "def maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n"
     },
     {
          "instruction": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n\n",
          "input": "**Example 1:**\n\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n**Example 2:**\n\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`",
          "output": "def calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n"
     },
     {
          "instruction": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n",
          "input": "**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`",
          "output": "def maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n"
     },
     {
          "instruction": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`",
          "output": "def rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n"
     },
     {
          "instruction": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`",
          "output": "def rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)\n"
     },
     {
          "instruction": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.\n\n",
          "input": "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \", \"1 \"\\],\\[ \"1 \", \"0 \"\\]\\]\n**Output:** 1\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
          "output": "def maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n"
     },
     {
          "instruction": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 13\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `0 <= n <= 109`",
          "output": "def countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n"
     },
     {
          "instruction": "Given a string `expression` of numbers and operators, return _all possible results from computing all the different possible ways to group numbers and operators_. You may return the answer in **any order**.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed `104`.\n\n",
          "input": "**Example 1:**\n\n**Input:** expression =  \"2-1-1 \"\n**Output:** \\[0,2\\]\n**Explanation:**\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\n**Example 2:**\n\n**Input:** expression =  \"2\\*3-4\\*5 \"\n**Output:** \\[-34,-14,-10,-10,10\\]\n**Explanation:**\n(2\\*(3-(4\\*5))) = -34 \n((2\\*3)-(4\\*5)) = -14 \n((2\\*(3-4))\\*5) = -10 \n(2\\*((3-4)\\*5)) = -10 \n(((2\\*3)-4)\\*5) = 10\n\n**Constraints:**\n\n*   `1 <= expression.length <= 20`\n*   `expression` consists of digits and the operator `'+'`, `'-'`, and `'*'`.\n*   All the integer values in the input expression are in the range `[0, 99]`.",
          "output": "def diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result\n"
     },
     {
          "instruction": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_.\n\n",
          "input": "**Example 1:**\n\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n\n**Example 2:**\n\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`",
          "output": "def minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])\n"
     },
     {
          "instruction": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return _the_ `nth` _**ugly number**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 10\n**Output:** 12\n**Explanation:** \\[1, 2, 3, 4, 5, 6, 8, 9, 10, 12\\] is the sequence of the first 10 ugly numbers.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n**Constraints:**\n\n*   `1 <= n <= 1690`",
          "output": "def nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]\n\n"
     },
     {
          "instruction": "There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...\n\nReturn _the minimum cost to paint all houses_.\n\n",
          "input": "**Example 1:**\n\n**Input:** costs = \\[\\[1,5,3\\],\\[2,9,4\\]\\]\n**Output:** 5\n**Explanation:**\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n\n**Example 2:**\n\n**Input:** costs = \\[\\[1,3\\],\\[2,4\\]\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == k`\n*   `1 <= n <= 100`\n*   `2 <= k <= 20`\n*   `1 <= costs[i][j] <= 20`\n\n**Follow up:** Could you solve it in `O(nk)` runtime?",
          "output": "def min_cost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n\n    n, k = len(costs), len(costs[0])\n\n    for i in range(1, n):\n        for j in range(k):\n            min_cost = float(\"inf\")\n            for l in range(k):\n                if l == j:\n                    continue\n                min_cost = min(min_cost, costs[i - 1][l])\n            costs[i][j] += min_cost\n\n    return min(costs[n - 1])\n"
     },
     {
          "instruction": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 6\n**Explanation:** All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\n**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 7, k = 2\n**Output:** 42\n\n**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= k <= 105`\n*   The testcases are generated such that the answer is in the range `[0, 231 - 1]` for the given `n` and `k`.",
          "output": "def numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different\n"
     },
     {
          "instruction": "Given an integer `n`, return _the least number of perfect square numbers that sum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 12\n**Output:** 3\n**Explanation:** 12 = 4 + 4 + 4.\n\n**Example 2:**\n\n**Input:** n = 13\n**Output:** 2\n**Explanation:** 13 = 4 + 9.\n\n**Constraints:**\n\n*   `1 <= n <= 104`",
          "output": "def numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n"
     },
     {
          "instruction": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn `true` _if the starting player can **guarantee a win**_, and `false` otherwise.\n\n",
          "input": "**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** true\n**Explanation:** The starting player can guarantee a win by flipping the middle  \"++ \" to become  \"+--+ \".\n\n**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= currentState.length <= 60`\n*   `currentState[i]` is either `'+'` or `'-'`.\n\n**Follow up:** Derive your algorithm's runtime complexity.",
          "output": "def canWin(currentState: str) -> bool:\n    for i in range(len(currentState) - 1):\n        if currentState[i] == '+' and currentState[i + 1] == '+':\n            temp = currentState[:i] + \"--\" + currentState[i + 2:]\n            if not canWin(temp):\n                return True\n    return False\n"
     },
     {
          "instruction": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[10,9,2,5,3,7,101,18\\]\n**Output:** 4\n**Explanation:** The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,0,3,2,3\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** nums = \\[7,7,7,7,7,7,7\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2500`\n*   `-104 <= nums[i] <= 104`\n\n**Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?",
          "output": "def lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n"
     },
     {
          "instruction": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n",
          "input": "**Example 1:**\n\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n\n**Example 2:**\n\n**Input:** prices = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`",
          "output": "def maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit\n"
     },
     {
          "instruction": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,1,5,8\\]\n**Output:** 167\n**Explanation:**\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167\n\n**Example 2:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `0 <= nums[i] <= 100`",
          "output": "def maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n"
     },
     {
          "instruction": "A **super ugly number** is a positive integer whose prime factors are in the array `primes`.\n\nGiven an integer `n` and an array of integers `primes`, return _the_ `nth` _**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit** signed integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 12, primes = \\[2,7,13,19\\]\n**Output:** 32\n**Explanation:** \\[1,2,4,7,8,13,14,16,19,26,28,32\\] is the sequence of the first 12 super ugly numbers given primes = \\[2,7,13,19\\].\n\n**Example 2:**\n\n**Input:** n = 1, primes = \\[2,3,5\\]\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are in the array primes = \\[2,3,5\\].\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= primes.length <= 100`\n*   `2 <= primes[i] <= 1000`\n*   `primes[i]` is **guaranteed** to be a prime number.\n*   All the values of `primes` are **unique** and sorted in **ascending order**.",
          "output": "def nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]\n"
     },
     {
          "instruction": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n",
          "input": "**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`",
          "output": "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1\n"
     },
     {
          "instruction": "Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).\n\n",
          "input": "**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`",
          "output": "dx = (0, 0, 1, -1)\ndy = (1, -1, 0, 0)\n\ndef dfs(matrix, memo, i, j):\n    if memo[i][j] != 0:\n        return memo[i][j]\n    \n    max_len = 0\n    for k in range(4):\n        ni, nj = i + dx[k], j + dy[k]\n        if (0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and matrix[ni][nj] > matrix[i][j]):\n            max_len = max(max_len, dfs(matrix, memo, ni, nj))\n    \n    memo[i][j] = max_len + 1\n    return memo[i][j]\n\ndef longest_increasing_path(matrix):\n    m, n = len(matrix), len(matrix[0])\n    \n    memo = [[0] * n for _ in range(m)]\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            ans = max(ans, dfs(matrix, memo, i, j))\n    \n    return ans\n"
     },
     {
          "instruction": "Given the root of a binary tree, find the largest subtree, which is also a Binary Search Tree (BST), where the largest means subtree has the largest number of nodes.\n\nA **Binary Search Tree (BST)** is a tree in which all the nodes follow the below-mentioned properties:\n\n*   The left subtree values are less than the value of their parent (root) node's value.\n*   The right subtree values are greater than the value of their parent (root) node's value.\n\n**Note:** A subtree must include all of its descendants.\n\n",
          "input": "**Example 1:**\n\n**Input:** root = \\[10,5,15,1,8,null,7\\]\n**Output:** 3\n**Explanation:** The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3.\n\n**Example 2:**\n\n**Input:** root = \\[4,2,7,2,3,5,null,2,null,null,null,null,null,1\\]\n**Output:** 2\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-104 <= Node.val <= 104`\n\n**Follow up:** Can you figure out ways to solve it with `O(n)` time complexity?",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef largestBSTSubtree(root: TreeNode) -> int:\n    def largestBSTUtil(root):\n        if not root:\n            return True, 0, float('inf'), float('-inf')\n        \n        left = largestBSTUtil(root.left)\n        right = largestBSTUtil(root.right)\n        \n        if left[0] and root.val > left[3] and right[0] and root.val < right[2]:\n            largestBST[0] = max(largestBST[0], left[1] + 1 + right[1])\n            return True, left[1] + 1 + right[1], min(root.val, left[2]), max(root.val, right[3])\n        \n        return False, -1, float('inf'), float('-inf')\n    \n    largestBST = [0]\n    largestBSTUtil(root)\n    \n    return largestBST[0]\n"
     },
     {
          "instruction": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return _the maximum amount of money the thief can rob **without alerting the police**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** root = \\[3,2,3,null,3,null,1\\]\n**Output:** 7\n**Explanation:** Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\n**Example 2:**\n\n**Input:** root = \\[3,4,5,1,3,null,1\\]\n**Output:** 9\n**Explanation:** Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 104`",
          "output": "def rob(self, root: TreeNode) -> int:\n    def rob_helper(node):\n        if not node:\n            return 0, 0\n\n        left_with_node, left_without_node = rob_helper(node.left)\n        right_with_node, right_without_node = rob_helper(node.right)\n\n        with_node = node.val + left_without_node + right_without_node\n        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)\n        return with_node, without_node\n\n    return max(rob_helper(root))\n"
     },
     {
          "instruction": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,1\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n\n**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[0,1,1,2,1,2\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n\n**Constraints:**\n\n*   `0 <= n <= 105`\n\n**Follow up:**\n\n*   It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?\n*   Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?",
          "output": "def countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans\n"
     },
     {
          "instruction": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** 2 = 1 + 1, 1 \\* 1 = 1.\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** 36\n**Explanation:** 10 = 3 + 3 + 4, 3 \\* 3 \\* 4 = 36.\n\n**Constraints:**\n\n*   `2 <= n <= 58`",
          "output": "def integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n"
     },
     {
          "instruction": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an \"unlock pattern \" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a **valid** unlock pattern if both of the following are true:\n\n*   All the dots in the sequence are **distinct**.\n*   If the line segment connecting two consecutive dots in the sequence passes through the **center** of any other dot, the other dot **must have previously appeared** in the sequence. No jumps through the center non-selected dots are allowed.\n    *   For example, connecting dots `2` and `9` without dots `5` or `6` appearing beforehand is valid because the line from dot `2` to dot `9` does not pass through the center of either dot `5` or `6`.\n    *   However, connecting dots `1` and `3` without dot `2` appearing beforehand is invalid because the line from dot `1` to dot `3` passes through the center of dot `2`.\n\nHere are some example valid and invalid unlock patterns:\n\n*   The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n*   The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n*   The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n*   The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return _the **number of unique and valid unlock patterns** of the Android grid lock screen that consist of **at least**_ `m` _keys and **at most**_ `n` _keys._\n\nTwo unlock patterns are considered **unique** if there is a dot in one sequence that is not in the other, or the order of the dots is different.\n\n",
          "input": "**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 9\n\n**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 65\n\n**Constraints:**\n\n*   `1 <= m, n <= 9`",
          "output": "def numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt\n"
     },
     {
          "instruction": "You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e., put one inside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n",
          "input": "**Example 1:**\n\n**Input:** envelopes = \\[\\[5,4\\],\\[6,4\\],\\[6,7\\],\\[2,3\\]\\]\n**Output:** 3\n**Explanation:** The maximum number of envelopes you can Russian doll is `3` (\\[2,3\\] => \\[5,4\\] => \\[6,7\\]).\n\n**Example 2:**\n\n**Input:** envelopes = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= envelopes.length <= 105`\n*   `envelopes[i].length == 2`\n*   `1 <= wi, hi <= 105`",
          "output": "from bisect import bisect_left\n\ndef max_envelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    \n    for _, h in envelopes:\n        idx = bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n\n    return len(dp)\n"
     },
     {
          "instruction": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 91\n**Explanation:** The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 8`",
          "output": "def countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total\n"
     },
     {
          "instruction": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[ \"0 \", \"E \", \"0 \", \"0 \"\\],\\[ \"E \", \"0 \", \"W \", \"E \"\\],\\[ \"0 \", \"E \", \"0 \", \"0 \"\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** grid = \\[\\[ \"W \", \"W \", \"W \"\\],\\[ \"0 \", \"0 \", \"0 \"\\],\\[ \"E \", \"E \", \"E \"\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `'W'`, `'E'`, or `'0'`.",
          "output": "def maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result\n"
     },
     {
          "instruction": "Given an `m x n` matrix `matrix` and an integer `k`, return _the max sum of a rectangle in the matrix such that its sum is no larger than_ `k`.\n\nIt is **guaranteed** that there will be a rectangle with a sum no larger than `k`.\n\n",
          "input": "**Example 1:**\n\n**Input:** matrix = \\[\\[1,0,1\\],\\[0,-2,3\\]\\], k = 2\n**Output:** 2\n**Explanation:** Because the sum of the blue rectangle \\[\\[0, 1\\], \\[-2, 3\\]\\] is 2, and 2 is the max number no larger than k (k = 2).\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[2,2,-1\\]\\], k = 3\n**Output:** 3\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-100 <= matrix[i][j] <= 100`\n*   `-105 <= k <= 105`\n\n**Follow up:** What if the number of rows is much larger than the number of columns?",
          "output": "from sortedcontainers import SortedList\n\ndef maxSumSubmatrix(matrix, k):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    max_sum = float('-inf')\n\n    for l in range(cols):\n        sums = [0] * rows\n        for r in range(l, cols):\n            for i in range(rows):\n                sums[i] += matrix[i][r]\n\n            sorted_sums = SortedList()\n            sorted_sums.add(0)\n            curr_sum = 0\n            for sum in sums:\n                curr_sum += sum\n                it = sorted_sums.bisect_left(curr_sum - k)\n                if it != len(sorted_sums):\n                    max_sum = max(max_sum, curr_sum - sorted_sums[it])\n                sorted_sums.add(curr_sum)\n\n    return max_sum\n"
     },
     {
          "instruction": "Given a set of **distinct** positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:\n\n*   `answer[i] % answer[j] == 0`, or\n*   `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions, return any of them.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,2\\]\n**Explanation:** \\[1,3\\] is also accepted.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,4,8\\]\n**Output:** \\[1,2,4,8\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 2 * 109`\n*   All the integers in `nums` are **unique**.",
          "output": "def largestDivisibleSubset(nums):\n    nums.sort()\n    n = len(nums)\n    count = [1] * n\n    prev = [-1] * n\n\n    max_idx = 0\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                count[i] = count[j] + 1\n                prev[i] = j\n        if count[max_idx] < count[i]:\n            max_idx = i\n\n    res = []\n    i = max_idx\n    while i >= 0:\n        res.append(nums[i])\n        i = prev[i]\n\n    return res\n"
     },
     {
          "instruction": "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n**Constraints:**\n\n*   `1 <= n <= 200`",
          "output": "def getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]\n"
     },
     {
          "instruction": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,7,4,9,2,5\\]\n**Output:** 6\n**Explanation:** The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n**Example 2:**\n\n**Input:** nums = \\[1,17,5,10,13,15,10,5,16,8\\]\n**Output:** 7\n**Explanation:** There are several subsequences that achieve this length.\nOne is \\[1, 17, 10, 13, 10, 16, 8\\] with differences (16, -7, 3, -3, 6, -8).\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n\n**Follow up:** Could you solve this in `O(n)` time?",
          "output": "def wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n"
     },
     {
          "instruction": "Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit** integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], target = 4\n**Output:** 7\n**Explanation:**\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n\n**Example 2:**\n\n**Input:** nums = \\[9\\], target = 3\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 1000`\n*   All the elements of `nums` are **unique**.\n*   `1 <= target <= 1000`\n\n**Follow up:** What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?",
          "output": "def combination_sum(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n"
     },
     {
          "instruction": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).\n\n",
          "input": "**Example 1:**\n\n**Input:** s = \"abc\", t = \"ahbgdc\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"axc\", t = \"ahbgdc\"\n**Output:** false\n\n**Constraints:**\n\n*   `0 <= s.length <= 100`\n*   `0 <= t.length <= 104`\n*   `s` and `t` consist only of lowercase English letters.\n\n**Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?",
          "output": "def is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)\n"
     },
     {
          "instruction": "You are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions clock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n*   `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0), F(1), ..., F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[4,3,2,6\\]\n**Output:** 26\n**Explanation:**\nF(0) = (0 \\* 4) + (1 \\* 3) + (2 \\* 2) + (3 \\* 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 \\* 6) + (1 \\* 4) + (2 \\* 3) + (3 \\* 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 \\* 2) + (1 \\* 6) + (2 \\* 4) + (3 \\* 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 \\* 3) + (1 \\* 2) + (2 \\* 6) + (3 \\* 4) = 0 + 2 + 12 + 12 = 26\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n\n**Example 2:**\n\n**Input:** nums = \\[100\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `-100 <= nums[i] <= 100`",
          "output": "def maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f\n"
     },
     {
          "instruction": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
          "output": "def min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n"
     },
     {
          "instruction": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.\n\n",
          "input": "**Example 1:**\n\n**Input:** stones = \\[0,1,3,5,6,8,12,17\\]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n**Example 2:**\n\n**Input:** stones = \\[0,1,2,3,4,8,9,11\\]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n**Constraints:**\n\n*   `2 <= stones.length <= 2000`\n*   `0 <= stones[i] <= 231 - 1`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.",
          "output": "def can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])\n"
     },
     {
          "instruction": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`",
          "output": "def splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n"
     },
     {
          "instruction": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\nGiven an integer array `nums`, return _the number of arithmetic **subarrays** of_ `nums`.\n\nA **subarray** is a contiguous subsequence of the array.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 3\n**Explanation:** We have 3 arithmetic slices in nums: \\[1, 2, 3\\], \\[2, 3, 4\\] and \\[1,2,3,4\\] itself.\n\n**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-1000 <= nums[i] <= 1000`",
          "output": "def numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count\n"
     },
     {
          "instruction": "Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,5,11,5\\]\n**Output:** true\n**Explanation:** The array can be partitioned as \\[1, 5, 5\\] and \\[11\\].\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,5\\]\n**Output:** false\n**Explanation:** The array cannot be partitioned into equal sum subsets.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 100`",
          "output": "def canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]\n"
     },
     {
          "instruction": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.\n\nThe order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.\n\n",
          "input": "**Example 1:**\n\n**Input:** sentence = \\[ \"hello \", \"world \"\\], rows = 2, cols = 8\n**Output:** 1\n**Explanation:**\nhello---\nworld---\nThe character '-' signifies an empty space on the screen.\n\n**Example 2:**\n\n**Input:** sentence = \\[ \"a \",  \"bcd \",  \"e \"\\], rows = 3, cols = 6\n**Output:** 2\n**Explanation:**\na-bcd- \ne-a---\nbcd-e-\nThe character '-' signifies an empty space on the screen.\n\n**Example 3:**\n\n**Input:** sentence = \\[ \"i \", \"had \", \"apple \", \"pie \"\\], rows = 4, cols = 5\n**Output:** 1\n**Explanation:**\ni-had\napple\npie-i\nhad--\nThe character '-' signifies an empty space on the screen.\n\n**Constraints:**\n\n*   `1 <= sentence.length <= 100`\n*   `1 <= sentence[i].length <= 10`\n*   `sentence[i]` consists of lowercase English letters.\n*   `1 <= rows, cols <= 2 * 104`",
          "output": "def words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result\n"
     },
     {
          "instruction": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.\n\n",
          "input": "**Example 1:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,3\\]\\]\n**Output:** 1\n**Explanation:** \\[1,3\\] can be removed and the rest of the intervals are non-overlapping.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[1,2\\],\\[1,2\\]\\]\n**Output:** 2\n**Explanation:** You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping.\n\n**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 0\n**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `-5 * 104 <= starti < endi <= 5 * 104`",
          "output": "def eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n"
     },
     {
          "instruction": "Given an integer array `nums`, return _the number of all the **arithmetic subsequences** of_ `nums`.\n\nA sequence of numbers is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1, 3, 5, 7, 9]`, `[7, 7, 7, 7]`, and `[3, -1, -5, -9]` are arithmetic sequences.\n*   For example, `[1, 1, 2, 5, 7]` is not an arithmetic sequence.\n\nA **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n*   For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`.\n\nThe test cases are generated so that the answer fits in **32-bit** integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,4,6,8,10\\]\n**Output:** 7\n**Explanation:** All arithmetic subsequence slices are:\n\\[2,4,6\\]\n\\[4,6,8\\]\n\\[6,8,10\\]\n\\[2,4,6,8\\]\n\\[4,6,8,10\\]\n\\[2,4,6,8,10\\]\n\\[2,6,10\\]\n\n**Example 2:**\n\n**Input:** nums = \\[7,7,7,7,7\\]\n**Output:** 16\n**Explanation:** Any subsequence of this array is arithmetic.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`",
          "output": "def numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res\n"
     },
     {
          "instruction": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1.  Choose some live pigs to feed.\n2.  For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3.  Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4.  After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5.  Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return _the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time_.\n\n",
          "input": "**Example 1:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 15\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n\n**Example 2:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 30\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n\n**Constraints:**\n\n*   `1 <= buckets <= 1000`\n*   `1 <= minutesToDie <= minutesToTest <= 100`",
          "output": "def poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs\n"
     },
     {
          "instruction": "In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n",
          "input": "**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`",
          "output": "def canIWin(maxChoosableInteger, desiredTotal):\n    if maxChoosableInteger >= desiredTotal: return True\n    if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal: return False\n\n    memo = {}\n        \n    def canWin(state):\n        if state in memo:\n            return memo[state]\n        for i in range(1, maxChoosableInteger + 1):\n            bitCheck = 1 << i\n            if (state & bitCheck) == 0:\n                if not canWin(state | bitCheck):\n                    memo[state] = True\n                    return True\n    \n        memo[state] = False\n        return False\n\n    return canWin(0)\n"
     },
     {
          "instruction": "You are given an array of transactions `transactions` where `transactions[i] = [fromi, toi, amounti]` indicates that the person with `ID = fromi` gave `amounti $` to the person with `ID = toi`.\n\nReturn _the minimum number of transactions required to settle the debt_.\n\n",
          "input": "**Example 1:**\n\n**Input:** transactions = \\[\\[0,1,10\\],\\[2,0,5\\]\\]\n**Output:** 2\n**Explanation:**\nPerson #0 gave person #1 $10.\nPerson #2 gave person #0 $5.\nTwo transactions are needed. One way to settle the debt is person #1 pays person #0 and #2 $5 each.\n\n**Example 2:**\n\n**Input:** transactions = \\[\\[0,1,10\\],\\[1,0,1\\],\\[1,2,5\\],\\[2,0,5\\]\\]\n**Output:** 1\n**Explanation:**\nPerson #0 gave person #1 $10.\nPerson #1 gave person #0 $1.\nPerson #1 gave person #2 $5.\nPerson #2 gave person #0 $5.\nTherefore, person #1 only need to give person #0 $4, and all debt is settled.\n\n**Constraints:**\n\n*   `1 <= transactions.length <= 8`\n*   `transactions[i].length == 3`\n*   `0 <= fromi, toi < 12`\n*   `fromi != toi`\n*   `1 <= amounti <= 100`",
          "output": "from collections import defaultdict\n\ndef minTransfers(transactions):\n    balances = defaultdict(int)\n    for transaction in transactions:\n        balances[transaction[0]] -= transaction[2]\n        balances[transaction[1]] += transaction[2]\n\n    debts = [balance for balance in balances.values() if balance != 0]\n    return dfs(debts, 0)\n\ndef dfs(debts, start):\n    while start < len(debts) and debts[start] == 0:\n        start += 1\n    if start == len(debts):\n        return 0\n    result = float('inf')\n    for i in range(start + 1, len(debts)):\n        if (debts[start] > 0) != (debts[i] > 0):\n            debts[i] += debts[start]\n            result = min(result, 1 + dfs(debts, start + 1))\n            debts[i] -= debts[start]\n    return result\n"
     },
     {
          "instruction": "We define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times.\n\n*   For example, `str == [ \"abc \", 3] == \"abcabcabc \"`.\n\nWe define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`.\n\n*   For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded underlined characters.\n\nYou are given two strings `s1` and `s2` and two integers `n1` and `n2`. You have the two strings `str1 = [s1, n1]` and `str2 = [s2, n2]`.\n\nReturn _the maximum integer_ `m` _such that_ `str = [str2, m]` _can be obtained from_ `str1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n**Output:** 2\n\n**Example 2:**\n\n**Input:** s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.\n*   `1 <= n1, n2 <= 106`",
          "output": "def getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2\n"
     },
     {
          "instruction": "We define the string `base` to be the infinite wraparound string of `\"abcdefghijklmnopqrstuvwxyz \"`, so `base` will look like this:\n\n*   `\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd.... \"`.\n\nGiven a string `s`, return _the number of **unique non-empty substrings** of_ `s` _are present in_ `base`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** Only the substring  \"a \" of s is in base.\n\n**Example 2:**\n\n**Input:** s =  \"cac \"\n**Output:** 2\n**Explanation:** There are two substrings ( \"a \",  \"c \") of s in base.\n\n**Example 3:**\n\n**Input:** s =  \"zab \"\n**Output:** 6\n**Explanation:** There are six substrings ( \"z \",  \"a \",  \"b \",  \"za \",  \"ab \", and  \"zab \") of s in base.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
          "output": "def findSubstringInWraproundString(p: str) -> int:\n    cnt = [0] * 26\n    length = 0\n\n    for i in range(len(p)):\n        if i > 0 and (p[i] == chr(ord(p[i - 1]) + 1) or ord(p[i - 1]) - ord(p[i]) == 25):\n            length += 1\n        else:\n            length = 1\n        cnt[ord(p[i]) - ord('a')] = max(cnt[ord(p[i]) - ord('a')], length)\n\n    return sum(cnt)\n"
     },
     {
          "instruction": "Given a string `s`, encode the string such that its encoded length is the shortest.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. `k` should be a positive integer.\n\nIf an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return **any of them**.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aaa \"\n**Output:**  \"aaa \"\n**Explanation:** There is no way to encode it such that it is shorter than the input string, so we do not encode it.\n\n**Example 2:**\n\n**Input:** s =  \"aaaaa \"\n**Output:**  \"5\\[a\\] \"\n**Explanation:**  \"5\\[a\\] \" is shorter than  \"aaaaa \" by 1 character.\n\n**Example 3:**\n\n**Input:** s =  \"aaaaaaaaaa \"\n**Output:**  \"10\\[a\\] \"\n**Explanation:**  \"a9\\[a\\] \" or  \"9\\[a\\]a \" are also valid solutions, both of them have the same length = 5, which is the same as  \"10\\[a\\] \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 150`\n*   `s` consists of only lowercase English letters.",
          "output": "def encode(s: str) -> str:\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            reps = n // i\n            sub = s[:i]\n            composed = sub * reps\n            if s == composed:\n                return f\"{reps}[{sub}]\"\n    return s\n"
     },
     {
          "instruction": "Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.\n\nA **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.\n\n",
          "input": "**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"cats \", \"catsdogcats \", \"dog \", \"dogcatsdog \", \"hippopotamuses \", \"rat \", \"ratcatdogcat \"\\]\n**Output:** \\[ \"catsdogcats \", \"dogcatsdog \", \"ratcatdogcat \"\\]\n**Explanation:**  \"catsdogcats \" can be concatenated by  \"cats \",  \"dog \" and  \"cats \"; \n \"dogcatsdog \" can be concatenated by  \"dog \",  \"cats \" and  \"dog \"; \n \"ratcatdogcat \" can be concatenated by  \"rat \",  \"cat \",  \"dog \" and  \"cat \".\n\n**Example 2:**\n\n**Input:** words = \\[ \"cat \", \"dog \", \"catdog \"\\]\n**Output:** \\[ \"catdog \"\\]\n\n**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= words[i].length <= 30`\n*   `words[i]` consists of only lowercase English letters.\n*   All the strings of `words` are **unique**.\n*   `1 <= sum(words[i].length) <= 105`",
          "output": "def is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result\n"
     },
     {
          "instruction": "You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**.\n\nReturn `true` if you can make this square and `false` otherwise.\n\n",
          "input": "**Example 1:**\n\n**Input:** matchsticks = \\[1,1,2,2,2\\]\n**Output:** true\n**Explanation:** You can form a square with length 2, one side of the square came two sticks with length 1.\n\n**Example 2:**\n\n**Input:** matchsticks = \\[3,3,3,3,4\\]\n**Output:** false\n**Explanation:** You cannot find a way to form a square with all the matchsticks.\n\n**Constraints:**\n\n*   `1 <= matchsticks.length <= 15`\n*   `1 <= matchsticks[i] <= 108`",
          "output": "from itertools import chain\n\ndef makesquare(matchsticks):\n    if len(matchsticks) < 4:\n        return False\n    total = sum(matchsticks)\n    if total % 4:\n        return False\n    target = total // 4\n    matchsticks.sort(reverse=True)\n    sums = [0]*4\n    return dfs(matchsticks, sums, target, 0)\n\ndef dfs(matchsticks, sums, target, index):\n    if index == len(matchsticks):\n        return sums[0] == target and sums[1] == target and sums[2] == target\n    for i in range(4):\n        if sums[i] + matchsticks[index] <= target:\n            sums[i] += matchsticks[index]\n            if dfs(matchsticks, sums, target, index + 1):\n                return True\n            sums[i] -= matchsticks[index]\n    return False\n"
     },
     {
          "instruction": "You are given an array of binary strings `strs` and two integers `m` and `n`.\n\nReturn _the size of the largest subset of `strs` such that there are **at most**_ `m` `0`_'s and_ `n` `1`_'s in the subset_.\n\nA set `x` is a **subset** of a set `y` if all elements of `x` are also elements of `y`.\n\n",
          "input": "**Example 1:**\n\n**Input:** strs = \\[ \"10 \", \"0001 \", \"111001 \", \"1 \", \"0 \"\\], m = 5, n = 3\n**Output:** 4\n**Explanation:** The largest subset with at most 5 0's and 3 1's is { \"10 \",  \"0001 \",  \"1 \",  \"0 \"}, so the answer is 4.\nOther valid but smaller subsets include { \"0001 \",  \"1 \"} and { \"10 \",  \"1 \",  \"0 \"}.\n{ \"111001 \"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.\n\n**Example 2:**\n\n**Input:** strs = \\[ \"10 \", \"0 \", \"1 \"\\], m = 1, n = 1\n**Output:** 2\n**Explanation:** The largest subset is { \"0 \",  \"1 \"}, so the answer is 2.\n\n**Constraints:**\n\n*   `1 <= strs.length <= 600`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists only of digits `'0'` and `'1'`.\n*   `1 <= m, n <= 100`",
          "output": "def findMaxForm(strs, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for s in strs:\n        ones = s.count('1')\n        zeros = len(s) - ones\n        \n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    \n    return dp[m][n]\n"
     },
     {
          "instruction": "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`",
          "output": "def can_win(nums):\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = nums[i]\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n    return dp[0][n - 1] >= 0\n"
     },
     {
          "instruction": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array if you can flip at most one_ `0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,0,1,1,0\\]\n**Output:** 4\n**Explanation:** \n- If we flip the first zero, nums becomes \\[1,1,1,1,0\\] and we have 4 consecutive ones.\n- If we flip the second zero, nums becomes \\[1,0,1,1,1\\] and we have 3 consecutive ones.\nThe max number of consecutive ones is 4.\n\n**Example 2:**\n\n**Input:** nums = \\[1,0,1,1,0,1\\]\n**Output:** 4\n**Explanation:** \n- If we flip the first zero, nums becomes \\[1,1,1,1,0,1\\] and we have 4 consecutive ones.\n- If we flip the second zero, nums becomes \\[1,0,1,1,1,1\\] and we have 4 consecutive ones.\nThe max number of consecutive ones is 4.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.\n\n**Follow up:** What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?",
          "output": "def findMaxConsecutiveOnes(nums: List[int]) -> int:\n    max_count, count_zeros, left = 0, 0, 0\n    for right in range(len(nums)):\n        if nums[right] == 0:\n            count_zeros += 1\n        while count_zeros > 1:\n            if nums[left] == 0:\n                count_zeros -= 1\n            left += 1\n        max_count = max(max_count, right - left + 1)\n    return max_count\n"
     },
     {
          "instruction": "You are playing a variation of the game Zuma.\n\nIn this variation of Zuma, there is a **single row** of colored balls on a board, where each ball can be colored red `'R'`, yellow `'Y'`, blue `'B'`, green `'G'`, or white `'W'`. You also have several colored balls in your hand.\n\nYour goal is to **clear all** of the balls from the board. On each turn:\n\n*   Pick **any** ball from your hand and insert it in between two balls in the row or on either end of the row.\n*   If there is a group of **three or more consecutive balls** of the **same color**, remove the group of balls from the board.\n    *   If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.\n*   If there are no more balls on the board, then you win the game.\n*   Repeat this process until you either win or do not have any more balls in your hand.\n\nGiven a string `board`, representing the row of balls on the board, and a string `hand`, representing the balls in your hand, return _the **minimum** number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return_ `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** board =  \"WRRBBW \", hand =  \"RB \"\n**Output:** -1\n**Explanation:** It is impossible to clear all the balls. The best you can do is:\n- Insert 'R' so the board becomes WRRRBBW. WRRRBBW -> WBBW.\n- Insert 'B' so the board becomes WBBBW. WBBBW -> WW.\nThere are still balls remaining on the board, and you are out of balls to insert.\n\n**Example 2:**\n\n**Input:** board =  \"WWRRBBWW \", hand =  \"WRBRW \"\n**Output:** 2\n**Explanation:** To make the board empty:\n- Insert 'R' so the board becomes WWRRRBBWW. WWRRRBBWW -> WWBBWW.\n- Insert 'B' so the board becomes WWBBBWW. WWBBBWW -> WWWW -> empty.\n2 balls from your hand were needed to clear the board.\n\n**Example 3:**\n\n**Input:** board =  \"G \", hand =  \"GGGGG \"\n**Output:** 2\n**Explanation:** To make the board empty:\n- Insert 'G' so the board becomes GG.\n- Insert 'G' so the board becomes GGG. GGG -> empty.\n2 balls from your hand were needed to clear the board.\n\n**Constraints:**\n\n*   `1 <= board.length <= 16`\n*   `1 <= hand.length <= 5`\n*   `board` and `hand` consist of the characters `'R'`, `'Y'`, `'B'`, `'G'`, and `'W'`.\n*   The initial row of balls on the board will **not** have any groups of three or more consecutive balls of the same color.",
          "output": "from collections import Counter\n\ndef find_min_step(board: str, hand: str) -> int:\n    def find_min_step_helper(board, memo, hand):\n        if not board:\n            return 0\n        if board in memo:\n            return memo[board]\n\n        result = float('inf')\n        i = 0\n        while i < len(board):\n            j = i\n            while j < len(board) and board[i] == board[j]:\n                j += 1            \n\n            color = board[i]\n            required = 3 - (j - i)\n            if hand[color] >= required:\n                hand[color] -= required\n                next_board = board[:i] + board[j:]\n                tmp = find_min_step_helper(next_board, memo, hand)\n                if tmp != -1:\n                    result = min(result, tmp + required)\n                hand[color] += required\n            i = j\n\n        memo[board] = -1 if result == float('inf') else result\n        return memo[board]\n\n    hand_count = Counter(hand)\n    memo = {}\n    return find_min_step_helper(board, memo, hand_count)\n"
     },
     {
          "instruction": "Bob is standing at cell `(0, 0)`, and he wants to reach `destination`: `(row, column)`. He can only travel **right** and **down**. You are going to help Bob by providing **instructions** for him to reach `destination`.\n\nThe **instructions** are represented as a string, where each character is either:\n\n*   `'H'`, meaning move horizontally (go **right**), or\n*   `'V'`, meaning move vertically (go **down**).\n\nMultiple **instructions** will lead Bob to `destination`. For example, if `destination` is `(2, 3)`, both `\"HHHVV \"` and `\"HVHVH \"` are valid **instructions**.\n\nHowever, Bob is very picky. Bob has a lucky number `k`, and he wants the `kth` **lexicographically smallest instructions** that will lead him to `destination`. `k` is **1-indexed**.\n\nGiven an integer array `destination` and an integer `k`, return _the_ `kth` _**lexicographically smallest instructions** that will take Bob to_ `destination`.\n\n",
          "input": "**Example 1:**\n\n**Input:** destination = \\[2,3\\], k = 1\n**Output:**  \"HHHVV \"\n**Explanation:** All the instructions that reach (2, 3) in lexicographic order are as follows:\n\\[ \"HHHVV \",  \"HHVHV \",  \"HHVVH \",  \"HVHHV \",  \"HVHVH \",  \"HVVHH \",  \"VHHHV \",  \"VHHVH \",  \"VHVHH \",  \"VVHHH \"\\].\n\n**Example 2:**\n\n**Input:** destination = \\[2,3\\], k = 2\n**Output:**  \"HHVHV \"\n\n**Example 3:**\n\n**Input:** destination = \\[2,3\\], k = 3\n**Output:**  \"HHVVH \"\n\n**Constraints:**\n\n*   `destination.length == 2`\n*   `1 <= row, column <= 15`\n*   `1 <= k <= nCr(row + column, row)`, where `nCr(a, b)` denotes `a` choose `b`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039.",
          "output": "from collections import defaultdict\n\ndef dfs(node, tree, labels, ans, count):\n    prev_count = count[labels[node]]\n    count[labels[node]] += 1\n    ans[node] = count[labels[node]] - prev_count\n\n    for child in tree[node]:\n        dfs(child, tree, labels, ans, count)\n\n    count[labels[node]] = prev_count\n\ndef countSubTrees(n, edges, labels):\n    tree = defaultdict(list)\n    for edge in edges:\n        tree[edge[1]].append(edge[0])\n\n    ans = [0] * n\n    count = defaultdict(int)\n    dfs(0, tree, labels, ans, count)\n\n    return ans\n"
     },
     {
          "instruction": "You are given an integer array `nums` and an integer `target`.\n\nYou want to build an **expression** out of nums by adding one of the symbols `'+'` and `'-'` before each integer in nums and then concatenate all the integers.\n\n*   For example, if `nums = [2, 1]`, you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `\"+2-1 \"`.\n\nReturn the number of different **expressions** that you can build, which evaluates to `target`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,1,1,1,1\\], target = 3\n**Output:** 5\n**Explanation:** There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n\n**Example 2:**\n\n**Input:** nums = \\[1\\], target = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 1000`\n*   `0 <= sum(nums[i]) <= 1000`\n*   `-1000 <= target <= 1000`",
          "output": "def findTargetSumWays(nums, target):\n    total_sum = sum(nums)\n    if total_sum < target or (total_sum + target) % 2 != 0:\n        return 0\n    target_sum = (total_sum + target) // 2\n    dp = [0] * (target_sum + 1)\n    dp[0] = 1\n    for num in nums:\n        for j in range(target_sum, num - 1, -1):\n            dp[j] += dp[j - num]\n    return dp[target_sum]\n"
     },
     {
          "instruction": "A **subarray** of a **0-indexed** integer array is a contiguous **non-empty** sequence of elements within an array.\n\nThe **alternating subarray sum** of a subarray that ranges from index `i` to `j` (**inclusive**, `0 <= i <= j < nums.length`) is `nums[i] - nums[i+1] + nums[i+2] - ... +/- nums[j]`.\n\nGiven a **0-indexed** integer array `nums`, return _the **maximum alternating subarray sum** of any subarray of_ `nums`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,-1,1,2\\]\n**Output:** 5\n**Explanation:**\nThe subarray \\[3,-1,1\\] has the largest alternating subarray sum.\nThe alternating subarray sum is 3 - (-1) + 1 = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 2\n**Explanation:**\nThe subarrays \\[2\\], \\[2,2,2\\], and \\[2,2,2,2,2\\] have the largest alternating subarray sum.\nThe alternating subarray sum of \\[2\\] is 2.\nThe alternating subarray sum of \\[2,2,2\\] is 2 - 2 + 2 = 2.\nThe alternating subarray sum of \\[2,2,2,2,2\\] is 2 - 2 + 2 - 2 + 2 = 2.\n\n**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:**\nThere is only one non-empty subarray, which is \\[1\\].\nThe alternating subarray sum is 1.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`",
          "output": "def maxAlternatingSum(nums):\n    odd, even = 0, 0\n    for num in nums:\n        newOdd = max(even + num, odd)\n        even = max(odd - num, even)\n        odd = newOdd\n    return odd\n"
     },
     {
          "instruction": "In the video game Fallout 4, the quest **\"Road to Freedom \"** requires players to reach a metal dial called the **\"Freedom Trail Ring \"** and use the dial to spell a specific keyword to open the door.\n\nGiven a string `ring` that represents the code engraved on the outer ring and another string `key` that represents the keyword that needs to be spelled, return _the minimum number of steps to spell all the characters in the keyword_.\n\nInitially, the first character of the ring is aligned at the `\"12:00 \"` direction. You should spell all the characters in `key` one by one by rotating `ring` clockwise or anticlockwise to make each character of the string key aligned at the `\"12:00 \"` direction and then by pressing the center button.\n\nAt the stage of rotating the ring to spell the key character `key[i]`:\n\n1.  You can rotate the ring clockwise or anticlockwise by one place, which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `\"12:00 \"` direction, where this character must equal `key[i]`.\n2.  If the character `key[i]` has been aligned at the `\"12:00 \"` direction, press the center button to spell, which also counts as **one step**. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.\n\n",
          "input": "**Example 1:**\n\n**Input:** ring =  \"godding \", key =  \"gd \"\n**Output:** 4\n**Explanation:**\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring  \"godding \" anticlockwise by two steps to make it become  \"ddinggo \".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\n**Example 2:**\n\n**Input:** ring =  \"godding \", key =  \"godding \"\n**Output:** 13\n\n**Constraints:**\n\n*   `1 <= ring.length, key.length <= 100`\n*   `ring` and `key` consist of only lower case English letters.\n*   It is guaranteed that `key` could always be spelled by rotating `ring`.",
          "output": "def find_rotate_steps(ring: str, key: str) -> int:\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    return dp[0][0] + m\n"
     },
     {
          "instruction": "Given a string `s`, find _the longest palindromic **subsequence**'s length in_ `s`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"bbbab \"\n**Output:** 4\n**Explanation:** One possible longest palindromic subsequence is  \"bbbb \".\n\n**Example 2:**\n\n**Input:** s =  \"cbbd \"\n**Output:** 2\n**Explanation:** One possible longest palindromic subsequence is  \"bb \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists only of lowercase English letters.",
          "output": "def longestPalindromeSubseq(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n                \n    return dp[0][n - 1]\n"
     },
     {
          "instruction": "Suppose you have `n` integers labeled `1` through `n`. A permutation of those `n` integers `perm` (**1-indexed**) is considered a **beautiful arrangement** if for every `i` (`1 <= i <= n`), **either** of the following is true:\n\n*   `perm[i]` is divisible by `i`.\n*   `i` is divisible by `perm[i]`.\n\nGiven an integer `n`, return _the **number** of the **beautiful arrangements** that you can construct_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** \nThe first beautiful arrangement is \\[1,2\\]:\n    - perm\\[1\\] = 1 is divisible by i = 1\n    - perm\\[2\\] = 2 is divisible by i = 2\nThe second beautiful arrangement is \\[2,1\\]:\n    - perm\\[1\\] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm\\[2\\] = 1\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 15`",
          "output": "def countArrangement(n: int) -> int:\n    def helper(idx: int, visited: List[bool], n: int) -> int:\n        if idx > n:\n            return 1\n\n        count = 0\n        for i in range(1, n+1):\n            if not visited[i] and (idx % i == 0 or i % idx == 0):\n                visited[i] = True\n                count += helper(idx+1, visited, n)\n                visited[i] = False\n\n        return count\n\n    visited = [False] * (n+1)\n    return helper(1, visited, n)\n"
     },
     {
          "instruction": "Given an `m x n` binary matrix `mat`, return _the distance of the nearest_ `0` _for each cell_.\n\nThe distance between two adjacent cells is `1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,1,0\\],\\[1,2,1\\]\\]\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.\n*   There is at least one `0` in `mat`.",
          "output": "from collections import deque\n\ndef updateMatrix(mat):\n    m, n = len(mat), len(mat[0])\n    distance = [[0 if mat[i][j] == 0 else float('inf') for j in range(n)] for i in range(m)]\n    queue = deque([(i, j) for i in range(m) for j in range(n) if mat[i][j] == 0])\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            newX, newY = x + dx, y + dy\n            if 0 <= newX < m and 0 <= newY < n and distance[newX][newY] > distance[x][y] + 1:\n                distance[newX][newY] = distance[x][y] + 1\n                queue.append((newX, newY))\n\n    return distance\n"
     },
     {
          "instruction": "You are given several `boxes` with different colors represented by different positive numbers.\n\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.\n\nReturn _the maximum points you can get_.\n\n",
          "input": "**Example 1:**\n\n**Input:** boxes = \\[1,3,2,2,2,3,4,3,1\\]\n**Output:** 23\n**Explanation:**\n\\[1, 3, 2, 2, 2, 3, 4, 3, 1\\] \n----> \\[1, 3, 3, 4, 3, 1\\] (3\\*3=9 points) \n----> \\[1, 3, 3, 3, 1\\] (1\\*1=1 points) \n----> \\[1, 1\\] (3\\*3=9 points) \n----> \\[\\] (2\\*2=4 points)\n\n**Example 2:**\n\n**Input:** boxes = \\[1,1,1\\]\n**Output:** 9\n\n**Example 3:**\n\n**Input:** boxes = \\[1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= boxes.length <= 100`\n*   `1 <= boxes[i] <= 100`",
          "output": "def removeBoxes(boxes):\n    def dfs(l, r, k):\n        if l > r: return 0\n        if dp[l][r][k] != 0: return dp[l][r][k]\n\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n            \n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)\n\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))\n                \n        return dp[l][r][k]\n\n    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]\n    return dfs(0, len(boxes) - 1, 0)\n"
     },
     {
          "instruction": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n`, return _the **number** of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it **modulo**_ `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 8\n**Explanation:** There are 8 records with length 2 that are eligible for an award:\n \"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2).\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 3\n\n**Example 3:**\n\n**Input:** n = 10101\n**Output:** 183236316\n\n**Constraints:**\n\n*   `1 <= n <= 105`",
          "output": "def checkRecord(n: int) -> int:\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M\n"
     },
     {
          "instruction": "You are given an integer array `nums`. The adjacent integers in `nums` will perform the float division.\n\n*   For example, for `nums = [2,3,4]`, we will evaluate the expression `\"2/3/4 \"`.\n\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.\n\nReturn _the corresponding expression that has the maximum value in string format_.\n\n**Note:** your expression should not contain redundant parenthesis.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1000,100,10,2\\]\n**Output:**  \"1000/(100/10/2) \"\n**Explanation:** 1000/(100/10/2) = 1000/((100/10)/2) = 200\nHowever, the bold parenthesis in  \"1000/(**(**100/10**)**/2) \" are redundant since they do not influence the operation priority.\nSo you should return  \"1000/(100/10/2) \".\nOther cases:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n\n**Example 2:**\n\n**Input:** nums = \\[2,3,4\\]\n**Output:**  \"2/(3/4) \"\n**Explanation:** (2/(3/4)) = 8/3 = 2.667\nIt can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667\n\n**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `2 <= nums[i] <= 1000`\n*   There is only one optimal division for the given input.",
          "output": "def optimal_division(nums):\n    n = len(nums)\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return str(nums[0]) + '/' + str(nums[1])\n    res = str(nums[0]) + '/('\n    for i in range(1, n - 1):\n        res += str(nums[i]) + '/'\n    res += str(nums[n - 1]) + ')'\n    return res\n"
     },
     {
          "instruction": "Given an `m x n` binary matrix `mat`, return _the length of the longest line of consecutive one in the matrix_.\n\nThe line could be horizontal, vertical, diagonal, or anti-diagonal.\n\n",
          "input": "**Example 1:**\n\n**Input:** mat = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** mat = \\[\\[1,1,1,1\\],\\[0,1,1,0\\],\\[0,0,0,1\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 104`\n*   `1 <= m * n <= 104`\n*   `mat[i][j]` is either `0` or `1`.",
          "output": "def longestLine(mat):\n    rows, cols = len(mat), len(mat[0])\n    max_length = 0\n    dp = [[[0, 0, 0, 0] for _ in range(cols)] for _ in range(rows)]\n\n    for r in range(rows):\n        for c in range(cols):\n            if mat[r][c] == 1:\n                dp[r][c][0] = dp[r - 1][c][0] + 1 if r > 0 else 1\n                dp[r][c][1] = dp[r][c - 1][1] + 1 if c > 0 else 1\n                dp[r][c][2] = dp[r - 1][c - 1][2] + 1 if r > 0 and c > 0 else 1\n                dp[r][c][3] = dp[r - 1][c + 1][3] + 1 if r > 0 and c < cols - 1 else 1\n                max_length = max(max_length, max(dp[r][c]))\n\n    return max_length\n"
     },
     {
          "instruction": "LeetCode wants to give one of its best employees the option to travel among `n` cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\n\nRules and restrictions:\n\n1.  You can only travel among `n` cities, represented by indexes from `0` to `n - 1`. Initially, you are in the city indexed `0` on **Monday**.\n2.  The cities are connected by flights. The flights are represented as an `n x n` matrix (not necessarily symmetrical), called `flights` representing the airline status from the city `i` to the city `j`. If there is no flight from the city `i` to the city `j`, `flights[i][j] == 0`; Otherwise, `flights[i][j] == 1`. Also, `flights[i][i] == 0` for all `i`.\n3.  You totally have `k` weeks (each week has **seven days**) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we do not consider the impact of flight time.\n4.  For each city, you can only have restricted vacation days in different weeks, given an `n x k` matrix called `days` representing this relationship. For the value of `days[i][j]`, it represents the maximum days you could take a vacation in the city `i` in the week `j`.\n5.  You could stay in a city beyond the number of vacation days, but you should work on the extra days, which will not be counted as vacation days.\n6.  If you fly from city `A` to city `B` and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city `B` in that week.\n7.  We do not consider the impact of flight hours on the calculation of vacation days.\n\nGiven the two matrices `flights` and `days`, return _the maximum vacation days you could take during_ `k` _weeks_.\n\n",
          "input": "**Example 1:**\n\n**Input:** flights = \\[\\[0,1,1\\],\\[1,0,1\\],\\[1,1,0\\]\\], days = \\[\\[1,3,1\\],\\[6,0,3\\],\\[3,3,3\\]\\]\n**Output:** 12\n**Explanation:**\nOne of the best strategies is:\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.\n(Although you start at city 0, we could also fly to and start at other cities since it is Monday.)\n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\n3rd week : stay at city 2, and play 3 days and work 4 days.\nAns = 6 + 3 + 3 = 12.\n\n**Example 2:**\n\n**Input:** flights = \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\], days = \\[\\[1,1,1\\],\\[7,7,7\\],\\[7,7,7\\]\\]\n**Output:** 3\n**Explanation:**\nSince there are no flights that enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. \nFor each week, you only have one day to play and six days to work.\nSo the maximum number of vacation days is 3.\nAns = 1 + 1 + 1 = 3.\n\n**Example 3:**\n\n**Input:** flights = \\[\\[0,1,1\\],\\[1,0,1\\],\\[1,1,0\\]\\], days = \\[\\[7,0,0\\],\\[0,7,0\\],\\[0,0,7\\]\\]\n**Output:** 21\n**Explanation:**\nOne of the best strategies is:\n1st week : stay at city 0, and play 7 days.\n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\nAns = 7 + 7 + 7 = 21\n\n**Constraints:**\n\n*   `n == flights.length`\n*   `n == flights[i].length`\n*   `n == days.length`\n*   `k == days[i].length`\n*   `1 <= n, k <= 100`\n*   `flights[i][j]` is either `0` or `1`.\n*   `0 <= days[i][j] <= 7`",
          "output": "def maxVacationDays(flights, days):\n    n = len(flights)\n    k = len(days[0])\n    memo = [[-1] * k for _ in range(n)]\n\n    def dfs(currentWeek, currentCity):\n        if currentWeek == k:\n            return 0\n        if memo[currentCity][currentWeek] != -1:\n            return memo[currentCity][currentWeek]\n\n        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)\n\n        for i in range(n):\n            if flights[currentCity][i] == 1:\n                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))\n\n        memo[currentCity][currentWeek] = maxVacation\n        return maxVacation\n\n    return dfs(0, 0)\n"
     },
     {
          "instruction": "There is an `m x n` grid with a ball. The ball is initially at the position `[startRow, startColumn]`. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply **at most** `maxMove` moves to the ball.\n\nGiven the five integers `m`, `n`, `maxMove`, `startRow`, `startColumn`, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n**Output:** 6\n\n**Example 2:**\n\n**Input:** m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n**Output:** 12\n\n**Constraints:**\n\n*   `1 <= m, n <= 50`\n*   `0 <= maxMove <= 50`\n*   `0 <= startRow < m`\n*   `0 <= startColumn < n`",
          "output": "def findPaths(m, n, maxMove, startRow, startColumn):               \n    MOD = 10**9 + 7                     \n    dp = [[[0]* n for _ in range(m)] for _ in range(maxMove + 1)]\n    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for k in range(1, maxMove + 1):                                \n        for i in range(m):                                         \n            for j in range(n):                                           \n                for move in moves:              \n                    ni, nj = i + move[0], j + move[1]\n                    if ni < 0 or ni >= m or nj < 0 or nj >= n:                                 \n                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          \n                    else:\n                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD\n\n    return dp[maxMove][startRow][startColumn]\n"
     },
     {
          "instruction": "Given two strings `word1` and `word2`, return _the minimum number of **steps** required to make_ `word1` _and_ `word2` _the same_.\n\nIn one **step**, you can delete exactly one character in either string.\n\n",
          "input": "**Example 1:**\n\n**Input:** word1 =  \"sea \", word2 =  \"eat \"\n**Output:** 2\n**Explanation:** You need one step to make  \"sea \" to  \"ea \" and another step to make  \"eat \" to  \"ea \".\n\n**Example 2:**\n\n**Input:** word1 =  \"leetcode \", word2 =  \"etco \"\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of only lowercase English letters.",
          "output": "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            elif word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\n    return dp[m][n]\n"
     },
     {
          "instruction": "Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5\n**Output:** 5\n**Explanation:**\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 2\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 3\n\n**Constraints:**\n\n*   `1 <= n <= 109`",
          "output": "def findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1\n"
     },
     {
          "instruction": "For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, k = 0\n**Output:** 1\n**Explanation:** Only the array \\[1,2,3\\] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n\n**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 2\n**Explanation:** The array \\[1,3,2\\] and \\[2,1,3\\] have exactly 1 inverse pair.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= k <= 1000`",
          "output": "def kInversePairs(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n            if j - i >= 0:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n    return dp[n][k]\n"
     },
     {
          "instruction": "In combinatorial mathematics, a **derangement** is a permutation of the elements of a set, such that no element appears in its original position.\n\nYou are given an integer `n`. There is originally an array consisting of `n` integers from `1` to `n` in ascending order, return _the number of **derangements** it can generate_. Since the answer may be huge, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** The original array is \\[1,2,3\\]. The two derangements are \\[2,3,1\\] and \\[3,1,2\\].\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 106`",
          "output": "def findDerangement(n: int) -> int:\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[2] = 1\n    for i in range(3, n + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n"
     },
     {
          "instruction": "In LeetCode Store, there are `n` items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n\nYou are given an integer array `price` where `price[i]` is the price of the `ith` item, and an integer array `needs` where `needs[i]` is the number of pieces of the `ith` item you want to buy.\n\nYou are also given an array `special` where `special[i]` is of size `n + 1` where `special[i][j]` is the number of pieces of the `jth` item in the `ith` offer and `special[i][n]` (i.e., the last integer in the array) is the price of the `ith` offer.\n\nReturn _the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers_. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\n\n",
          "input": "**Example 1:**\n\n**Input:** price = \\[2,5\\], special = \\[\\[3,0,5\\],\\[1,2,10\\]\\], needs = \\[3,2\\]\n**Output:** 14\n**Explanation:** There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\n**Example 2:**\n\n**Input:** price = \\[2,3,4\\], special = \\[\\[1,1,0,4\\],\\[2,2,1,9\\]\\], needs = \\[1,2,1\\]\n**Output:** 11\n**Explanation:** The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\n**Constraints:**\n\n*   `n == price.length == needs.length`\n*   `1 <= n <= 6`\n*   `0 <= price[i], needs[i] <= 10`\n*   `1 <= special.length <= 100`\n*   `special[i].length == n + 1`\n*   `0 <= special[i][j] <= 50`",
          "output": "from typing import List\n\ndef shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) -> int:\n    def helper(index):\n        if index == len(special):\n            return sum(needs[i] * price[i] for i in range(len(needs)))\n\n        no_offer = helper(index + 1)\n        can_apply_offer = True\n        for i in range(len(needs)):\n            needs[i] -= special[index][i]\n            if needs[i] < 0:\n                can_apply_offer = False\n\n        with_offer = float('inf')\n        if can_apply_offer:\n            offer_cost = special[index][-1] + helper(index)\n            with_offer = min(no_offer, offer_cost)\n\n        for i in range(len(needs)):\n            needs[i] += special[index][i]\n        \n        return with_offer if can_apply_offer else no_offer\n\n    return helper(0)\n"
     },
     {
          "instruction": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\n**In addition** to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1* \"` may represent any of the encoded messages `\"11 \"`, `\"12 \"`, `\"13 \"`, `\"14 \"`, `\"15 \"`, `\"16 \"`, `\"17 \"`, `\"18 \"`, or `\"19 \"`. Decoding `\"1* \"` is equivalent to decoding **any** of the encoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters, return _the **number** of ways to **decode** it_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"\\* \"\n**Output:** 9\n**Explanation:** The encoded message can represent any of the encoded messages  \"1 \",  \"2 \",  \"3 \",  \"4 \",  \"5 \",  \"6 \",  \"7 \",  \"8 \", or  \"9 \".\nEach of these can be decoded to the strings  \"A \",  \"B \",  \"C \",  \"D \",  \"E \",  \"F \",  \"G \",  \"H \", and  \"I \" respectively.\nHence, there are a total of 9 ways to decode  \"\\* \".\n\n**Example 2:**\n\n**Input:** s =  \"1\\* \"\n**Output:** 18\n**Explanation:** The encoded message can represent any of the encoded messages  \"11 \",  \"12 \",  \"13 \",  \"14 \",  \"15 \",  \"16 \",  \"17 \",  \"18 \", or  \"19 \".\nEach of these encoded messages have 2 ways to be decoded (e.g.  \"11 \" can be decoded to  \"AA \" or  \"K \").\nHence, there are a total of 9 \\* 2 = 18 ways to decode  \"1\\* \".\n\n**Example 3:**\n\n**Input:** s =  \"2\\* \"\n**Output:** 15\n**Explanation:** The encoded message can represent any of the encoded messages  \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \",  \"26 \",  \"27 \",  \"28 \", or  \"29 \".\n \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \", and  \"26 \" have 2 ways of being decoded, but  \"27 \",  \"28 \", and  \"29 \" only have 1 way.\nHence, there are a total of (6 \\* 2) + (3 \\* 1) = 12 + 3 = 15 ways to decode  \"2\\* \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a digit or `'*'`.",
          "output": "def num_decodings(s: str) -> int:\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)\n\n    for i in range(2, n + 1):\n        c, prev_c = s[i - 1], s[i - 2]\n        \n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n            if prev_c == '1': dp[i] += 9 * dp[i - 2]\n            elif prev_c == '2': dp[i] += 6 * dp[i - 2]\n            elif prev_c == '*': dp[i] += 15 * dp[i - 2]\n        else:\n            dp[i] = dp[i - 1] if c != '0' else 0\n            num = int(s[i - 2 : i])\n            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]\n            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]\n\n        dp[i] %= MOD\n    return dp[n]\n"
     },
     {
          "instruction": "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.\n\n",
          "input": "**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** The longest chain is \\[1,2\\] -> \\[3,4\\].\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[7,8\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** The longest chain is \\[1,2\\] -> \\[4,5\\] -> \\[7,8\\].\n\n**Constraints:**\n\n*   `n == pairs.length`\n*   `1 <= n <= 1000`\n*   `-1000 <= lefti < righti <= 1000`",
          "output": "def findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n\n    max_chain_length = 0\n    last_right = float('-inf')\n    for pair in pairs:\n        if pair[0] > last_right:\n            last_right = pair[1]\n            max_chain_length += 1\n\n    return max_chain_length\n"
     },
     {
          "instruction": "Given a string `s`, return _the number of **palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 3\n**Explanation:** Three palindromic strings:  \"a \",  \"b \",  \"c \".\n\n**Example 2:**\n\n**Input:** s =  \"aaa \"\n**Output:** 6\n**Explanation:** Six palindromic strings:  \"a \",  \"a \",  \"a \",  \"aa \",  \"aa \",  \"aaa \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of lowercase English letters.",
          "output": "def countSubstrings(s: str) -> int:\n    n = len(s)\n    count = 0\n    for center in range(2 * n - 1):\n        left = center // 2\n        right = left + center % 2\n        while left >= 0 and right < n and s[left] == s[right]:\n            count += 1\n            left -= 1\n            right += 1\n    return count\n"
     },
     {
          "instruction": "There is only one character `'A'` on the screen of a notepad. You can perform one of two operations on this notepad for each step:\n\n*   Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n*   Paste: You can paste the characters which are copied last time.\n\nGiven an integer `n`, return _the minimum number of operations to get the character_ `'A'` _exactly_ `n` _times on the screen_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** Initially, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= n <= 1000`",
          "output": "def min_steps(n):\n    result = 0\n    i = 2\n    while i <= n:\n        while n % i == 0:\n            result += i\n            n //= i\n        i += 1\n    return result\n"
     },
     {
          "instruction": "Imagine you have a special keyboard with the following keys:\n\n*   A: Print one `'A'` on the screen.\n*   Ctrl-A: Select the whole screen.\n*   Ctrl-C: Copy selection to buffer.\n*   Ctrl-V: Print buffer on screen appending it after what has already been printed.\n\nGiven an integer n, return _the maximum number of_ `'A'` _you can print on the screen with **at most**_ `n` _presses on the keys_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** We can at most get 3 A's on screen by pressing the following key sequence:\nA, A, A\n\n**Example 2:**\n\n**Input:** n = 7\n**Output:** 9\n**Explanation:** We can at most get 9 A's on screen by pressing following key sequence:\nA, A, A, Ctrl A, Ctrl C, Ctrl V, Ctrl V\n\n**Constraints:**\n\n*   `1 <= n <= 50`",
          "output": "def maxA(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(1, i - 2):\n            dp[i] = max(dp[i], dp[j] * (i - j - 1))\n    return dp[n]\n"
     },
     {
          "instruction": "You are given an integer array `coins` (**1-indexed**) of length `n` and an integer `maxJump`. You can jump to any index `i` of the array `coins` if `coins[i] != -1` and you have to pay `coins[i]` when you visit index `i`. In addition to that, if you are currently at index `i`, you can only jump to any index `i + k` where `i + k <= n` and `k` is a value in the range `[1, maxJump]`.\n\nYou are initially positioned at index `1` (`coins[1]` is not `-1`). You want to find the path that reaches index n with the minimum cost.\n\nReturn an integer array of the indices that you will visit in order so that you can reach index n with the minimum cost. If there are multiple paths with the same cost, return the **lexicographically smallest** such path. If it is not possible to reach index n, return an empty array.\n\nA path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j` exists, then `x < y`.\n\n",
          "input": "**Example 1:**\n\n**Input:** coins = \\[1,2,4,-1,2\\], maxJump = 2\n**Output:** \\[1,3,5\\]\n\n**Example 2:**\n\n**Input:** coins = \\[1,2,4,-1,2\\], maxJump = 1\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `1 <= coins.length <= 1000`\n*   `-1 <= coins[i] <= 100`\n*   `coins[1] != -1`\n*   `1 <= maxJump <= 100`",
          "output": "def cheapestJump(coins, maxJump):\n    n = len(coins)\n    dp = [float('inf')] * n\n    parent = [-1] * n\n    dp[0] = coins[0]\n    for i in range(n):\n        if coins[i] == -1:\n            continue\n        for j in range(1, maxJump + 1):\n            if i + j >= n:\n                break\n            next = i + j\n            cost = coins[next] + dp[i]\n            if cost < dp[next]:\n                dp[next] = cost\n                parent[next] = i\n    ans = []\n    if dp[n - 1] == float('inf'):\n        return ans\n    cur = n - 1\n    while cur != -1:\n        ans.append(cur + 1)\n        cur = parent[cur]\n    ans.reverse()\n    return ans\n"
     },
     {
          "instruction": "There is a strange printer with the following two special properties:\n\n*   The printer can only print a sequence of **the same character** each time.\n*   At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return _the minimum number of turns the printer needed to print it_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aaabbb \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"bbb \".\n\n**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"b \" from the second place of the string, which will cover the existing character 'a'.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.",
          "output": "def strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]\n"
     },
     {
          "instruction": "Given an integer array `nums`, return _the number of longest increasing subsequences._\n\n**Notice** that the sequence has to be **strictly** increasing.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 2\n**Explanation:** The two longest increasing subsequences are \\[1, 3, 4, 7\\] and \\[1, 3, 5, 7\\].\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 5\n**Explanation:** The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `-106 <= nums[i] <= 106`",
          "output": "def findNumberOfLIS(nums):\n    n = len(nums)\n    maxLength = ans = 0\n    length = [1] * n\n    count = [1] * n\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                if length[i] == length[j] + 1:\n                    count[i] += count[j]\n                elif length[i] < length[j] + 1:\n                    length[i] = length[j] + 1\n                    count[i] = count[j]\n        if maxLength == length[i]:\n            ans += count[i]\n        elif maxLength < length[i]:\n            maxLength = length[i]\n            ans = count[i]\n\n    return ans\n"
     },
     {
          "instruction": "Given a string `s` containing only three types of characters: `'('`, `')'` and `'*'`, return `true` _if_ `s` _is **valid**_.\n\nThe following rules define a **valid** string:\n\n*   Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n*   Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n*   Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n*   `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `\" \"`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s = \"()\"\n**Output:** true\n\n**Example 2:**\n\n**Input:** s = \"(\\*)\"\n**Output:** true\n\n**Example 3:**\n\n**Input:** s = \"(\\*))\"\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s[i]` is `'('`, `')'` or `'*'`.",
          "output": "def checkValidString(s: str) -> bool:\n    left_balance, right_balance = 0, 0\n\n    for i in range(len(s)):\n        left_balance += 1 if s[i] == '(' or s[i] == '*' else -1\n        right_balance += 1 if s[len(s) - 1 - i] == ')' or s[len(s) - 1 - i] == '*' else -1\n\n        if left_balance < 0 or right_balance < 0:\n            return False\n\n    return True\n"
     },
     {
          "instruction": "On an `n x n` chessboard, a knight starts at the cell `(row, column)` and attempts to make exactly `k` moves. The rows and columns are **0-indexed**, so the top-left cell is `(0, 0)`, and the bottom-right cell is `(n - 1, n - 1)`.\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\nThe knight continues moving until it has made exactly `k` moves or has moved off the chessboard.\n\nReturn _the probability that the knight remains on the board after it has stopped moving_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, k = 2, row = 0, column = 0\n**Output:** 0.06250\n**Explanation:** There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n\n**Example 2:**\n\n**Input:** n = 1, k = 0, row = 0, column = 0\n**Output:** 1.00000\n\n**Constraints:**\n\n*   `1 <= n <= 25`\n*   `0 <= k <= 100`\n*   `0 <= row, column <= n - 1`",
          "output": "def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    memo = [[[-1.0 for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]\n    return self.helper(n, k, row, column, memo)\n\ndef helper(self, n, k, row, column, memo):\n    if row < 0 or row >= n or column < 0 or column >= n:\n        return 0.0\n    if k == 0:\n        return 1.0\n    if memo[row][column][k] >= 0:\n        return memo[row][column][k]\n\n    result = 0.0\n    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]\n    for move in moves:\n        result += self.helper(n, k - 1, row + move[0], column + move[1], memo) / 8\n\n    memo[row][column][k] = result\n    return result\n"
     },
     {
          "instruction": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (**0-indexed**). If there are multiple answers, return the lexicographically smallest one.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,6,7,5,1\\], k = 2\n**Output:** \\[0,3,5\\]\n**Explanation:** Subarrays \\[1, 2\\], \\[2, 6\\], \\[7, 5\\] correspond to the starting indices \\[0, 3, 5\\].\nWe could have also taken \\[2, 1\\], but an answer of \\[1, 3, 5\\] would be lexicographically larger.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1,2,1\\], k = 2\n**Output:** \\[0,2,4\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] < 216`\n*   `1 <= k <= floor(nums.length / 3)`",
          "output": "def max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans\n"
     },
     {
          "instruction": "We are given `n` different types of `stickers`. Each sticker has a lowercase English word on it.\n\nYou would like to spell out the given string `target` by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker.\n\nReturn _the minimum number of stickers that you need to spell out_ `target`. If the task is impossible, return `-1`.\n\n**Note:** In all test cases, all words were chosen randomly from the `1000` most common US English words, and `target` was chosen as a concatenation of two random words.\n\n",
          "input": "**Example 1:**\n\n**Input:** stickers = \\[ \"with \", \"example \", \"science \"\\], target =  \"thehat \"\n**Output:** 3\n**Explanation:**\nWe can use 2  \"with \" stickers, and 1  \"example \" sticker.\nAfter cutting and rearrange the letters of those stickers, we can form the target  \"thehat \".\nAlso, this is the minimum number of stickers necessary to form the target string.\n\n**Example 2:**\n\n**Input:** stickers = \\[ \"notice \", \"possible \"\\], target =  \"basicbasic \"\n**Output:** -1\nExplanation:\nWe cannot form the target  \"basicbasic \" from cutting letters from the given stickers.\n\n**Constraints:**\n\n*   `n == stickers.length`\n*   `1 <= n <= 50`\n*   `1 <= stickers[i].length <= 10`\n*   `1 <= target.length <= 15`\n*   `stickers[i]` and `target` consist of lowercase English letters.",
          "output": "from collections import Counter\nfrom functools import lru_cache\n\ndef minStickers(stickers, target):\n    target_count = Counter(target)\n    memo = {}\n    \n    for s in stickers:\n        sticker_count = Counter(s)\n        state = ''.join(sticker_count & target_count)\n        memo[state] = 1\n    \n    @lru_cache(None)\n    def dp(state):\n        counts = Counter(state)\n        ans = float('inf')\n        for key, value in memo.items():\n            if any(counts[ch] < key.count(ch) for ch in state): continue\n            ans = min(ans, dp(state.translate(str.maketrans('', '', key))) + value)\n        return -1 if ans == float('inf') else ans\n    \n    return dp(target)\n"
     },
     {
          "instruction": "Given an integer array `nums` and an integer `k`, return `true` if it is possible to divide this array into `k` non-empty subsets whose sums are all equal.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[4,3,2,3,5,2,1\\], k = 4\n**Output:** true\n**Explanation:** It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\], k = 3\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 16`\n*   `1 <= nums[i] <= 104`\n*   The frequency of each element is in the range `[1, 4]`.",
          "output": "def canPartitionKSubsets(nums, k):\n    total_sum = sum(nums)\n    if total_sum % k != 0:\n        return False\n    target = total_sum // k\n    visited = [False] * len(nums)\n    return dfs(nums, visited, 0, target, 0, k)\n\ndef dfs(nums, visited, start, target, curr_sum, k):\n    if k == 1:\n        return True\n    if curr_sum == target:\n        return dfs(nums, visited, 0, target, 0, k - 1)\n    for i in range(start, len(nums)):\n        if not visited[i] and curr_sum + nums[i] <= target:\n            visited[i] = True\n            if dfs(nums, visited, i + 1, target, curr_sum + nums[i], k):\n                return True\n            visited[i] = False\n    return False\n"
     },
     {
          "instruction": "Given two strings `s1` and `s2`, return _the lowest **ASCII** sum of deleted characters to make two strings equal_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s1 =  \"sea \", s2 =  \"eat \"\n**Output:** 231\n**Explanation:** Deleting  \"s \" from  \"sea \" adds the ASCII value of  \"s \" (115) to the sum.\nDeleting  \"t \" from  \"eat \" adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n\n**Example 2:**\n\n**Input:** s1 =  \"delete \", s2 =  \"leet \"\n**Output:** 403\n**Explanation:** Deleting  \"dee \" from  \"delete \" to turn the string into  \"let \",\nadds 100\\[d\\] + 101\\[e\\] + 101\\[e\\] to the sum.\nDeleting  \"e \" from  \"leet \" adds 101\\[e\\] to the sum.\nAt the end, both strings are equal to  \"let \", and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into  \"lee \" or  \"eet \", we would get answers of 433 or 417, which are higher.\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 1000`\n*   `s1` and `s2` consist of lowercase English letters.",
          "output": "def minimumDeleteSum(s1: str, s2: str) -> int:\n    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]), dp[i][j - 1] + ord(s2[j - 1]))\n    return dp[len(s1)][len(s2)]\n"
     },
     {
          "instruction": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n",
          "input": "**Example 1:**\n\n**Input:** prices = \\[1,3,2,8,4,9\\], fee = 2\n**Output:** 8\n**Explanation:** The maximum profit can be achieved by:\n- Buying at prices\\[0\\] = 1\n- Selling at prices\\[3\\] = 8\n- Buying at prices\\[4\\] = 4\n- Selling at prices\\[5\\] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n\n**Example 2:**\n\n**Input:** prices = \\[1,3,7,5,10,3\\], fee = 3\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= prices.length <= 5 * 104`\n*   `1 <= prices[i] < 5 * 104`\n*   `0 <= fee < 5 * 104`",
          "output": "def maxProfit(prices, fee):\n    cash, hold = 0, -prices[0]\n    for price in prices:\n        temp = cash\n        cash = max(cash, hold + price - fee)\n        hold = max(hold, temp - price)\n    return cash\n"
     },
     {
          "instruction": "Given two integer arrays `nums1` and `nums2`, return _the maximum length of a subarray that appears in **both** arrays_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,2,1\\], nums2 = \\[3,2,1,4,7\\]\n**Output:** 3\n**Explanation:** The repeated subarray with maximum length is \\[3,2,1\\].\n\n**Example 2:**\n\n**Input:** nums1 = \\[0,0,0,0,0\\], nums2 = \\[0,0,0,0,0\\]\n**Output:** 5\n**Explanation:** The repeated subarray with maximum length is \\[0,0,0,0,0\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 100`",
          "output": "def findLength(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxLength = 0\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if nums1[i] == nums2[j]:\n                dp[i][j] = dp[i + 1][j + 1] + 1\n                maxLength = max(maxLength, dp[i][j])\n\n    return maxLength\n"
     },
     {
          "instruction": "Given strings `s1` and `s2`, return _the minimum contiguous substring part of_ `s1`_, so that_ `s2` _is a subsequence of the part_.\n\nIf there is no such window in `s1` that covers all characters in `s2`, return the empty string `\" \"`. If there are multiple such minimum-length windows, return the one with the **left-most starting index**.\n\n",
          "input": "**Example 1:**\n\n**Input:** s1 =  \"abcdebdde \", s2 =  \"bde \"\n**Output:**  \"bcde \"\n**Explanation:** \n \"bcde \" is the answer because it occurs before  \"bdde \" which has the same length.\n \"deb \" is not a smaller window because the elements of s2 in the window must occur in order.\n\n**Example 2:**\n\n**Input:** s1 =  \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl \", s2 =  \"u \"\n**Output:**  \" \"\n\n**Constraints:**\n\n*   `1 <= s1.length <= 2 * 104`\n*   `1 <= s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.",
          "output": "def min_window_sub_sequence(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for j in range(0, m + 1):\n        dp[0][j] = j\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[j - 1] == s2[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    start, length = 0, m + 1\n    for j in range(1, m + 1):\n        if dp[n][j] != 0 and j - dp[n][j] < length:\n            start = dp[n][j]\n            length = j - start\n\n    return \"\" if length == m + 1 else s1[start:start + length]\n"
     },
     {
          "instruction": "Given a string s, return _the number of different non-empty palindromic subsequences in_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from the string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some `i` for which `ai != bi`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"bccb \"\n**Output:** 6\n**Explanation:** The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n\n**Example 2:**\n\n**Input:** s =  \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba \"\n**Output:** 104860361\n**Explanation:** There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7.\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'a'`, `'b'`, `'c'`, or `'d'`.",
          "output": "def countPalindromicSubsequences(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(4)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            c = ord(s[i]) - ord('a')\n            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2\n            dp[c][j] = (dp[c][j] + MOD) % MOD\n\n    return sum(dp[c][n] for c in range(4)) % MOD\n"
     },
     {
          "instruction": "You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:\n\n*   Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the **maximum number of points** you can earn by applying the above operation some number of times_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,4,2\\]\n**Output:** 6\n**Explanation:** You can perform the following operations:\n- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = \\[2\\].\n- Delete 2 to earn 2 points. nums = \\[\\].\nYou earn a total of 6 points.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,3,3,3,4\\]\n**Output:** 9\n**Explanation:** You can perform the following operations:\n- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = \\[3,3\\].\n- Delete a 3 again to earn 3 points. nums = \\[3\\].\n- Delete a 3 once more to earn 3 points. nums = \\[\\].\nYou earn a total of 9 points.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 104`",
          "output": "def max_points(nums):\n    dp = [0] * 100001\n    max_points = 0\n    for num in nums:\n        dp[num] += 1\n    for i in range(2, len(dp)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + i * dp[i])\n        max_points = max(max_points, dp[i])\n    return max_points\n"
     },
     {
          "instruction": "You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`",
          "output": "def cherryPickup(self, grid: List[List[int]]) -> int:\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))\n"
     },
     {
          "instruction": "You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn _the minimum cost to reach the top of the floor_.\n\n",
          "input": "**Example 1:**\n\n**Input:** cost = \\[10,15,20\\]\n**Output:** 15\n**Explanation:** You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n**Example 2:**\n\n**Input:** cost = \\[1,100,1,1,1,100,1,1,100,1\\]\n**Output:** 6\n**Explanation:** You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n\n**Constraints:**\n\n*   `2 <= cost.length <= 1000`\n*   `0 <= cost[i] <= 999`",
          "output": "class WordFilter:\n\n    def __init__(self, words):\n        self.dict = {}\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                self.dict[word[:j] + \"#\" + word[j:]] = i\n\n    def f(self, prefix, suffix):\n        return self.dict.get(prefix + \"#\" + suffix, -1)\n"
     },
     {
          "instruction": "Given an `m x n` integer matrix `grid` where each entry is only `0` or `1`, return _the number of **corner rectangles**_.\n\nA **corner rectangle** is four distinct `1`'s on the grid that forms an axis-aligned rectangle. Note that only the corners need to have the value `1`. Also, all four `1`'s used must be distinct.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,1,0\\],\\[0,0,1,0,1\\],\\[0,0,0,1,0\\],\\[1,0,1,0,1\\]\\]\n**Output:** 1\n**Explanation:** There is only one corner rectangle, with corners grid\\[1\\]\\[2\\], grid\\[1\\]\\[4\\], grid\\[3\\]\\[2\\], grid\\[3\\]\\[4\\].\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 9\n**Explanation:** There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1\\]\\]\n**Output:** 0\n**Explanation:** Rectangles must have four distinct corners.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.\n*   The number of `1`'s in the grid is in the range `[1, 6000]`.",
          "output": "def countCornerRectangles(grid):\n    count = 0\n    m = len(grid)\n    n = len(grid[0])\n    \n    for i in range(m - 1):\n        for j in range(n - 1):\n            if grid[i][j] == 1:\n                for k in range(i + 1, m):\n                    for l in range(j + 1, n):\n                        if grid[k][l] == 1 and grid[i][l] == 1 and grid[k][j] == 1:\n                            count += 1\n    return count\n"
     },
     {
          "instruction": "You are given an integer `n`. You have an `n x n` binary grid `grid` with all values initially `1`'s except for some indices given in the array `mines`. The `ith` element of the array `mines` is defined as `mines[i] = [xi, yi]` where `grid[xi][yi] == 0`.\n\nReturn _the order of the largest **axis-aligned** plus sign of_ 1_'s contained in_ `grid`. If there is none, return `0`.\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center `grid[r][c] == 1` along with four arms of length `k - 1` going up, down, left, and right, and made of `1`'s. Note that there could be `0`'s or `1`'s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for `1`'s.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5, mines = \\[\\[4,2\\]\\]\n**Output:** 2\n**Explanation:** In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n**Example 2:**\n\n**Input:** n = 1, mines = \\[\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** There is no plus sign, so return 0.\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n*   `1 <= mines.length <= 5000`\n*   `0 <= xi, yi < n`\n*   All the pairs `(xi, yi)` are **unique**.",
          "output": "from collections import deque\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef levelOrder(root):\n    result = []\n\n    if not root:\n        return result\n\n    toVisit = deque([root])\n\n    while toVisit:\n        size = len(toVisit)\n        level = []\n\n        for _ in range(size):\n            currentNode = toVisit.popleft()\n            level.append(currentNode.val)\n\n            for child in currentNode.children:\n                toVisit.append(child)\n\n        result.append(level)\n\n    return result\n"
     },
     {
          "instruction": "There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 4, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[2,0,100\\],\\[1,3,600\\],\\[2,3,200\\]\\], src = 0, dst = 3, k = 1\n**Output:** 700\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities \\[0,1,2,3\\] is cheaper but is invalid because it uses 2 stops.\n\n**Example 2:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 1\n**Output:** 200\n**Explanation:**\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\n**Example 3:**\n\n**Input:** n = 3, flights = \\[\\[0,1,100\\],\\[1,2,100\\],\\[0,2,500\\]\\], src = 0, dst = 2, k = 0\n**Output:** 500\n**Explanation:**\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= flights.length <= (n * (n - 1) / 2)`\n*   `flights[i].length == 3`\n*   `0 <= fromi, toi < n`\n*   `fromi != toi`\n*   `1 <= pricei <= 104`\n*   There will not be any multiple flights between two cities.\n*   `0 <= src, dst, k < n`\n*   `src != dst`",
          "output": "from collections import deque\n\ndef slidingPuzzle(board):\n    m, n = 2, 3\n    target = \"123450\"\n    start = \"\".join(str(num) for row in board for num in row)\n    dirs = [[1, 3], [0, 2, 4], [1, 5], [0, 4], [1, 3, 5], [2, 4]]\n    q = deque([start])\n    res = 0\n    visited = {start}\n    while q:\n        for _ in range(len(q)):\n            cur = q.popleft()\n            if cur == target:\n                return res\n            zero_idx = cur.index(\"0\")\n            for dir in dirs[zero_idx]:\n                neighbor = list(cur)\n                neighbor[zero_idx], neighbor[dir] = neighbor[dir], neighbor[zero_idx]\n                neighbor = \"\".join(neighbor)\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        res += 1\n    return -1\n"
     },
     {
          "instruction": "An integer `x` is a **good** if after rotating each digit individually by 180 degrees, we get a valid number that is different from `x`. Each digit must be rotated - we cannot choose to leave it alone.\n\nA number is valid if each digit remains a digit after rotation. For example:\n\n*   `0`, `1`, and `8` rotate to themselves,\n*   `2` and `5` rotate to each other (in this case they are rotated in a different direction, in other words, `2` or `5` gets mirrored),\n*   `6` and `9` rotate to each other, and\n*   the rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer `n`, return _the number of **good** integers in the range_ `[1, n]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** There are four good numbers in the range \\[1, 10\\] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 104`",
          "output": "def rotatedDigits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if isGood(i):\n            count += 1\n    return count\n\ndef isGood(num: int) -> bool:\n    changed = False\n    while num:\n        digit = num % 10\n        if digit in (3, 4, 7):\n            return False\n        if digit in (2, 5, 6, 9):\n            changed = True\n        num //= 10\n    return changed\n"
     },
     {
          "instruction": "You have two types of tiles: a `2 x 1` domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return _the number of ways to tile an_ `2 x n` _board_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n**Explanation:** The five different ways are show above.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 1000`",
          "output": "def is_ideal_permutation(nums):\n    for i, num in enumerate(nums):\n        if abs(num - i) > 1:\n            return False\n    return True\n"
     },
     {
          "instruction": "We stack glasses in a pyramid, where the **first** row has `1` glass, the **second** row has `2` glasses, and so on until the 100th row. Each glass holds one cup of champagne.\n\nThen, some champagne is poured into the first glass at the top. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has its excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\nNow after pouring some non-negative integer cups of champagne, return how full the `jth` glass in the `ith` row is (both `i` and `j` are 0-indexed.)\n\n",
          "input": "**Example 1:**\n\n**Input:** poured = 1, query\\_row = 1, query\\_glass = 1\n**Output:** 0.00000\n**Explanation:** We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n\n**Example 2:**\n\n**Input:** poured = 2, query\\_row = 1, query\\_glass = 1\n**Output:** 0.50000\n**Explanation:** We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\n\n**Example 3:**\n\n**Input:** poured = 100000009, query\\_row = 33, query\\_glass = 17\n**Output:** 1.00000\n\n**Constraints:**\n\n*   `0 <= poured <= 109`\n*   `0 <= query_glass <= query_row < 100`",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def __init__(self):\n        self.min_diff = float(\"inf\")\n        self.prev = None\n\n    def minDiffInBST(self, root: TreeNode) -> int:\n        self.in_order_traversal(root)\n        return self.min_diff\n\n    def in_order_traversal(self, node: TreeNode) -> None:\n        if not node: return\n        self.in_order_traversal(node.left)\n        if self.prev:\n            self.min_diff = min(self.min_diff, node.val - self.prev.val)\n        self.prev = node\n        self.in_order_traversal(node.right)\n"
     },
     {
          "instruction": "You are given two integer arrays of the same length `nums1` and `nums2`. In one operation, you are allowed to swap `nums1[i]` with `nums2[i]`.\n\n*   For example, if `nums1 = [1,2,3,8]`, and `nums2 = [5,6,7,4]`, you can swap the element at `i = 3` to obtain `nums1 = [1,2,3,4]` and `nums2 = [5,6,7,8]`.\n\nReturn _the minimum number of needed operations to make_ `nums1` _and_ `nums2` _**strictly increasing**_. The test cases are generated so that the given input always makes it possible.\n\nAn array `arr` is **strictly increasing** if and only if `arr[0] < arr[1] < arr[2] < ... < arr[arr.length - 1]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[1,3,5,4\\], nums2 = \\[1,2,3,7\\]\n**Output:** 1\n**Explanation:** \nSwap nums1\\[3\\] and nums2\\[3\\]. Then the sequences are:\nnums1 = \\[1, 3, 5, 7\\] and nums2 = \\[1, 2, 3, 4\\]\nwhich are both strictly increasing.\n\n**Example 2:**\n\n**Input:** nums1 = \\[0,3,5,8,9\\], nums2 = \\[2,1,4,6,9\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `2 <= nums1.length <= 105`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 2 * 105`",
          "output": "from collections import deque\n\ndef isBipartite(graph):\n    colors = [0] * len(graph)\n    for i in range(len(graph)):\n        if colors[i] != 0:\n            continue\n        colors[i] = 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if colors[neighbor] == 0:\n                    colors[neighbor] = -colors[node]\n                    queue.append(neighbor)\n                elif colors[neighbor] == colors[node]:\n                    return False\n    return True\n"
     },
     {
          "instruction": "You are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B` such that `A` and `B` are non-empty, and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\n**Note** that for an array `arr`, `average(arr)` is the sum of all the elements of `arr` over the length of `arr`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8\\]\n**Output:** true\n**Explanation:** We can split the array into \\[1,4,5,8\\] and \\[2,3,6,7\\], and both of them have an average of 4.5.\n\n**Example 2:**\n\n**Input:** nums = \\[3,1\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= nums.length <= 30`\n*   `0 <= nums[i] <= 104`",
          "output": "from typing import List\n\ndef escape_ghosts(ghosts: List[List[int]], target: List[int]) -> bool:\n    max_dist = abs(target[0]) + abs(target[1])\n    for ghost in ghosts:\n        ghost_dist = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])\n        if ghost_dist <= max_dist:\n            return False\n    return True\n"
     },
     {
          "instruction": "There are two types of soup: **type A** and **type B**. Initially, we have `n` ml of each type of soup. There are four kinds of operations:\n\n1.  Serve `100` ml of **soup A** and `0` ml of **soup B**,\n2.  Serve `75` ml of **soup A** and `25` ml of **soup B**,\n3.  Serve `50` ml of **soup A** and `50` ml of **soup B**, and\n4.  Serve `25` ml of **soup A** and `75` ml of **soup B**.\n\nWhen we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability `0.25`. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.\n\n**Note** that we do not have an operation where all `100` ml's of **soup B** are used first.\n\nReturn _the probability that **soup A** will be empty first, plus half the probability that **A** and **B** become empty at the same time_. Answers within `10-5` of the actual answer will be accepted.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 50\n**Output:** 0.62500\n**Explanation:** If we choose the first two operations, A will become empty first.\nFor the third operation, A and B will become empty at the same time.\nFor the fourth operation, B will become empty first.\nSo the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 \\* (1 + 1 + 0.5 + 0) = 0.625.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 0.71875\n\n**Constraints:**\n\n*   `0 <= n <= 109`",
          "output": "from bisect import bisect_left\nfrom collections import defaultdict\n\ndef numMatchingSubseq(s, words):\n    positions = defaultdict(list)\n\n    for i, c in enumerate(s):\n        positions[c].append(i)\n\n    count = 0\n\n    for word in words:\n        index = -1\n        isSubsequence = True\n\n        for c in word:\n            position_list = positions.get(c, [])\n            i = bisect_left(position_list, index + 1)\n            if (i == len(position_list)):\n                isSubsequence = False\n                break\n            index = position_list[i]\n\n        if isSubsequence:\n            count += 1\n\n    return count\n"
     },
     {
          "instruction": "You are given an integer array `nums` and an integer `k`. You can partition the array into **at most** `k` non-empty adjacent subarrays. The **score** of a partition is the sum of the averages of each subarray.\n\nNote that the partition must use every integer in `nums`, and that the score is not necessarily an integer.\n\nReturn _the maximum **score** you can achieve of all the possible partitions_. Answers within `10-6` of the actual answer will be accepted.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[9,1,2,3,9\\], k = 3\n**Output:** 20.00000\n**Explanation:** \nThe best choice is to partition nums into \\[9\\], \\[1, 2, 3\\], \\[9\\]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned nums into \\[9, 1\\], \\[2\\], \\[3, 9\\], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 4\n**Output:** 20.50000\n\n**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 104`\n*   `1 <= k <= nums.length`",
          "output": "from typing import List\n\ndef allPathsSourceTarget(graph: List[List[int]]) -> List[List[int]]:\n    def DFS(currentNode, path):\n        path.append(currentNode)\n        if currentNode == len(graph) - 1:\n            result.append(path[:])\n        else:\n            for neighbor in graph[currentNode]:\n                DFS(neighbor, path)\n        path.pop()\n\n    result = []\n    DFS(0, [])\n    return result\n"
     },
     {
          "instruction": "Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'` (reverse):\n\n*   When you get an instruction `'A'`, your car does the following:\n    *   `position += speed`\n    *   `speed *= 2`\n*   When you get an instruction `'R'`, your car does the following:\n    *   If your speed is positive then `speed = -1`\n    *   otherwise `speed = 1`Your position stays the same.\n\nFor example, after commands `\"AAR \"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target`, return _the length of the shortest sequence of instructions to get there_.\n\n",
          "input": "**Example 1:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:** \nThe shortest instruction sequence is  \"AA \".\nYour position goes from 0 --> 1 --> 3.\n\n**Example 2:**\n\n**Input:** target = 6\n**Output:** 5\n**Explanation:** \nThe shortest instruction sequence is  \"AAARA \".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n\n**Constraints:**\n\n*   `1 <= target <= 104`",
          "output": "def racecar(target: int) -> int:\n    memo = {}\n    def dp(position, speed):\n        if abs(position) > 2 * target:\n            return target + 1\n        if position == target:\n            return 0 if speed == 1 else 1\n        if (position, speed) in memo:\n            return memo[(position, speed)]\n        \n        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1\n        ans = min(ans, dp(position + speed, speed * 2) + 1)\n        memo[(position, speed)] = ans\n        return ans\n    \n    return dp(0, 1)\n"
     },
     {
          "instruction": "Given an array of unique integers, `arr`, where each integer `arr[i]` is strictly greater than `1`.\n\nWe make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.\n\nReturn _the number of binary trees we can make_. The answer may be too large so return the answer **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[2,4\\]\n**Output:** 3\n**Explanation:** We can make these trees: `[2], [4], [4, 2, 2]`\n\n**Example 2:**\n\n**Input:** arr = \\[2,4,5,10\\]\n**Output:** 7\n**Explanation:** We can make these trees: `[2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]`.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `2 <= arr[i] <= 109`\n*   All the values of `arr` are **unique**.",
          "output": "def isPossibleToSplit(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n\n    if total_sum % n != 0:\n        return False\n\n    target_sum = total_sum * (n // 2) // n\n    dp = [[False] * (target_sum + 1) for _ in range(n // 2 + 1)]\n    dp[0][0] = True\n\n    for num in nums:\n        for count in range(n // 2, 0, -1):\n            for sum_ in range(target_sum, num - 1, -1):\n                dp[count][sum_] = dp[count][sum_] or dp[count - 1][sum_ - num]\n\n        if dp[n // 2][target_sum]:\n            return True\n\n    return False\n"
     },
     {
          "instruction": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\n*   For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"ABC \"\n**Output:** 10\n**Explanation:** All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\n**Example 2:**\n\n**Input:** s =  \"ABA \"\n**Output:** 8\n**Explanation:** The same as example 1, except `countUniqueChars`( \"ABA \") = 1.\n\n**Example 3:**\n\n**Input:** s =  \"LEETCODE \"\n**Output:** 92\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of uppercase English letters only.",
          "output": "def xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0\n"
     },
     {
          "instruction": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.",
          "output": "def ambiguousCoordinates(s):\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res\n"
     },
     {
          "instruction": "Alice plays the following game, loosely based on the card game **\"21 \"**.\n\nAlice starts with `0` points and draws numbers while she has less than `k` points. During each draw, she gains an integer number of points randomly from the range `[1, maxPts]`, where `maxPts` is an integer. Each draw is independent and the outcomes have equal probabilities.\n\nAlice stops drawing numbers when she gets `k` **or more points**.\n\nReturn the probability that Alice has `n` or fewer points.\n\nAnswers within `10-5` of the actual answer are considered accepted.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 10, k = 1, maxPts = 10\n**Output:** 1.00000\n**Explanation:** Alice gets a single card, then stops.\n\n**Example 2:**\n\n**Input:** n = 6, k = 1, maxPts = 10\n**Output:** 0.60000\n**Explanation:** Alice gets a single card, then stops.\nIn 6 out of 10 possibilities, she is at or below 6 points.\n\n**Example 3:**\n\n**Input:** n = 21, k = 17, maxPts = 10\n**Output:** 0.73278\n\n**Constraints:**\n\n*   `0 <= k <= n <= 104`\n*   `1 <= maxPts <= 104`",
          "output": "def mostCommonWord(paragraph: str, banned: List[str]):\n    word_count = {}\n    banned_set = {ban.lower() for ban in banned}\n\n    for word in paragraph.lower().split():\n        cleaned_word = ''.join(c for c in word if c.isalpha())\n        if cleaned_word not in banned_set:\n            word_count[cleaned_word] = word_count.get(cleaned_word, 0) + 1\n\n    return max(word_count, key=word_count.get)\n"
     },
     {
          "instruction": "There are `n` dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n\nYou are given a string `dominoes` representing the initial state where:\n\n*   `dominoes[i] = 'L'`, if the `ith` domino has been pushed to the left,\n*   `dominoes[i] = 'R'`, if the `ith` domino has been pushed to the right, and\n*   `dominoes[i] = '.'`, if the `ith` domino has not been pushed.\n\nReturn _a string representing the final state_.\n\n",
          "input": "**Example 1:**\n\n**Input:** dominoes =  \"RR.L \"\n**Output:**  \"RR.L \"\n**Explanation:** The first domino expends no additional force on the second domino.\n\n**Example 2:**\n\n**Input:** dominoes =  \".L.R...LR..L.. \"\n**Output:**  \"LL.RR.LLRRLL.. \"\n\n**Constraints:**\n\n*   `n == dominoes.length`\n*   `1 <= n <= 105`\n*   `dominoes[i]` is either `'L'`, `'R'`, or `'.'`.",
          "output": "def pushDominoes(dominoes: str) -> str:\n    n = len(dominoes)\n    forces = [0] * n\n    \n    force = 0\n    for i in range(n):\n        if dominoes[i] == 'R':\n            force = n\n        elif dominoes[i] == 'L':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] += force\n    \n    force = 0\n    for i in range(n - 1, -1, -1):\n        if dominoes[i] == 'L':\n            force = n\n        elif dominoes[i] == 'R':\n            force = 0\n        else:\n            force = max(force - 1, 0)\n        forces[i] -= force\n    \n    return \"\".join(['R' if f > 0 else 'L' if f < 0 else '.' for f in forces])\n"
     },
     {
          "instruction": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[2,1,4,7,3,2,5\\]\n**Output:** 5\n**Explanation:** The largest mountain is \\[1,4,7,3,2\\] which has length 5.\n\n**Example 2:**\n\n**Input:** arr = \\[2,2,2\\]\n**Output:** 0\n**Explanation:** There is no mountain.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\n\n**Follow up:**\n\n*   Can you solve it using only one pass?\n*   Can you solve it in `O(1)` space?",
          "output": "def longestMountain(arr):\n    n = len(arr)\n    res = up = down = 0\n\n    for i in range(1, n):\n        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:\n            up = down = 0\n\n        up += arr[i - 1] < arr[i]\n        down += arr[i - 1] > arr[i]\n\n        if up and down:\n            res = max(res, up + down + 1)\n\n    return res\n"
     },
     {
          "instruction": "You have an undirected, connected graph of `n` nodes labeled from `0` to `n - 1`. You are given an array `graph` where `graph[i]` is a list of all the nodes connected with node `i` by an edge.\n\nReturn _the length of the shortest path that visits every node_. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n\n",
          "input": "**Example 1:**\n\n**Input:** graph = \\[\\[1,2,3\\],\\[0\\],\\[0\\],\\[0\\]\\]\n**Output:** 4\n**Explanation:** One possible path is \\[1,0,2,0,3\\]\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1\\],\\[0,2,4\\],\\[1,3,4\\],\\[2\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** One possible path is \\[0,1,4,2,3\\]\n\n**Constraints:**\n\n*   `n == graph.length`\n*   `1 <= n <= 12`\n*   `0 <= graph[i].length < n`\n*   `graph[i]` does not contain `i`.\n*   If `graph[a]` contains `b`, then `graph[b]` contains `a`.\n*   The input graph is always connected.",
          "output": "from collections import deque\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    queue = deque([(i, 1 << i, 0) for i in range(n)])\n    visited = [[False] * (1 << n) for _ in range(n)]\n\n    for i in range(n):\n        visited[i][1 << i] = True\n\n    while queue:\n        node, bitmask, length = queue.popleft()\n\n        if bitmask == (1 << n) - 1:\n            return length\n\n        for nei in graph[node]:\n            next_bitmask = bitmask | (1 << nei)\n            if not visited[nei][next_bitmask]:\n                visited[nei][next_bitmask] = True\n                queue.append((nei, next_bitmask, length + 1))\n\n    return 0\n"
     },
     {
          "instruction": "A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.\n\n",
          "input": "**Example 1:**\n\n**Input:** target = 1, startFuel = 1, stations = \\[\\]\n**Output:** 0\n**Explanation:** We can reach the target without refueling.\n\n**Example 2:**\n\n**Input:** target = 100, startFuel = 1, stations = \\[\\[10,100\\]\\]\n**Output:** -1\n**Explanation:** We can not reach the target (or even the first gas station).\n\n**Example 3:**\n\n**Input:** target = 100, startFuel = 10, stations = \\[\\[10,60\\],\\[20,30\\],\\[30,30\\],\\[60,40\\]\\]\n**Output:** 2\n**Explanation:** We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n**Constraints:**\n\n*   `1 <= target, startFuel <= 109`\n*   `0 <= stations.length <= 500`\n*   `1 <= positioni < positioni+1 < target`\n*   `1 <= fueli < 109`",
          "output": "def can_visit_all_rooms(rooms):\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)\n"
     },
     {
          "instruction": "A sequence `x1, x2, ..., xn` is _Fibonacci-like_ if:\n\n*   `n >= 3`\n*   `xi + xi+1 == xi+2` for all `i + 2 <= n`\n\nGiven a **strictly increasing** array `arr` of positive integers forming a sequence, return _the **length** of the longest Fibonacci-like subsequence of_ `arr`. If one does not exist, return `0`.\n\nA **subsequence** is derived from another sequence `arr` by deleting any number of elements (including none) from `arr`, without changing the order of the remaining elements. For example, `[3, 5, 8]` is a subsequence of `[3, 4, 5, 6, 7, 8]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,2,3,4,5,6,7,8\\]\n**Output:** 5\n**Explanation:** The longest subsequence that is fibonacci-like: \\[1,2,3,5,8\\].\n\n**Example 2:**\n\n**Input:** arr = \\[1,3,7,11,12,14,18\\]\n**Output:** 3\n**Explanation**: The longest subsequence that is fibonacci-like: \\[1,11,12\\], \\[3,11,14\\] or \\[7,11,18\\].\n\n**Constraints:**\n\n*   `3 <= arr.length <= 1000`\n*   `1 <= arr[i] < arr[i + 1] <= 109`",
          "output": "import random\n\ndef match(a, b):\n    return sum(a[i] == b[i] for i in range(6))\n\ndef find_secret_word(wordlist, master):\n    for _ in range(10):\n        guess = random.choice(wordlist)\n        match_cnt = master.guess(guess)\n        if match_cnt == 6:\n            return\n        wordlist = [word for word in wordlist if match(word, guess) == match_cnt]\n"
     },
     {
          "instruction": "Alice and Bob play a game with piles of stones. There are an **even** number of piles arranged in a row, and each pile has a **positive** integer number of stones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number of stones across all the piles is **odd**, so there are no ties.\n\nAlice and Bob take turns, with **Alice starting first**. Each turn, a player takes the entire pile of stones either from the **beginning** or from the **end** of the row. This continues until there are no more piles left, at which point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally, return `true` _if Alice wins the game, or_ `false` _if Bob wins_.\n\n",
          "input": "**Example 1:**\n\n**Input:** piles = \\[5,3,4,5\\]\n**Output:** true\n**Explanation:** \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes \\[3, 4, 5\\].\nIf Bob takes 3, then the board is \\[4, 5\\], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is \\[3, 4\\], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n**Example 2:**\n\n**Input:** piles = \\[3,7,2,3\\]\n**Output:** true\n\n**Constraints:**\n\n*   `2 <= piles.length <= 500`\n*   `piles.length` is **even**.\n*   `1 <= piles[i] <= 500`\n*   `sum(piles[i])` is **odd**.",
          "output": "from collections import deque, defaultdict\n\ndef shortestPathLength(graph):\n    n = len(graph)\n    q = deque()\n    \n    for i in range(n):\n        q.append((i, 1 << i))\n    steps = -1\n    visited = {i: set() for i in range(n)}\n    \n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            currNode, currVisits = q.popleft()\n            \n            if bin(currVisits).count('1') == n:\n                return steps\n\n            for nextNode in graph[currNode]:\n                nextVisits = currVisits | (1 << nextNode)\n\n                if nextVisits not in visited[nextNode]:\n                    visited[nextNode].add(nextVisits)\n                    q.append((nextNode, nextVisits))\n\n    return -1\n"
     },
     {
          "instruction": "There is a group of `n` members, and a list of various crimes they could commit. The `ith` crime generates a `profit[i]` and requires `group[i]` members to participate in it. If a member participates in one crime, that member can't participate in another crime.\n\nLet's call a **profitable scheme** any subset of these crimes that generates at least `minProfit` profit, and the total number of members participating in that subset of crimes is at most `n`.\n\nReturn the number of schemes that can be chosen. Since the answer may be very large, **return it modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5, minProfit = 3, group = \\[2,2\\], profit = \\[2,3\\]\n**Output:** 2\n**Explanation:** To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.\nIn total, there are 2 schemes.\n\n**Example 2:**\n\n**Input:** n = 10, minProfit = 5, group = \\[2,3,5\\], profit = \\[6,7,8\\]\n**Output:** 7\n**Explanation:** To make a profit of at least 5, the group could commit any crimes, as long as they commit one.\nThere are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).\n\n**Constraints:**\n\n*   `1 <= n <= 100`\n*   `0 <= minProfit <= 100`\n*   `1 <= group.length <= 100`\n*   `1 <= group[i] <= 100`\n*   `profit.length == group.length`\n*   `0 <= profit[i] <= 100`",
          "output": "def max_dist_to_closest(seats):\n    max_dist = 0\n    last_person = -1\n    for i, seat in enumerate(seats):\n        if seat == 1:\n            max_dist = i if last_person < 0 else max(max_dist, (i - last_person) // 2)\n            last_person = i\n    return max(max_dist, len(seats) - 1 - last_person)\n"
     },
     {
          "instruction": "You are given `k` identical eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nEach move, you may take an unbroken egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n",
          "input": "**Example 1:**\n\n**Input:** k = 1, n = 2\n**Output:** 2\n**Explanation:** \nDrop the egg from floor 1. If it breaks, we know that f = 0.\nOtherwise, drop the egg from floor 2. If it breaks, we know that f = 1.\nIf it does not break, then we know f = 2.\nHence, we need at minimum 2 moves to determine with certainty what the value of f is.\n\n**Example 2:**\n\n**Input:** k = 2, n = 6\n**Output:** 3\n\n**Example 3:**\n\n**Input:** k = 3, n = 14\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= n <= 104`",
          "output": "import heapq\n\ndef mincost_to_hire_workers(quality, wage, k):\n    workers = sorted((w / q, q) for w, q in zip(wage, quality))\n    total_quality = 0\n    max_heap = []\n    result = float(\"inf\")\n\n    for ratio, q in workers:\n        heapq.heappush(max_heap, -q)\n        total_quality += q\n\n        if len(max_heap) > k:\n            total_quality += heapq.heappop(max_heap)\n\n        if len(max_heap) == k:\n            result = min(result, total_quality * ratio)\n\n    return result\n"
     },
     {
          "instruction": "Given an integer `n`, return _a list of all possible **full binary trees** with_ `n` _nodes_. Each node of each tree in the answer must have `Node.val == 0`.\n\nEach element of the answer is the root node of one possible tree. You may return the final list of trees in **any order**.\n\nA **full binary tree** is a binary tree where each node has exactly `0` or `2` children.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 7\n**Output:** \\[\\[0,0,0,null,null,0,0,null,null,0,0\\],\\[0,0,0,null,null,0,0,0,0\\],\\[0,0,0,0,0,0,0\\],\\[0,0,0,0,0,null,null,null,null,0,0\\],\\[0,0,0,0,0,null,null,0,0\\]\\]\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** \\[\\[0,0,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 20`",
          "output": "import random\n\nclass Solution:\n\n    def __init__(self, n: int, blacklist: List[int]):\n        self.blacklist_map = {}\n        self.reduced_n = n - len(blacklist)\n\n        for b in blacklist:\n            if b < n:\n                self.blacklist_map[b] = -1\n\n        for b in blacklist:\n            if b >= self.reduced_n:\n                continue\n            while n - 1 in self.blacklist_map:\n                n -= 1\n            self.blacklist_map[b] = n - 1\n            n -= 1\n\n    def pick(self) -> int:\n        random_int = random.randint(0, self.reduced_n - 1)\n        return self.blacklist_map.get(random_int, random_int)\n"
     },
     {
          "instruction": "Given an integer array `arr`, return _the number of distinct bitwise ORs of all the non-empty subarrays of_ `arr`.\n\nThe bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[0\\]\n**Output:** 1\n**Explanation:** There is only one possible result: 0.\n\n**Example 2:**\n\n**Input:** arr = \\[1,1,2\\]\n**Output:** 3\n**Explanation:** The possible subarrays are \\[1\\], \\[1\\], \\[2\\], \\[1, 1\\], \\[1, 2\\], \\[1, 1, 2\\].\nThese yield the results 1, 1, 2, 1, 3, 3.\nThere are 3 unique values, so the answer is 3.\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,4\\]\n**Output:** 6\n**Explanation:** The possible results are 1, 2, 3, 4, 6, and 7.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 5 * 104`\n*   `0 <= arr[i] <= 109`",
          "output": "def transpose(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    result = [[0] * rows for _ in range(cols)]\n    for i in range(rows):\n        for j in range(cols):\n            result[j][i] = matrix[i][j]\n    return result\n"
     },
     {
          "instruction": "Given an array of `digits` which is sorted in **non-decreasing** order. You can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.\n\nReturn _the number of positive integers that can be generated_ that are less than or equal to a given integer `n`.\n\n",
          "input": "**Example 1:**\n\n**Input:** digits = \\[ \"1 \", \"3 \", \"5 \", \"7 \"\\], n = 100\n**Output:** 20\n**Explanation:** \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n**Example 2:**\n\n**Input:** digits = \\[ \"1 \", \"4 \", \"9 \"\\], n = 1000000000\n**Output:** 29523\n**Explanation:** \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\n**Example 3:**\n\n**Input:** digits = \\[ \"7 \"\\], n = 8\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= digits.length <= 9`\n*   `digits[i].length == 1`\n*   `digits[i]` is a digit from `'1'` to `'9'`.\n*   All the values in `digits` are **unique**.\n*   `digits` is sorted in **non-decreasing** order.\n*   `1 <= n <= 109`",
          "output": "import heapq\n\ndef minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int:\n    i, stops, curFuel = 0, 0, startFuel\n    pq = []\n    while curFuel < target:\n        while i < len(stations) and stations[i][0] <= curFuel:\n            heapq.heappush(pq, -stations[i][1])\n            i += 1\n        if not pq: return -1\n        curFuel += -heapq.heappop(pq)\n        stops += 1\n    return stops\n"
     },
     {
          "instruction": "You are given a string `s` of length `n` where `s[i]` is either:\n\n*   `'D'` means decreasing, or\n*   `'I'` means increasing.\n\nA permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` is called a **valid permutation** if for all valid `i`:\n\n*   If `s[i] == 'D'`, then `perm[i] > perm[i + 1]`, and\n*   If `s[i] == 'I'`, then `perm[i] < perm[i + 1]`.\n\nReturn _the number of **valid permutations**_ `perm`. Since the answer may be large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"DID \"\n**Output:** 5\n**Explanation:** The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)\n\n**Example 2:**\n\n**Input:** s =  \"D \"\n**Output:** 1\n\n**Constraints:**\n\n*   `n == s.length`\n*   `1 <= n <= 200`\n*   `s[i]` is either `'I'` or `'D'`.",
          "output": "def rand7(): # Given API\n    pass\n\ndef rand10():\n    result = 41\n    while result > 40:\n        result = (rand7() - 1) * 7 + rand7()\n    return result % 10 + 1\n"
     },
     {
          "instruction": "Given an array of integers arr, find the sum of `min(b)`, where `b` ranges over every (contiguous) subarray of `arr`. Since the answer may be large, return the answer **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[3,1,2,4\\]\n**Output:** 17\n**Explanation:** \nSubarrays are \\[3\\], \\[1\\], \\[2\\], \\[4\\], \\[3,1\\], \\[1,2\\], \\[2,4\\], \\[3,1,2\\], \\[1,2,4\\], \\[3,1,2,4\\]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.\n\n**Example 2:**\n\n**Input:** arr = \\[11,81,94,43,3\\]\n**Output:** 444\n\n**Constraints:**\n\n*   `1 <= arr.length <= 3 * 104`\n*   `1 <= arr[i] <= 3 * 104`",
          "output": "def minEatingSpeed(piles, h):\n    left, right = 1, max(piles)\n    while left < right:\n        mid = left + (right - left) // 2\n        totalHours = sum((pile + mid - 1) // mid for pile in piles)\n        if totalHours > h:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n"
     },
     {
          "instruction": "A game on an **undirected** graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.\n\nDuring each player's turn, they **must** travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it **must** travel to any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n*   If ever the Cat occupies the same node as the Mouse, the Cat wins.\n*   If ever the Mouse reaches the Hole, the Mouse wins.\n*   If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n*   `1` if the mouse wins the game,\n*   `2` if the cat wins the game, or\n*   `0` if the game is a draw.\n\n",
          "input": "**Example 1:**\n\n**Input:** graph = \\[\\[2,5\\],\\[3\\],\\[0,4,5\\],\\[1,4,5\\],\\[2,3\\],\\[0,2,3\\]\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0\\],\\[3\\],\\[0,2\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `3 <= graph.length <= 50`\n*   `1 <= graph[i].length < graph.length`\n*   `0 <= graph[i][j] < graph.length`\n*   `graph[i][j] != i`\n*   `graph[i]` is unique.\n*   The mouse and the cat can always move.",
          "output": "import random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.grid = [[0] * n for _ in range(m)]\n        self.zero_count = m * n\n\n    def pick(self):\n        index = random.randrange(self.zero_count)\n\n        for i, row in enumerate(self.grid):\n            for j, cell in enumerate(row):\n                if cell == 0:\n                    if index == 0:\n                        self.grid[i][j] = 1\n                        self.zero_count -= 1\n                        return (i, j)\n                    index -= 1\n        return (-1, -1)  # Should not happen\n"
     },
     {
          "instruction": "Given a **circular integer array** `nums` of length `n`, return _the maximum possible sum of a non-empty **subarray** of_ `nums`.\n\nA **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.\n\nA **subarray** may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,-2,3,-2\\]\n**Output:** 3\n**Explanation:** Subarray \\[3\\] has maximum sum 3.\n\n**Example 2:**\n\n**Input:** nums = \\[5,-3,5\\]\n**Output:** 10\n**Explanation:** Subarray \\[5,5\\] has maximum sum 5 + 5 = 10.\n\n**Example 3:**\n\n**Input:** nums = \\[-3,-2,-3\\]\n**Output:** -2\n**Explanation:** Subarray \\[-2\\] has maximum sum -2.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`",
          "output": "from heapq import heappush, heappop\n\ndef reachableNodes(edges, maxMoves, n):\n    graph = [[] for _ in range(n)]\n    for u, v, cnt in edges:\n        graph[u].append((v, cnt + 1))\n        graph[v].append((u, cnt + 1))\n\n    visited = set()\n    pq = [(-maxMoves, 0)]\n\n    while pq:\n        moves_left, node = heappop(pq)\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for next_node, moves_needed in graph[node]:\n            moves_left_after = moves_left - moves_needed\n            if next_node not in visited and moves_left_after > 0:\n                heappush(pq, (moves_left_after, next_node))\n\n    return len(visited)\n"
     },
     {
          "instruction": "Your music player contains `n` different songs. You want to listen to `goal` songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n*   Every song is played **at least once**.\n*   A song can only be played again only if `k` other songs have been played.\n\nGiven `n`, `goal`, and `k`, return _the number of possible playlists that you can create_. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, goal = 3, k = 1\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 2, 3\\], \\[1, 3, 2\\], \\[2, 1, 3\\], \\[2, 3, 1\\], \\[3, 1, 2\\], and \\[3, 2, 1\\].\n\n**Example 2:**\n\n**Input:** n = 2, goal = 3, k = 0\n**Output:** 6\n**Explanation:** There are 6 possible playlists: \\[1, 1, 2\\], \\[1, 2, 1\\], \\[2, 1, 1\\], \\[2, 2, 1\\], \\[2, 1, 2\\], and \\[1, 2, 2\\].\n\n**Example 3:**\n\n**Input:** n = 2, goal = 3, k = 1\n**Output:** 2\n**Explanation:** There are 2 possible playlists: \\[1, 2, 1\\] and \\[2, 1, 2\\].\n\n**Constraints:**\n\n*   `0 <= k < n <= goal <= 100`",
          "output": "def uncommon_from_sentences(s1, s2):\n    word_count = {}\n    for word in (s1 + \" \" + s2).split():\n        word_count[word] = word_count.get(word, 0) + 1\n\n    return [key for key, val in word_count.items() if val == 1]\n"
     },
     {
          "instruction": "A binary string is monotone increasing if it consists of some number of `0`'s (possibly none), followed by some number of `1`'s (also possibly none).\n\nYou are given a binary string `s`. You can flip `s[i]` changing it from `0` to `1` or from `1` to `0`.\n\nReturn _the minimum number of flips to make_ `s` _monotone increasing_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"00110 \"\n**Output:** 1\n**Explanation:** We flip the last digit to get 00111.\n\n**Example 2:**\n\n**Input:** s =  \"010110 \"\n**Output:** 2\n**Explanation:** We flip to get 011111, or alternatively 000111.\n\n**Example 3:**\n\n**Input:** s =  \"00011000 \"\n**Output:** 2\n**Explanation:** We flip to get 00000000.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.",
          "output": "def find_and_replace_patterns(words, pattern):\n    result = []\n    for word in words:\n        if len(word) != len(pattern): continue\n\n        w2p = {}\n        p2w = {}\n        matches = True\n        for cWord, cPattern in zip(word, pattern):\n            if cWord not in w2p: w2p[cWord] = cPattern\n            if cPattern not in p2w: p2w[cPattern] = cWord\n\n            if w2p[cWord] != cPattern or p2w[cPattern] != cWord:\n                matches = False\n                break\n\n        if matches: result.append(word)\n    return result\n"
     },
     {
          "instruction": "Given an `n x n` array of integers `matrix`, return _the **minimum sum** of any **falling path** through_ `matrix`.\n\nA **falling path** starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position `(row, col)` will be `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.\n\n",
          "input": "**Example 1:**\n\n**Input:** matrix = \\[\\[2,1,3\\],\\[6,5,4\\],\\[7,8,9\\]\\]\n**Output:** 13\n**Explanation:** There are two falling paths with a minimum sum as shown.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[-19,57\\],\\[-40,-5\\]\\]\n**Output:** -59\n**Explanation:** The falling path with a minimum sum is shown.\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 100`\n*   `-100 <= matrix[i][j] <= 100`",
          "output": "from collections import defaultdict, deque\n\nclass FreqStack:\n    def __init__(self):\n        self.freq = defaultdict(int)\n        self.group = defaultdict(list)\n\n    def push(self, x: int):\n        freq = self.freq[x] = self.freq[x] + 1\n        self.group[freq].append(x)\n\n    def pop(self) -> int:\n        max_freq = max(self.group)\n        x = self.group[max_freq].pop()\n        self.freq[x] -= 1\n        if not self.group[max_freq]:\n            del self.group[max_freq]\n        return x\n"
     },
     {
          "instruction": "The chess knight has a **unique movement**, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an **L**). The possible movements of chess knight are shown in this diagaram:\n\nA chess knight can move as indicated in the chess diagram below:\n\nWe have a chess knight and a phone pad as shown below, the knight **can only stand on a numeric cell** (i.e. blue cell).\n\nGiven an integer `n`, return how many distinct phone numbers of length `n` we can dial.\n\nYou are allowed to place the knight **on any numeric cell** initially and then you should perform `n - 1` jumps to dial a number of length `n`. All jumps should be **valid** knight jumps.\n\nAs the answer may be very large, **return the answer modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** 10\n**Explanation:** We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 20\n**Explanation:** All the valid number we can dial are \\[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94\\]\n\n**Example 3:**\n\n**Input:** n = 3131\n**Output:** 136006598\n**Explanation:** Please take care of the mod.\n\n**Constraints:**\n\n*   `1 <= n <= 5000`",
          "output": "def lex_smallest_string(s, k):\n    res = s\n    for i in range(k):\n        tmp = s[i:] + s[:i]\n        if tmp < res:\n            res = tmp\n    return res\n"
     },
     {
          "instruction": "Given a string s, return _the number of **distinct non-empty subsequences** of_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"abc \"\n**Output:** 7\n**Explanation:** The 7 distinct subsequences are  \"a \",  \"b \",  \"c \",  \"ab \",  \"ac \",  \"bc \", and  \"abc \".\n\n**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 6\n**Explanation:** The 6 distinct subsequences are  \"a \",  \"b \",  \"ab \",  \"aa \",  \"ba \", and  \"aba \".\n\n**Example 3:**\n\n**Input:** s =  \"aaa \"\n**Output:** 3\n**Explanation:** The 3 distinct subsequences are  \"a \",  \"aa \" and  \"aaa \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.",
          "output": "def totalFruit(fruits):\n    left, right, max_count = 0, 0, 0\n    count = {}\n\n    while right < len(fruits):\n        count[fruits[right]] = count.get(fruits[right], 0) + 1\n        while len(count) > 2:\n            count[fruits[left]] -= 1\n            if count[fruits[left]] == 0:\n                del count[fruits[left]]\n            left += 1\n        max_count = max(max_count, right - left + 1)\n        right += 1\n\n    return max_count\n"
     },
     {
          "instruction": "Given an array of strings `words`, return _the smallest string that contains each string in_ `words` _as a substring_. If there are multiple valid strings of the smallest length, return **any of them**.\n\nYou may assume that no string in `words` is a substring of another string in `words`.\n\n",
          "input": "**Example 1:**\n\n**Input:** words = \\[ \"alex \", \"loves \", \"leetcode \"\\]\n**Output:**  \"alexlovesleetcode \"\n**Explanation:** All permutations of  \"alex \", \"loves \", \"leetcode \" would also be accepted.\n\n**Example 2:**\n\n**Input:** words = \\[ \"catg \", \"ctaagt \", \"gcta \", \"ttca \", \"atgcatc \"\\]\n**Output:**  \"gctaagttcatgcatc \"\n\n**Constraints:**\n\n*   `1 <= words.length <= 12`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are **unique**.",
          "output": "def sum_of_mins(arr):\n    mod = 10**9 + 7\n    n = len(arr)\n    left, right = [0] * n, [0] * n\n    st = []\n\n    for i in range(n):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        left[i] = st[-1] if st else -1\n        st.append(i)\n\n    st.clear()\n    for i in range(n - 1, -1, -1):\n        while st and arr[st[-1]] > arr[i]:\n            st.pop()\n        right[i] = st[-1] if st else n\n        st.append(i)\n\n    ans = 0\n    for i in range(n):\n        ans = (ans + arr[i] * (i - left[i]) * (right[i] - i)) % mod\n    return ans\n"
     },
     {
          "instruction": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n\nYou are given a collection of `rods` that can be welded together. For example, if you have rods of lengths `1`, `2`, and `3`, you can weld them together to make a support of length `6`.\n\nReturn _the largest possible height of your billboard installation_. If you cannot support the billboard, return `0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** rods = \\[1,2,3,6\\]\n**Output:** 6\n**Explanation:** We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n**Example 2:**\n\n**Input:** rods = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n**Example 3:**\n\n**Input:** rods = \\[1,2\\]\n**Output:** 0\n**Explanation:** The billboard cannot be supported, so we return 0.\n\n**Constraints:**\n\n*   `1 <= rods.length <= 20`\n*   `1 <= rods[i] <= 1000`\n*   `sum(rods[i]) <= 5000`",
          "output": "def numMusicPlaylists(n, goal, k):\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(goal + 1)]\n    dp[0][0] = 1\n    for i in range(1, goal + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j - 1] * (n - (j - 1)) % MOD + dp[i - 1][j] * max(0, j - k) % MOD) % MOD\n    return dp[goal][n]\n"
     },
     {
          "instruction": "You are given an array of `n` strings `strs`, all of the same length.\n\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\n\nFor example, if we have `strs = [ \"abcdef \", \"uvwxyz \"]` and deletion indices `{0, 2, 3}`, then the final array after deletions is `[ \"bef \", \"vyz \"]`.\n\nSuppose we chose a set of deletion indices `answer` such that after deletions, the final array has **every string (row) in lexicographic** order. (i.e., `(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])`, and `(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])`, and so on). Return _the minimum possible value of_ `answer.length`.\n\n",
          "input": "**Example 1:**\n\n**Input:** strs = \\[ \"babca \", \"bbazb \"\\]\n**Output:** 3\n**Explanation:** After deleting columns 0, 1, and 4, the final array is strs = \\[ \"bc \",  \"az \"\\].\nBoth these rows are individually in lexicographic order (ie. strs\\[0\\]\\[0\\] <= strs\\[0\\]\\[1\\] and strs\\[1\\]\\[0\\] <= strs\\[1\\]\\[1\\]).\nNote that strs\\[0\\] > strs\\[1\\] - the array strs is not necessarily in lexicographic order.\n\n**Example 2:**\n\n**Input:** strs = \\[ \"edcba \"\\]\n**Output:** 4\n**Explanation:** If we delete less than 4 columns, the only row will not be lexicographically sorted.\n\n**Example 3:**\n\n**Input:** strs = \\[ \"ghi \", \"def \", \"abc \"\\]\n**Output:** 0\n**Explanation:** All rows are already lexicographically sorted.\n\n**Constraints:**\n\n*   `n == strs.length`\n*   `1 <= n <= 100`\n*   `1 <= strs[i].length <= 100`\n*   `strs[i]` consists of lowercase English letters.",
          "output": "from collections import deque\n\ndef minMalwareSpread(graph, initial):\n    n = len(graph)\n    initial.sort()\n    \n    malware = set(initial)\n    \n    minNode = initial[0]\n    minSpread = n + 1\n\n    for node in initial:\n        q = deque(otherNode for otherNode in initial if node != otherNode)\n        visited = [node != otherNode and otherNode in malware for otherNode in range(n)]\n        \n        while q:\n            cur = q.popleft()\n            for next, isConnected in enumerate(graph[cur]):\n                if isConnected and not visited[next] and next not in malware:\n                    visited[next] = True\n                    q.append(next)\n        \n        spread = sum(visited)\n        \n        if spread < minSpread:\n            minNode = node\n            minSpread = spread\n    \n    return minNode\n"
     },
     {
          "instruction": "Given a single positive integer `x`, we will write an expression of the form `x (op1) x (op2) x (op3) x ...` where each operator `op1`, `op2`, etc. is either addition, subtraction, multiplication, or division (`+`, `-`, `*`, or `/)`. For example, with `x = 3`, we might write `3 * 3 / 3 + 3 - 3` which is a value of 3.\n\nWhen writing such an expression, we adhere to the following conventions:\n\n*   The division operator (`/`) returns rational numbers.\n*   There are no parentheses placed anywhere.\n*   We use the usual order of operations: multiplication and division happen before addition and subtraction.\n*   It is not allowed to use the unary negation operator (`-`). For example, \"`x - x` \" is a valid expression as it only uses subtraction, but \"`-x + x` \" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such that the expression equals the given `target`. Return the least number of operators used.\n\n",
          "input": "**Example 1:**\n\n**Input:** x = 3, target = 19\n**Output:** 5\n**Explanation:** 3 \\* 3 + 3 \\* 3 + 3 / 3.\nThe expression contains 5 operations.\n\n**Example 2:**\n\n**Input:** x = 5, target = 501\n**Output:** 8\n**Explanation:** 5 \\* 5 \\* 5 \\* 5 - 5 \\* 5 \\* 5 + 5 / 5.\nThe expression contains 8 operations.\n\n**Example 3:**\n\n**Input:** x = 100, target = 100000000\n**Output:** 3\n**Explanation:** 100 \\* 100 \\* 100 \\* 100.\nThe expression contains 3 operations.\n\n**Constraints:**\n\n*   `2 <= x <= 100`\n*   `1 <= target <= 2 * 108`",
          "output": "from collections import deque\nfrom typing import List\n\ndef minMalwareSpread(graph: List[List[int]], initial: List[int]) -> int:\n    n = len(graph)\n    color = [-1] * n\n    colors = 0\n\n    for i in range(n):\n        if color[i] == -1:\n            q = deque([i])\n            color[i] = colors\n\n            while q:\n                t = q.popleft()\n                for j in range(n):\n                    if graph[t][j] == 1 and color[j] == -1:\n                        q.append(j)\n                        color[j] = colors\n\n            colors += 1\n\n    area = [0] * colors\n    count = [0] * colors\n    initially_infected = set(initial)\n    for i in range(n):\n        area[color[i]] += 1\n        if i in initially_infected:\n            count[color[i]] += 1\n\n    res = min(initial)\n    min_size = n + 1\n    for i in initial:\n        if count[color[i]] == 1:\n            if area[color[i]] < min_size:\n                min_size = area[color[i]]\n                res = i\n            elif area[color[i]] == min_size and i < res:\n                res = i\n\n    return res\n"
     },
     {
          "instruction": "You are given the `root` of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\nReturn _the minimum number of cameras needed to monitor all nodes of the tree_.\n\n",
          "input": "**Example 1:**\n\n**Input:** root = \\[0,0,null,0,0\\]\n**Output:** 1\n**Explanation:** One camera is enough to monitor all nodes if placed as shown.\n\n**Example 2:**\n\n**Input:** root = \\[0,0,null,0,null,0,null,null,0\\]\n**Output:** 2\n**Explanation:** At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `Node.val == 0`",
          "output": "def beautifulArray(n: int) -> List[int]:\n    result = [1]\n    while len(result) < n:\n        temp = []\n        for i in result:\n            if i * 2 - 1 <= n:\n                temp.append(i * 2 - 1)\n        for i in result:\n            if i * 2 <= n:\n                temp.append(i * 2)\n        result = temp\n    return result\n"
     },
     {
          "instruction": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n**Constraints:**\n\n*   `0 <= n <= 30`",
          "output": "def fib(n: int) -> int:\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n"
     },
     {
          "instruction": "You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called **odd-numbered jumps**, and the (2nd, 4th, 6th, ...) jumps in the series are called **even-numbered jumps**. Note that the **jumps** are numbered, not the indices.\n\nYou may jump forward from index `i` to index `j` (with `i < j`) in the following way:\n\n*   During **odd-numbered jumps** (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   During **even-numbered jumps** (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the **smallest** such index `j`.\n*   It may be the case that for some index `i`, there are no legal jumps.\n\nA starting index is **good** if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).\n\nReturn _the number of **good** starting indices_.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[10,13,12,14,15\\]\n**Output:** 2\n**Explanation:** \nFrom starting index i = 0, we can make our 1st jump to i = 2 (since arr\\[2\\] is the smallest among arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\] that is greater or equal to arr\\[0\\]), then we cannot jump any more.\nFrom starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.\nFrom starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.\nFrom starting index i = 4, we have reached the end already.\nIn total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of\njumps.\n\n**Example 2:**\n\n**Input:** arr = \\[2,3,1,1,4\\]\n**Output:** 3\n**Explanation:** \nFrom starting index i = 0, we make jumps to i = 1, i = 2, i = 3:\nDuring our 1st jump (odd-numbered), we first jump to i = 1 because arr\\[1\\] is the smallest value in \\[arr\\[1\\], arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[0\\].\nDuring our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr\\[2\\] is the largest value in \\[arr\\[2\\], arr\\[3\\], arr\\[4\\]\\] that is less than or equal to arr\\[1\\]. arr\\[3\\] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3\nDuring our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr\\[3\\] is the smallest value in \\[arr\\[3\\], arr\\[4\\]\\] that is greater than or equal to arr\\[2\\].\nWe can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.\nIn a similar manner, we can deduce that:\nFrom starting index i = 1, we jump to i = 4, so we reach the end.\nFrom starting index i = 2, we jump to i = 3, and then we can't jump anymore.\nFrom starting index i = 3, we jump to i = 4, so we reach the end.\nFrom starting index i = 4, we are already at the end.\nIn total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some\nnumber of jumps.\n\n**Example 3:**\n\n**Input:** arr = \\[5,1,3,4,2\\]\n**Output:** 3\n**Explanation:** We can reach the end from starting indices 1, 2, and 4.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 2 * 104`\n*   `0 <= arr[i] < 105`",
          "output": "def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:\n    if not root:\n        return 0\n    if root.val < low:\n        return self.rangeSumBST(root.right, low, high)\n    if root.val > high:\n        return self.rangeSumBST(root.left, low, high)\n    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)\n"
     },
     {
          "instruction": "Given an integer array `arr`, return _the length of a maximum size turbulent subarray of_ `arr`.\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent pair of elements in the subarray.\n\nMore formally, a subarray `[arr[i], arr[i + 1], ..., arr[j]]` of `arr` is said to be turbulent if and only if:\n\n*   For `i <= k < j`:\n    *   `arr[k] > arr[k + 1]` when `k` is odd, and\n    *   `arr[k] < arr[k + 1]` when `k` is even.\n*   Or, for `i <= k < j`:\n    *   `arr[k] > arr[k + 1]` when `k` is even, and\n    *   `arr[k] < arr[k + 1]` when `k` is odd.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[9,4,2,10,7,8,8,1,9\\]\n**Output:** 5\n**Explanation:** arr\\[1\\] > arr\\[2\\] < arr\\[3\\] > arr\\[4\\] < arr\\[5\\]\n\n**Example 2:**\n\n**Input:** arr = \\[4,8,12,16\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** arr = \\[100\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= arr.length <= 4 * 104`\n*   `0 <= arr[i] <= 109`",
          "output": "def valid_mountain_array(arr):\n    n, i, j = len(arr), 0, len(arr) - 1\n    while i + 1 < n and arr[i] < arr[i + 1]:\n        i += 1\n    while j > 0 and arr[j - 1] > arr[j]:\n        j -= 1\n    return i > 0 and i == j and j < n - 1\n"
     },
     {
          "instruction": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array `days`. Each day is an integer from `1` to `365`.\n\nTrain tickets are sold in **three different ways**:\n\n*   a **1-day** pass is sold for `costs[0]` dollars,\n*   a **7-day** pass is sold for `costs[1]` dollars, and\n*   a **30-day** pass is sold for `costs[2]` dollars.\n\nThe passes allow that many days of consecutive travel.\n\n*   For example, if we get a **7-day** pass on day `2`, then we can travel for `7` days: `2`, `3`, `4`, `5`, `6`, `7`, and `8`.\n\nReturn _the minimum number of dollars you need to travel every day in the given list of days_.\n\n",
          "input": "**Example 1:**\n\n**Input:** days = \\[1,4,6,7,8,20\\], costs = \\[2,7,15\\]\n**Output:** 11\n**Explanation:** For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs\\[0\\] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs\\[1\\] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs\\[0\\] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n\n**Example 2:**\n\n**Input:** days = \\[1,2,3,4,5,6,7,8,9,10,30,31\\], costs = \\[2,7,15\\]\n**Output:** 17\n**Explanation:** For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs\\[2\\] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs\\[0\\] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n\n**Constraints:**\n\n*   `1 <= days.length <= 365`\n*   `1 <= days[i] <= 365`\n*   `days` is in strictly increasing order.\n*   `costs.length == 3`\n*   `1 <= costs[i] <= 1000`",
          "output": "def validateStackSequences(pushed, popped):\n    stack = []\n    popIndex = 0\n    \n    for pushValue in pushed:\n        stack.append(pushValue)\n        while stack and stack[-1] == popped[popIndex]:\n            stack.pop()\n            popIndex += 1\n    \n    return not stack\n"
     },
     {
          "instruction": "An array is **squareful** if the sum of every pair of adjacent elements is a **perfect square**.\n\nGiven an integer array nums, return _the number of permutations of_ `nums` _that are **squareful**_.\n\nTwo permutations `perm1` and `perm2` are different if there is some index `i` such that `perm1[i] != perm2[i]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,17,8\\]\n**Output:** 2\n**Explanation:** \\[1,8,17\\] and \\[17,8,1\\] are the valid permutations.\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,2\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= nums.length <= 12`\n*   `0 <= nums[i] <= 109`",
          "output": "from collections import Counter\n\ndef numSquarefulPerms(nums):\n    def is_square(n):\n        return int(n ** 0.5) ** 2 == n\n\n    def dfs(idx):\n        if idx == len(nums):\n            return 1\n\n        count = 0\n        for key in counter.keys():\n            if counter[key] and (idx == 0 or is_square(nums[idx - 1] + key)):\n                counter[key] -= 1\n                nums[idx] = key\n                count += dfs(idx + 1)\n                counter[key] += 1\n\n        return count\n\n    key_set, counter = set(nums), Counter(nums)\n    return dfs(0)\n"
     },
     {
          "instruction": "There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones.\n\nA move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles.\n\nReturn _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 2\n**Output:** 20\n**Explanation:** We start with \\[3, 2, 4, 1\\].\nWe merge \\[3, 2\\] for a cost of 5, and we are left with \\[5, 4, 1\\].\nWe merge \\[4, 1\\] for a cost of 5, and we are left with \\[5, 5\\].\nWe merge \\[5, 5\\] for a cost of 10, and we are left with \\[10\\].\nThe total cost was 20, and this is the minimum possible.\n\n**Example 2:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 3\n**Output:** -1\n**Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n**Example 3:**\n\n**Input:** stones = \\[3,5,1,2,6\\], k = 3\n**Output:** 25\n**Explanation:** We start with \\[3, 5, 1, 2, 6\\].\nWe merge \\[5, 1, 2\\] for a cost of 8, and we are left with \\[3, 8, 6\\].\nWe merge \\[3, 8, 6\\] for a cost of 17, and we are left with \\[17\\].\nThe total cost was 25, and this is the minimum possible.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `1 <= n <= 30`\n*   `1 <= stones[i] <= 100`\n*   `2 <= k <= 30`",
          "output": "def min_deletion_size(strs):\n    rows, cols = len(strs), len(strs[0])\n    count = 0\n    for c in range(cols):\n        for r in range(1, rows):\n            if strs[r - 1][c] > strs[r][c]:\n                count += 1\n                break\n    return count\n"
     },
     {
          "instruction": "A **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).\n\nGiven two strings `source` and `target`, return _the minimum number of **subsequences** of_ `source` _such that their concatenation equals_ `target`. If the task is impossible, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** source =  \"abc \", target =  \"abcbc \"\n**Output:** 2\n**Explanation:** The target  \"abcbc \" can be formed by  \"abc \" and  \"bc \", which are subsequences of source  \"abc \".\n\n**Example 2:**\n\n**Input:** source =  \"abc \", target =  \"acdbc \"\n**Output:** -1\n**Explanation:** The target string cannot be constructed from the subsequences of source string due to the character  \"d \" in target string.\n\n**Example 3:**\n\n**Input:** source =  \"xyz \", target =  \"xzyxz \"\n**Output:** 3\n**Explanation:** The target string can be constructed as follows  \"xz \" +  \"y \" +  \"xz \".\n\n**Constraints:**\n\n*   `1 <= source.length, target.length <= 1000`\n*   `source` and `target` consist of lowercase English letters.",
          "output": "def num_pairs_divisible_by60(time):\n    count = [0] * 60\n    pairs = 0\n\n    for t in time:\n        mod = t % 60\n        pairs += count[(60 - mod) % 60]\n        count[mod] += 1\n\n    return pairs\n"
     },
     {
          "instruction": "Given an integer `n`, return _the number of positive integers in the range_ `[1, n]` _that have **at least one** repeated digit_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 20\n**Output:** 1\n**Explanation:** The only positive number (<= 20) with at least 1 repeated digit is 11.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 10\n**Explanation:** The positive numbers (<= 100) with atleast 1 repeated digit are 11, 22, 33, 44, 55, 66, 77, 88, 99, and 100.\n\n**Example 3:**\n\n**Input:** n = 1000\n**Output:** 262\n\n**Constraints:**\n\n*   `1 <= n <= 109`",
          "output": "def isRationalEqual(s: str, t: str) -> bool:\n    def evaluate(s: str) -> float:\n        i = s.find('(')\n        if i != -1:\n            base = s[:i]\n            rep = s[i + 1:-1]\n            return float(base + rep * 20)\n        return float(s)\n\n    return abs(evaluate(s) - evaluate(t)) < 1e-12\n"
     },
     {
          "instruction": "Given a string `s`, return _the length of the longest repeating substrings_. If no repeating substring exists, return `0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"abcd \"\n**Output:** 0\n**Explanation:** There is no repeating substring.\n\n**Example 2:**\n\n**Input:** s =  \"abbaba \"\n**Output:** 2\n**Explanation:** The longest repeating substrings are  \"ab \" and  \"ba \", each of which occurs twice.\n\n**Example 3:**\n\n**Input:** s =  \"aabcaabdaab \"\n**Output:** 3\n**Explanation:** The longest repeating substring is  \"aab \", which occurs `3` times.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters.",
          "output": "def find_longest_repeating_substring(s: str) -> int:\n    n = len(s)\n    max_substr_length = 0\n    for length in range(1, n // 2 + 1):\n        max_repeat_count = repeat_count = 0\n        for i in range(n - length):\n            if s[i:i + length] == s[i + length:i + 2 * length]:\n                repeat_count += 1\n            else:\n                max_repeat_count = max(max_repeat_count, repeat_count)\n                repeat_count = 0\n        max_substr_length = max(max_substr_length, max_repeat_count * length)\n    return max_substr_length\n"
     },
     {
          "instruction": "You are given an integer array `values` where values\\[i\\] represents the value of the `ith` sightseeing spot. Two sightseeing spots `i` and `j` have a **distance** `j - i` between them.\n\nThe score of a pair (`i < j`) of sightseeing spots is `values[i] + values[j] + i - j`: the sum of the values of the sightseeing spots, minus the distance between them.\n\nReturn _the maximum score of a pair of sightseeing spots_.\n\n",
          "input": "**Example 1:**\n\n**Input:** values = \\[8,1,5,2,6\\]\n**Output:** 11\n**Explanation:** i = 0, j = 2, values\\[i\\] + values\\[j\\] + i - j = 8 + 5 + 0 - 2 = 11\n\n**Example 2:**\n\n**Input:** values = \\[1,2\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `2 <= values.length <= 5 * 104`\n*   `1 <= values[i] <= 1000`",
          "output": "def kClosest(points, k):\n    points.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    return points[:k]\n"
     },
     {
          "instruction": "On a campus represented as a 2D grid, there are `n` workers and `m` bikes, with `n <= m`. Each worker and bike is a 2D coordinate on this grid.\n\nWe assign one unique bike to each worker so that the sum of the **Manhattan distances** between each worker and their assigned bike is minimized.\n\nReturn `the minimum possible sum of Manhattan distances between each worker and their assigned bike`.\n\nThe **Manhattan distance** between two points `p1` and `p2` is `Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|`.\n\n",
          "input": "**Example 1:**\n\n**Input:** workers = \\[\\[0,0\\],\\[2,1\\]\\], bikes = \\[\\[1,2\\],\\[3,3\\]\\]\n**Output:** 6\n**Explanation:** \nWe assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.\n\n**Example 2:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\]\\], bikes = \\[\\[1,0\\],\\[2,2\\],\\[2,1\\]\\]\n**Output:** 4\n**Explanation:** \nWe first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.\n\n**Example 3:**\n\n**Input:** workers = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\],\\[3,0\\],\\[4,0\\]\\], bikes = \\[\\[0,999\\],\\[1,999\\],\\[2,999\\],\\[3,999\\],\\[4,999\\]\\]\n**Output:** 4995\n\n**Constraints:**\n\n*   `n == workers.length`\n*   `m == bikes.length`\n*   `1 <= n <= m <= 10`\n*   `workers[i].length == 2`\n*   `bikes[i].length == 2`\n*   `0 <= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] < 1000`\n*   All the workers and the bikes locations are **unique**.",
          "output": "from typing import List\n\ndef manhattan_distance(worker: List[int], bike: List[int]) -> int:\n    return abs(worker[0] - bike[0]) + abs(worker[1] - bike[1])\n\ndef dfs(workers: List[List[int]], bikes: List[List[int]], used: List[bool], index: int, dist: int, min_dist: List[int]) -> None:\n    if index == len(workers):\n        min_dist[0] = min(min_dist[0], dist)\n        return\n\n    if dist >= min_dist[0]:\n        return\n\n    for i in range(len(bikes)):\n        if used[i]:\n            continue\n        used[i] = True\n        cur_dist = manhattan_distance(workers[index], bikes[i])\n        dfs(workers, bikes, used, index + 1, dist + cur_dist, min_dist)\n        used[i] = False\n\ndef assign_bikes(workers: List[List[int]], bikes: List[List[int]]) -> int:\n    min_dist = [float('inf')]\n    used = [False] * len(bikes)\n    dfs(workers, bikes, used, 0, 0, min_dist)\n    return min_dist[0]\n"
     },
     {
          "instruction": "Given a single-digit integer `d` and two integers `low` and `high`, return _the number of times that_ `d` _occurs as a digit in all integers in the inclusive range_ `[low, high]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** d = 1, low = 1, high = 13\n**Output:** 6\n**Explanation:** The digit d = 1 occurs 6 times in 1, 10, 11, 12, 13.\nNote that the digit d = 1 occurs twice in the number 11.\n\n**Example 2:**\n\n**Input:** d = 3, low = 100, high = 250\n**Output:** 35\n**Explanation:** The digit d = 3 occurs 35 times in 103,113,123,130,131,...,238,239,243.\n\n**Constraints:**\n\n*   `0 <= d <= 9`\n*   `1 <= low <= high <= 2 * 108`",
          "output": "def count_digit(d, low, high):\n    count = 0\n    for i in range(low, high + 1):\n        num = i\n        while num > 0:\n            if num % 10 == d:\n                count += 1\n            num //= 10\n    return count\n"
     },
     {
          "instruction": "You are given a series of video clips from a sporting event that lasted `time` seconds. These video clips can be overlapping with each other and have varying lengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti, endi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n*   For example, a clip `[0, 7]` can be cut into segments `[0, 1] + [1, 3] + [3, 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event_ `[0, time]`. If the task is impossible, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** clips = \\[\\[0,2\\],\\[4,6\\],\\[8,10\\],\\[1,9\\],\\[1,5\\],\\[5,9\\]\\], time = 10\n**Output:** 3\n**Explanation:** We take the clips \\[0,2\\], \\[8,10\\], \\[1,9\\]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut \\[1,9\\] into segments \\[1,2\\] + \\[2,8\\] + \\[8,9\\].\nNow we have segments \\[0,2\\] + \\[2,8\\] + \\[8,10\\] which cover the sporting event \\[0, 10\\].\n\n**Example 2:**\n\n**Input:** clips = \\[\\[0,1\\],\\[1,2\\]\\], time = 5\n**Output:** -1\n**Explanation:** We cannot cover \\[0,5\\] with only \\[0,1\\] and \\[1,2\\].\n\n**Example 3:**\n\n**Input:** clips = \\[\\[0,1\\],\\[6,8\\],\\[0,2\\],\\[5,6\\],\\[0,4\\],\\[0,3\\],\\[6,7\\],\\[1,3\\],\\[4,7\\],\\[1,4\\],\\[2,5\\],\\[2,6\\],\\[3,4\\],\\[4,5\\],\\[5,7\\],\\[6,9\\]\\], time = 9\n**Output:** 3\n**Explanation:** We can take clips \\[0,4\\], \\[4,7\\], and \\[6,9\\].\n\n**Constraints:**\n\n*   `1 <= clips.length <= 100`\n*   `0 <= starti <= endi <= 100`\n*   `1 <= time <= 100`\n\n0 <= i < j < k < nums.length, and nums\\[i\\] & nums\\[j\\] & nums\\[k\\] != 0. (\\`&\\` represents the bitwise AND operation.)",
          "output": "def count_and_triples(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            for k in range(j + 1, len(nums)):\n                if nums[i] & nums[j] & nums[k] != 0:\n                    count += 1\n    return count\n"
     },
     {
          "instruction": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** true\n**Explanation:** Alice chooses 1, and Bob has no more moves.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** false\n**Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`",
          "output": "def mincostTickets(days, costs):\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]\n"
     },
     {
          "instruction": "Given an array `nums` of integers, return _the length of the longest arithmetic subsequence in_ `nums`.\n\n**Note** that:\n\n*   A **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n*   A sequence `seq` is arithmetic if `seq[i + 1] - seq[i]` are all the same value (for `0 <= i < seq.length - 1`).\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,6,9,12\\]\n**Output:** 4\n**Explanation: ** The whole array is an arithmetic sequence with steps of length = 3.\n\n**Example 2:**\n\n**Input:** nums = \\[9,4,7,2,10\\]\n**Output:** 3\n**Explanation: ** The longest arithmetic subsequence is \\[4,7,10\\].\n\n**Example 3:**\n\n**Input:** nums = \\[20,1,15,3,10,5,8\\]\n**Output:** 4\n**Explanation: ** The longest arithmetic subsequence is \\[20,15,10,5\\].\n\n**Constraints:**\n\n*   `2 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 500`",
          "output": "def sumEvenAfterQueries(nums, queries):\n    answer = []\n    even_sum = sum(num for num in nums if num % 2 == 0)\n\n    for value, index in queries:\n        if nums[index] % 2 == 0:\n            even_sum -= nums[index]\n        nums[index] += value\n        if nums[index] % 2 == 0:\n            even_sum += nums[index]\n        answer.append(even_sum)\n\n    return answer\n"
     },
     {
          "instruction": "Given an integer array `nums` and two integers `firstLen` and `secondLen`, return _the maximum sum of elements in two non-overlapping **subarrays** with lengths_ `firstLen` _and_ `secondLen`.\n\nThe array with length `firstLen` could occur before or after the array with length `secondLen`, but they have to be non-overlapping.\n\nA **subarray** is a **contiguous** part of an array.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[0,6,5,2,2,5,1,9,4\\], firstLen = 1, secondLen = 2\n**Output:** 20\n**Explanation:** One choice of subarrays is \\[9\\] with length 1, and \\[6,5\\] with length 2.\n\n**Example 2:**\n\n**Input:** nums = \\[3,8,1,3,2,1,8,9,0\\], firstLen = 3, secondLen = 2\n**Output:** 29\n**Explanation:** One choice of subarrays is \\[3,8,1\\] with length 3, and \\[8,9\\] with length 2.\n\n**Example 3:**\n\n**Input:** nums = \\[2,1,5,6,0,9,5,0,3,8\\], firstLen = 4, secondLen = 3\n**Output:** 31\n**Explanation:** One choice of subarrays is \\[5,6,0,9\\] with length 4, and \\[0,3,8\\] with length 3.\n\n**Constraints:**\n\n*   `1 <= firstLen, secondLen <= 1000`\n*   `2 <= firstLen + secondLen <= 1000`\n*   `firstLen + secondLen <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`",
          "output": "def add_to_array_form(num, k):\n    for i in range(len(num) - 1, -1, -1):\n        k, num[i] = divmod(num[i] + k, 10)\n        if k == 0:\n            break\n    while k:\n        k, digit = divmod(k, 10)\n        num.insert(0, digit)\n    return num\n"
     },
     {
          "instruction": "You are given two integer arrays `nums1` and `nums2`. We write the integers of `nums1` and `nums2` (in the order they are given) on two separate horizontal lines.\n\nWe may draw connecting lines: a straight line connecting two numbers `nums1[i]` and `nums2[j]` such that:\n\n*   `nums1[i] == nums2[j]`, and\n*   the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\nReturn _the maximum number of connecting lines we can draw in this way_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[1,4,2\\], nums2 = \\[1,2,4\\]\n**Output:** 2\n**Explanation:** We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1\\[1\\] = 4 to nums2\\[2\\] = 4 will intersect the line from nums1\\[2\\]=2 to nums2\\[1\\]=2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[2,5,1,2,5\\], nums2 = \\[10,5,2,1,5,2\\]\n**Output:** 3\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,3,7,1,7,5\\], nums2 = \\[1,9,2,5,1\\]\n**Output:** 2\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `1 <= nums1[i], nums2[j] <= 2000`",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isCousins(self, root, x, y):\n        def findDepth(node, search_val, depth):\n            if not node:\n                return -1\n            if node.val == search_val:\n                return depth\n            left_depth = findDepth(node.left, search_val, depth + 1)\n            if left_depth != -1:\n                return left_depth\n            return findDepth(node.right, search_val, depth + 1)\n\n        def findParent(node, search_val):\n            if not node or not (node.left or node.right):\n                return None\n            if (node.left and node.left.val == search_val) or (node.right and node.right.val == search_val):\n                return node\n            left_parent = findParent(node.left, search_val)\n            if left_parent:\n                return left_parent\n            return findParent(node.right, search_val)\n\n        x_depth = findDepth(root, x, 0)\n        y_depth = findDepth(root, y, 0)\n        x_parent = findParent(root, x)\n        y_parent = findParent(root, y)\n        return (x_depth == y_depth) and (x_parent != y_parent)\n"
     },
     {
          "instruction": "You have a convex `n`\\-sided polygon where each vertex has an integer value. You are given an integer array `values` where `values[i]` is the value of the `ith` vertex (i.e., **clockwise order**).\n\nYou will **triangulate** the polygon into `n - 2` triangles. For each triangle, the value of that triangle is the product of the values of its vertices, and the total score of the triangulation is the sum of these values over all `n - 2` triangles in the triangulation.\n\nReturn _the smallest possible total score that you can achieve with some triangulation of the polygon_.\n\n",
          "input": "**Example 1:**\n\n**Input:** values = \\[1,2,3\\]\n**Output:** 6\n**Explanation:** The polygon is already triangulated, and the score of the only triangle is 6.\n\n**Example 2:**\n\n**Input:** values = \\[3,7,4,5\\]\n**Output:** 144\n**Explanation:** There are two triangulations, with possible scores: 3\\*7\\*5 + 4\\*5\\*7 = 245, or 3\\*4\\*5 + 3\\*4\\*7 = 144.\nThe minimum score is 144.\n\n**Example 3:**\n\n**Input:** values = \\[1,3,1,4,1,5\\]\n**Output:** 13\n**Explanation:** The minimum score triangulation has score 1\\*1\\*3 + 1\\*1\\*4 + 1\\*1\\*5 + 1\\*1\\*1 = 13.\n\n**Constraints:**\n\n*   `n == values.length`\n*   `3 <= n <= 50`\n*   `1 <= values[i] <= 100`",
          "output": "def find_judge(n, trust):\n    trustCounts = [0] * (n + 1)\n    for a, b in trust:\n        trustCounts[a] -= 1\n        trustCounts[b] += 1\n\n    for i in range(1, n + 1):\n        if trustCounts[i] == n - 1:\n            return i\n    return -1\n"
     },
     {
          "instruction": "Given an `n x n` `grid` containing only values `0` and `1`, where `0` represents water and `1` represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return `-1`.\n\nThe distance used in this problem is the Manhattan distance: the distance between two cells `(x0, y0)` and `(x1, y1)` is `|x0 - x1| + |y0 - y1|`.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,1\\],\\[0,0,0\\],\\[1,0,1\\]\\]\n**Output:** 2\n**Explanation:** The cell (1, 1) is as far as possible from all the land with distance 2.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Output:** 4\n**Explanation:** The cell (2, 2) is as far as possible from all the land with distance 4.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 100`\n*   `grid[i][j]` is `0` or `1`",
          "output": "from collections import deque\n\ndef maxDistance(grid):\n    distance = -1\n    water_cells = deque()\n    n = len(grid)\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                water_cells.append((i, j))\n\n    if not water_cells or len(water_cells) == n * n:\n        return distance\n\n    directions = ((0, 1), (0, -1), (1, 0), (-1, 0))\n\n    while water_cells:\n        size = len(water_cells)\n        for _ in range(size):\n            x, y = water_cells.popleft()\n            for dx, dy in directions:\n                newX, newY = x + dx, y + dy\n                if 0 <= newX < n and 0 <= newY < n and grid[newX][newY] == 0:\n                    grid[newX][newY] = 1\n                    water_cells.append((newX, newY))\n        distance += 1\n        \n    return distance - 1\n"
     },
     {
          "instruction": "Given an integer array `arr`, partition the array into (contiguous) subarrays of length **at most** `k`. After partitioning, each subarray has their values changed to become the maximum value of that subarray.\n\nReturn _the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a **32-bit** integer._\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,15,7,9,2,5,10\\], k = 3\n**Output:** 84\n**Explanation:** arr becomes \\[15,15,15,9,10,10,10\\]\n\n**Example 2:**\n\n**Input:** arr = \\[1,4,1,5,7,3,6,1,9,9,3\\], k = 4\n**Output:** 83\n\n**Example 3:**\n\n**Input:** arr = \\[1\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= arr.length <= 500`\n*   `0 <= arr[i] <= 109`\n*   `1 <= k <= arr.length`",
          "output": "def grid_illumination(n, lamps, queries):\n    lamp_rows = set()\n    lamp_cols = set()\n    lamp_left_diag = set()\n    lamp_right_diag = set()\n\n    for lamp in lamps:\n        row, col = lamp\n        lamp_rows.add(row)\n        lamp_cols.add(col)\n        lamp_left_diag.add(row - col)\n        lamp_right_diag.add(row + col)\n\n    ans = []\n\n    for query in queries:\n        row, col = query\n        if row in lamp_rows or col in lamp_cols or (row - col) in lamp_left_diag or (row + col) in lamp_right_diag:\n            ans.append(1)\n        else:\n            ans.append(0)\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                newRow, newCol = row + i, col + j\n                lamp_rows.discard(newRow)\n                lamp_cols.discard(newCol)\n                lamp_left_diag.discard(newRow - newCol)\n                lamp_right_diag.discard(newRow + newCol)\n\n    return ans\n"
     },
     {
          "instruction": "You are given an array of `words` where each word consists of lowercase English letters.\n\n`wordA` is a **predecessor** of `wordB` if and only if we can insert **exactly one** letter anywhere in `wordA` **without changing the order of the other characters** to make it equal to `wordB`.\n\n*   For example, `\"abc \"` is a **predecessor** of `\"abac \"`, while `\"cba \"` is not a **predecessor** of `\"bcad \"`.\n\nA **word chain** is a sequence of words `[word1, word2, ..., wordk]` with `k >= 1`, where `word1` is a **predecessor** of `word2`, `word2` is a **predecessor** of `word3`, and so on. A single word is trivially a **word chain** with `k == 1`.\n\nReturn _the **length** of the **longest possible word chain** with words chosen from the given list of_ `words`.\n\n",
          "input": "**Example 1:**\n\n**Input:** words = \\[ \"a \", \"b \", \"ba \", \"bca \", \"bda \", \"bdca \"\\]\n**Output:** 4\n**Explanation**: One of the longest word chains is \\[ \"a \", \"ba \", \"bda \", \"bdca \"\\].\n\n**Example 2:**\n\n**Input:** words = \\[ \"xbc \", \"pcxbcf \", \"xb \", \"cxbc \", \"pcxbc \"\\]\n**Output:** 5\n**Explanation:** All the words can be put in a word chain \\[ \"xb \",  \"xbc \",  \"cxbc \",  \"pcxbc \",  \"pcxbcf \"\\].\n\n**Example 3:**\n\n**Input:** words = \\[ \"abcd \", \"dbqca \"\\]\n**Output:** 1\n**Explanation:** The trivial word chain \\[ \"abcd \"\\] is one of the longest word chains.\n\\[ \"abcd \", \"dbqca \"\\] is not a valid word chain because the ordering of the letters is changed.\n\n**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 16`\n*   `words[i]` only consists of lowercase English letters.",
          "output": "def clumsy(n: int) -> int:\n    if n <= 2:\n        return n\n    if n == 3:\n        return 6\n    result = n * (n - 1) // (n - 2) + (n - 3)\n    n -= 4\n    while n >= 4:\n        result = result - (n * (n - 1) // (n - 2)) + (n - 3)\n        n -= 4\n    return result - clumsy(n)\n"
     },
     {
          "instruction": "You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the smallest possible weight of the left stone_. If there are no stones left, return `0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:**\nWe can combine 2 and 4 to get 2, so the array converts to \\[2,7,1,8,1\\] then,\nwe can combine 7 and 8 to get 1, so the array converts to \\[2,1,1,1\\] then,\nwe can combine 2 and 1 to get 1, so the array converts to \\[1,1,1\\] then,\nwe can combine 1 and 1 to get 0, so the array converts to \\[1\\], then that's the optimal value.\n\n**Example 2:**\n\n**Input:** stones = \\[31,26,33,21,40\\]\n**Output:** 5\n\n**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 100`",
          "output": "def min_rotations(tops, bottoms):\n    res = float('inf')\n\n    for target in (tops[0], bottoms[0]):\n        top_rot, bot_rot = 0, 0\n        for ti, bi in zip(tops, bottoms):\n            if ti != target and bi != target:\n                top_rot = bot_rot = float('inf')\n                break\n            top_rot += ti != target\n            bot_rot += bi != target\n\n        res = min(res, top_rot, bot_rot)\n\n    return -1 if res == float('inf') else res\n"
     },
     {
          "instruction": "You are given an array `colors`, in which there are three colors: `1`, `2` and `3`.\n\nYou are also given some queries. Each query consists of two integers `i` and `c`, return the shortest distance between the given index `i` and the target color `c`. If there is no solution return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** colors = \\[1,1,2,1,3,2,2,3,3\\], queries = \\[\\[1,3\\],\\[2,2\\],\\[6,1\\]\\]\n**Output:** \\[3,0,3\\]\n**Explanation:** \nThe nearest 3 from index 1 is at index 4 (3 steps away).\nThe nearest 2 from index 2 is at index 2 itself (0 steps away).\nThe nearest 1 from index 6 is at index 3 (3 steps away).\n\n**Example 2:**\n\n**Input:** colors = \\[1,2\\], queries = \\[\\[0,3\\]\\]\n**Output:** \\[-1\\]\n**Explanation:** There is no 3 in the array.\n\n**Constraints:**\n\n*   `1 <= colors.length <= 5*10^4`\n*   `1 <= colors[i] <= 3`\n*   `1 <= queries.length <= 5*10^4`\n*   `queries[i].length == 2`\n*   `0 <= queries[i][0] < colors.length`\n*   `1 <= queries[i][1] <= 3`",
          "output": "def shortestDistance(colors, queries):\n    result = []\n    positions = [[] for _ in range(3)]\n\n    for i, color in enumerate(colors):\n        positions[color - 1].append(i)\n\n    for query in queries:\n        index_positions = positions[query[1] - 1]\n\n        if not index_positions:\n            result.append(-1)\n        else:\n            dist = float('inf')\n\n            for pos in index_positions:\n                dist = min(dist, abs(pos - query[0]))\n\n            result.append(dist)\n\n    return result\n"
     },
     {
          "instruction": "You have some coins. The `i`\\-th coin has a probability `prob[i]` of facing heads when tossed.\n\nReturn the probability that the number of coins facing heads equals `target` if you toss every coin exactly once.\n\n",
          "input": "**Example 1:**\n\n**Input:** prob = \\[0.4\\], target = 1\n**Output:** 0.40000\n\n**Example 2:**\n\n**Input:** prob = \\[0.5,0.5,0.5,0.5,0.5\\], target = 0\n**Output:** 0.03125\n\n**Constraints:**\n\n*   `1 <= prob.length <= 1000`\n*   `0 <= prob[i] <= 1`\n*   `0 <= target` `<= prob.length`\n*   Answers will be accepted as correct if they are within `10^-5` of the correct answer.",
          "output": "def max_value(arr1, arr2):\n    n = len(arr1)\n    max1 = max2 = max3 = max4 = float('-inf')\n    min1 = min2 = min3 = min4 = float('inf')\n\n    for i in range(n):\n        max1 = max(max1, arr1[i] - arr2[i] + i)\n        max2 = max(max2, arr1[i] + arr2[i] + i)\n        max3 = max(max3, -arr1[i] + arr2[i] + i)\n        max4 = max(max4, -arr1[i] - arr2[i] + i)\n\n        min1 = min(min1, arr1[i] - arr2[i] + i)\n        min2 = min(min2, arr1[i] + arr2[i] + i)\n        min3 = min(min3, -arr1[i] + arr2[i] + i)\n        min4 = min(min4, -arr1[i] - arr2[i] + i)\n\n    return max(max1 - min1, max2 - min2, max3 - min3, max4 - min4)\n"
     },
     {
          "instruction": "Given two strings `str1` and `str2`, return _the shortest string that has both_ `str1` _and_ `str2` _as **subsequences**_. If there are multiple valid strings, return **any** of them.\n\nA string `s` is a **subsequence** of string `t` if deleting some number of characters from `t` (possibly `0`) results in the string `s`.\n\n",
          "input": "**Example 1:**\n\n**Input:** str1 =  \"abac \", str2 =  \"cab \"\n**Output:**  \"cabac \"\n**Explanation:** \nstr1 =  \"abac \" is a subsequence of  \"cabac \" because we can delete the first  \"c \".\nstr2 =  \"cab \" is a subsequence of  \"cabac \" because we can delete the last  \"ac \".\nThe answer provided is the shortest such string that satisfies these properties.\n\n**Example 2:**\n\n**Input:** str1 =  \"aaaaaaaa \", str2 =  \"aaaaaaaa \"\n**Output:**  \"aaaaaaaa \"\n\n**Constraints:**\n\n*   `1 <= str1.length, str2.length <= 1000`\n*   `str1` and `str2` consist of lowercase English letters.",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef dfs(node):\n    if not node:\n        return 0, float('inf'), float('-inf')\n    left_diff, left_min, left_max = dfs(node.left)\n    right_diff, right_min, right_max = dfs(node.right)\n    mn = min(node.val, left_min, right_min)\n    mx = max(node.val, left_max, right_max)\n    return max(max(left_diff, right_diff), max(abs(node.val - left_min), abs(node.val - right_max))), mn, mx\n\ndef maxAncestorDiff(root):\n    diff, _, _ = dfs(root)\n    return diff\n"
     },
     {
          "instruction": "Given a string `s` and an integer `k`, return `true` if `s` is a `k`**\\-palindrome**.\n\nA string is `k`**\\-palindrome** if it can be transformed into a palindrome by removing at most `k` characters from it.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"abcdeca \", k = 2\n**Output:** true\n**Explanation:** Remove 'b' and 'e' characters.\n\n**Example 2:**\n\n**Input:** s =  \"abbababa \", k = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= s.length`",
          "output": "from threading import Lock\n\nclass ZeroEvenOdd:\n    def __init__(self, n):\n        self.n = n\n        self.cnt = 1\n        self.lock = Lock()\n\n    def zero(self, printNumber):\n        for i in range(1, self.n + 1):\n            with self.lock:\n                while self.cnt % 2 == 0:\n                    self.lock.wait()\n                printNumber(0)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def even(self, printNumber):\n        for i in range(2, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n\n    def odd(self, printNumber):\n        for i in range(1, self.n + 1, 2):\n            with self.lock:\n                while self.cnt != 2 * i - 1:\n                    self.lock.wait()\n                printNumber(i)\n                self.cnt += 1\n                self.lock.notify_all()\n"
     },
     {
          "instruction": "You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.\n\nNote that at each step of the above process, the order of the books we place is the same order as the given sequence of books.\n\n*   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.\n\n",
          "input": "**Example 1:**\n\n**Input:** books = \\[\\[1,1\\],\\[2,3\\],\\[2,3\\],\\[1,1\\],\\[1,1\\],\\[1,1\\],\\[1,2\\]\\], shelfWidth = 4\n**Output:** 6\n**Explanation:**\nThe sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\nNotice that book number 2 does not have to be on the first shelf.\n\n**Example 2:**\n\n**Input:** books = \\[\\[1,3\\],\\[2,4\\],\\[3,2\\]\\], shelfWidth = 6\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= books.length <= 1000`\n*   `1 <= thicknessi <= shelfWidth <= 1000`\n*   `1 <= heighti <= 1000`",
          "output": "def max_uncrossed_lines(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n"
     },
     {
          "instruction": "You are given an integer array `arr`.\n\nIn one move, you can select a **palindromic** subarray `arr[i], arr[i + 1], ..., arr[j]` where `i <= j`, and remove that subarray from the given array. Note that after removing a subarray, the elements on the left and on the right of that subarray move to fill the gap left by the removal.\n\nReturn _the minimum number of moves needed to remove all numbers from the array_.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,2\\]\n**Output:** 2\n\n**Example 2:**\n\n**Input:** arr = \\[1,3,4,1,5\\]\n**Output:** 3\n**Explanation:** Remove \\[4\\] then remove \\[1,3,1\\] then remove \\[5\\].\n\n**Constraints:**\n\n*   `1 <= arr.length <= 100`\n*   `1 <= arr[i] <= 20`",
          "output": "def minimumMoves(arr):\n    def minRemovals(i, j):\n        if i > j:\n            return 0\n        if i == j:\n            return 1\n        if dp[i][j] != -1:\n            return dp[i][j]\n\n        ans = minRemovals(i + 1, j) + 1\n        for k in range(i + 1, j + 1):\n            if arr[i] == arr[k]:\n                ans = min(ans, minRemovals(i + 1, k - 1) + minRemovals(k + 1, j))\n        dp[i][j] = ans\n        return ans\n\n    dp = [[-1] * len(arr) for _ in range(len(arr))]\n    return minRemovals(0, len(arr) - 1)\n"
     },
     {
          "instruction": "You are given an **even** number of people `numPeople` that stand around a circle and each person shakes hands with someone else so that there are `numPeople / 2` handshakes total.\n\nReturn _the number of ways these handshakes could occur such that none of the handshakes cross_.\n\nSince the answer could be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** numPeople = 4\n**Output:** 2\n**Explanation:** There are two ways to do it, the first way is \\[(1,2),(3,4)\\] and the second one is \\[(2,3),(4,1)\\].\n\n**Example 2:**\n\n**Input:** numPeople = 6\n**Output:** 5\n\n**Constraints:**\n\n*   `2 <= numPeople <= 1000`\n*   `numPeople` is even.",
          "output": "def numberOfWays(numPeople: int) -> int:\n    MOD = 1000000007\n    dp = [0] * (numPeople // 2 + 1)\n    dp[0] = 1\n    for i in range(1, numPeople // 2 + 1):\n        for j in range(1, i + 1):\n            dp[i] = (dp[i] + dp[i - j] * dp[j - 1]) % MOD\n    return dp[numPeople // 2]\n"
     },
     {
          "instruction": "In a project, you have a list of required skills `req_skills`, and a list of people. The `ith` person `people[i]` contains a list of skills that the person has.\n\nConsider a sufficient team: a set of people such that for every required skill in `req_skills`, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n\n*   For example, `team = [0, 1, 3]` represents the people with skills `people[0]`, `people[1]`, and `people[3]`.\n\nReturn _any sufficient team of the smallest possible size, represented by the index of each person_. You may return the answer in **any order**.\n\nIt is **guaranteed** an answer exists.\n\n",
          "input": "**Example 1:**\n\n**Input:** req\\_skills = \\[\"java\",\"nodejs\",\"reactjs\"\\], people = \\[\\[\"java\"\\],\\[\"nodejs\"\\],\\[\"nodejs\",\"reactjs\"\\]\\]\n**Output:** \\[0,2\\]\n\n**Example 2:**\n\n**Input:** req\\_skills = \\[\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"\\], people = \\[\\[\"algorithms\",\"math\",\"java\"\\],\\[\"algorithms\",\"math\",\"reactjs\"\\],\\[\"java\",\"csharp\",\"aws\"\\],\\[\"reactjs\",\"csharp\"\\],\\[\"csharp\",\"math\"\\],\\[\"aws\",\"java\"\\]\\]\n**Output:** \\[1,2\\]\n\n**Constraints:**\n\n*   `1 <= req_skills.length <= 16`\n*   `1 <= req_skills[i].length <= 16`\n*   `req_skills[i]` consists of lowercase English letters.\n*   All the strings of `req_skills` are **unique**.\n*   `1 <= people.length <= 60`\n*   `0 <= people[i].length <= 16`\n*   `1 <= people[i][j].length <= 16`\n*   `people[i][j]` consists of lowercase English letters.\n*   All the strings of `people[i]` are **unique**.\n*   Every skill in `people[i]` is a skill in `req_skills`.\n*   It is guaranteed a sufficient team exists.",
          "output": "from collections import defaultdict\nfrom math import log2\n\ndef smallestSufficientTeam(req_skills, people):\n    skill_to_id = {skill: idx for idx, skill in enumerate(req_skills)}\n\n    n, m = len(people), len(req_skills)\n    dp = [float(\"inf\")] * (1 << m)\n    pre = [0] * (1 << m)\n    skill_set = [0] * (1 << m)\n\n    dp[0] = 0\n\n    for i, skills in enumerate(people):\n        skill_mask = sum(1 << skill_to_id[skill] for skill in skills)\n        for j in range((1 << m) - 1, -1, -1):\n            if dp[j | skill_mask] > dp[j] + 1:\n                dp[j | skill_mask] = dp[j] + 1\n                pre[j | skill_mask] = j\n                skill_set[j | skill_mask] = i\n\n    res = []\n    mask = (1 << m) - 1\n    while mask:\n        res.append(skill_set[mask])\n        mask = pre[mask]\n\n    return res\n"
     },
     {
          "instruction": "Given an `n x n` integer matrix `grid`, return _the minimum sum of a **falling path with non-zero shifts**_.\n\nA **falling path with non-zero shifts** is a choice of exactly one element from each row of `grid` such that no two elements chosen in adjacent rows are in the same column.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** 13\n**Explanation:** \nThe possible falling paths are:\n\\[1,5,9\\], \\[1,5,7\\], \\[1,6,7\\], \\[1,6,8\\],\n\\[2,4,8\\], \\[2,4,9\\], \\[2,6,7\\], \\[2,6,8\\],\n\\[3,4,8\\], \\[3,4,9\\], \\[3,5,7\\], \\[3,5,9\\]\nThe falling path with the smallest sum is \\[1,5,7\\], so the answer is 13.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[7\\]\\]\n**Output:** 7\n\n**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 200`\n*   `-99 <= grid[i][j] <= 99`",
          "output": "def day_of_the_week(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    if month < 3:\n        month += 12\n        year -= 1\n    k = year % 100\n    j = year // 100\n    day_of_week = (day + 13 * (month + 1) // 5 + k + k // 4 + 5 * j + j // 4) % 7\n    return days[day_of_week]\n"
     },
     {
          "instruction": "Given an array `arr` of positive integers, consider all binary trees such that:\n\n*   Each node has either `0` or `2` children;\n*   The values of `arr` correspond to the values of each **leaf** in an in-order traversal of the tree.\n*   The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return _the smallest possible sum of the values of each non-leaf node_. It is guaranteed this sum fits into a **32-bit** integer.\n\nA node is a **leaf** if and only if it has zero children.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[6,2,4\\]\n**Output:** 32\n**Explanation:** There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\n**Example 2:**\n\n**Input:** arr = \\[4,11\\]\n**Output:** 44\n\n**Constraints:**\n\n*   `2 <= arr.length <= 40`\n*   `1 <= arr[i] <= 15`\n*   It is guaranteed that the answer fits into a **32-bit** signed integer (i.e., it is less than 231).",
          "output": "import heapq\n\ndef lastStoneWeight(stones):\n    stones = [-stone for stone in stones]\n    heapq.heapify(stones)\n    while len(stones) > 1:\n        y = -heapq.heappop(stones)\n        x = -heapq.heappop(stones)\n        if x != y:\n            heapq.heappush(stones, -(y - x))\n    return -stones[0] if stones else 0\n"
     },
     {
          "instruction": "You are given a square `board` of characters. You can move on the board starting at the bottom right square marked with the character `'S'`.\n\nYou need to reach the top left square marked with the character `'E'`. The rest of the squares are labeled either with a numeric character `1, 2, ..., 9` or with an obstacle `'X'`. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.\n\nReturn a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, **taken modulo `10^9 + 7`**.\n\nIn case there is no path, return `[0, 0]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** board = \\[\"E23\",\"2X2\",\"12S\"\\]\n**Output:** \\[7,1\\]\n\n**Example 2:**\n\n**Input:** board = \\[\"E12\",\"1X1\",\"21S\"\\]\n**Output:** \\[4,2\\]\n\n**Example 3:**\n\n**Input:** board = \\[\"E11\",\"XXX\",\"11S\"\\]\n**Output:** \\[0,0\\]\n\n**Constraints:**\n\n*   `2 <= board.length == board[i].length <= 100`",
          "output": "from typing import List\n\nMOD = 10**9 + 7\n\ndef pathsWithMaxScore(board: List[str]) -> List[int]:\n    n = len(board)\n    dp = [[0] * n for _ in range(n)]\n    cnt = [[0] * n for _ in range(n)]\n\n    board[0] = list(board[0])\n    board[0][0] = '0'\n    board[n-1] = list(board[n-1])\n    board[n-1][n-1] = '0'\n    cnt[n-1][n-1] = 1\n\n    for i in range(n-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            if board[i][j] != 'X':\n                neighbors = [(i-1, j), (i, j-1), (i-1, j-1)]\n                for x, y in neighbors:\n                    if x >= 0 and y >= 0:\n                        if dp[i][j] < dp[x][y] + int(board[i][j]):\n                            dp[i][j] = dp[x][y] + int(board[i][j])\n                            cnt[i][j] = cnt[x][y]\n                        elif dp[i][j] == dp[x][y] + int(board[i][j]):\n                            cnt[i][j] = (cnt[i][j] + cnt[x][y]) % MOD\n\n    return [dp[0][0], cnt[0][0]]\n"
     },
     {
          "instruction": "The Tribonacci sequence Tn is defined as follows:\n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 4\n**Output:** 4\n**Explanation:**\nT\\_3 = 0 + 1 + 1 = 2\nT\\_4 = 1 + 1 + 2 = 4\n\n**Example 2:**\n\n**Input:** n = 25\n**Output:** 1389537\n\n**Constraints:**\n\n*   `0 <= n <= 37`\n*   The answer is guaranteed to fit within a 32-bit integer, ie. `answer <= 2^31 - 1`.",
          "output": "def height_checker(heights):\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n    return count\n"
     },
     {
          "instruction": "Given a 2D `grid` of `0`s and `1`s, return the number of elements in the largest **square** subgrid that has all `1`s on its **border**, or `0` if such a subgrid doesn't exist in the `grid`.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 9\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,0,0\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= grid.length <= 100`\n*   `1 <= grid[0].length <= 100`\n*   `grid[i][j]` is `0` or `1`",
          "output": "def prev_perm_opt1(arr):\n    n = len(arr)\n    for i in range(n - 2, -1, -1):\n        if arr[i] > arr[i + 1]:\n            j = i + 1\n            while j < n and arr[j] < arr[i]:\n                j += 1\n            arr[i], arr[j - 1] = arr[j - 1], arr[i]\n            return arr\n    return arr\n"
     },
     {
          "instruction": "Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n",
          "input": "**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`",
          "output": "from heapq import heappush, heappop\n\ndef rearrange_barcodes(barcodes):\n    count = {}\n    for barcode in barcodes:\n        if barcode not in count:\n            count[barcode] = 0\n        count[barcode] += 1\n\n    pq = []\n    for key, value in count.items():\n        heappush(pq, (-value, key))\n\n    idx = 0\n    while pq:\n        curr = heappop(pq)\n        while curr[0] < 0:\n            barcodes[idx] = curr[1]\n            curr = (curr[0] + 1, curr[1])\n            idx += 2\n            if idx >= len(barcodes):\n                idx = 1\n    return barcodes\n"
     },
     {
          "instruction": "Given two strings `text1` and `text2`, return _the length of their longest **common subsequence**._ If there is no **common subsequence**, return `0`.\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n*   For example, `\"ace \"` is a subsequence of `\"abcde \"`.\n\nA **common subsequence** of two strings is a subsequence that is common to both strings.\n\n",
          "input": "**Example 1:**\n\n**Input:** text1 =  \"abcde \", text2 =  \"ace \" \n**Output:** 3  \n**Explanation:** The longest common subsequence is  \"ace \" and its length is 3.\n\n**Example 2:**\n\n**Input:** text1 =  \"abc \", text2 =  \"abc \"\n**Output:** 3\n**Explanation:** The longest common subsequence is  \"abc \" and its length is 3.\n\n**Example 3:**\n\n**Input:** text1 =  \"abc \", text2 =  \"def \"\n**Output:** 0\n**Explanation:** There is no such common subsequence, so the result is 0.\n\n**Constraints:**\n\n*   `1 <= text1.length, text2.length <= 1000`\n*   `text1` and `text2` consist of only lowercase English characters.",
          "output": "def longestCommonSubsequence(text1: str, text2: str) -> int:\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n"
     },
     {
          "instruction": "You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:\n\n*   `subtexti` is a **non-empty** string.\n*   The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).\n*   `subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).\n\nReturn the largest possible value of `k`.\n\n",
          "input": "**Example 1:**\n\n**Input:** text =  \"ghiabcdefhelloadamhelloabcdefghi \"\n**Output:** 7\n**Explanation:** We can split the string on  \"(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi) \".\n\n**Example 2:**\n\n**Input:** text =  \"merchant \"\n**Output:** 1\n**Explanation:** We can split the string on  \"(merchant) \".\n\n**Example 3:**\n\n**Input:** text =  \"antaprezatepzapreanta \"\n**Output:** 11\n**Explanation:** We can split the string on  \"(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a) \".\n\n**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists only of lowercase English characters.",
          "output": "from collections import defaultdict\n\ndef maxEqualRowsAfterFlips(matrix):\n    count = defaultdict(int)\n    for row in matrix:\n        row_str = \"\".join(str(row[0] ^ val) for val in row)\n        count[row_str] += 1\n    return max(count.values())\n"
     },
     {
          "instruction": "You have `n` dice, and each die has `k` faces numbered from `1` to `k`.\n\nGiven three integers `n`, `k`, and `target`, return _the number of possible ways (out of the_ `kn` _total ways)_ _to roll the dice, so the sum of the face-up numbers equals_ `target`. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1, k = 6, target = 3\n**Output:** 1\n**Explanation:** You throw one die with 6 faces.\nThere is only one way to get a sum of 3.\n\n**Example 2:**\n\n**Input:** n = 2, k = 6, target = 7\n**Output:** 6\n**Explanation:** You throw two dice, each with 6 faces.\nThere are 6 ways to get a sum of 7: 1+6, 2+5, 3+4, 4+3, 5+2, 6+1.\n\n**Example 3:**\n\n**Input:** n = 30, k = 30, target = 500\n**Output:** 222616187\n**Explanation:** The answer must be returned modulo 109 + 7.\n\n**Constraints:**\n\n*   `1 <= n, k <= 30`\n*   `1 <= target <= 1000`",
          "output": "def numRollsToTarget(n, k, target):\n    MOD = 1000000007\n    dp = [[0 for _ in range(target + 1)] for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, target + 1):\n            for d in range(1, k + 1):\n                if j - d >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD\n    return dp[n][target]\n"
     },
     {
          "instruction": "Given an array of digits `digits`, return _the largest multiple of **three** that can be formed by concatenating some of the given digits in **any order**_. If there is no answer return an empty string.\n\nSince the answer may not fit in an integer data type, return the answer as a string. Note that the returning answer must not contain unnecessary leading zeros.\n\n",
          "input": "**Example 1:**\n\n**Input:** digits = \\[8,1,9\\]\n**Output:**  \"981 \"\n\n**Example 2:**\n\n**Input:** digits = \\[8,6,7,1,0\\]\n**Output:**  \"8760 \"\n\n**Example 3:**\n\n**Input:** digits = \\[1\\]\n**Output:**  \" \"\n\n**Constraints:**\n\n*   `1 <= digits.length <= 104`\n*   `0 <= digits[i] <= 9`",
          "output": "from collections import defaultdict\n\ndef largest_multiple_of_three(digits):\n    digits.sort(reverse=True)\n    sum_digits = sum(digits)\n\n    if sum_digits % 3 == 0:\n        return '0' if digits[-1] == 0 else ''.join(map(str, digits))\n\n    mod = defaultdict(list)\n    for digit in digits:\n        mod[digit % 3].append(digit)\n\n    if sum_digits % 3 == 1:\n        if mod[1]:\n            mod[1].pop()\n        else:\n            mod[2].pop(), mod[2].pop()\n    else:\n        if mod[2]:\n            mod[2].pop()\n        else:\n            mod[1].pop(), mod[1].pop()\n\n    result = \"\".join(str(digit) for value in mod.values() for digit in value)\n    result = \"\".join(sorted(result, reverse=True))\n\n    return '0' if not result or result[0] == '0' else result\n"
     },
     {
          "instruction": "Given an integer array `nums` and an integer `k`, return the maximum sum of a **non-empty** subsequence of that array such that for every two **consecutive** integers in the subsequence, `nums[i]` and `nums[j]`, where `i < j`, the condition `j - i <= k` is satisfied.\n\nA _subsequence_ of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[10,2,-10,5,20\\], k = 2\n**Output:** 37\n**Explanation:** The subsequence is \\[10, 2, 5, 20\\].\n\n**Example 2:**\n\n**Input:** nums = \\[-1,-2,-3\\], k = 1\n**Output:** -1\n**Explanation:** The subsequence must be non-empty, so we choose the largest number.\n\n**Example 3:**\n\n**Input:** nums = \\[10,-2,-10,-5,20\\], k = 2\n**Output:** 23\n**Explanation:** The subsequence is \\[10, -2, -5, 20\\].\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
          "output": "def maxSum(nums, k):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    pq = []\n    sum_ = 0\n\n    for i in range(n):\n        if i >= k:\n            pq.remove(-(dp[i] - nums[i]))  # Remove element from pq\n        heapq.heappush(pq, -(dp[i] - nums[i]))  # Push in the negative for max heap\n        dp[i + 1] = max(dp[i], nums[i] - pq[0])\n        sum_ = max(sum_, dp[i + 1])\n\n    return sum_\n"
     },
     {
          "instruction": "Given an array of integers, return the maximum sum for a **non-empty** subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.\n\nNote that the subarray needs to be **non-empty** after deleting one element.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,-2,0,3\\]\n**Output:** 4\n**Explanation:** Because we can choose \\[1, -2, 0, 3\\] and drop -2, thus the subarray \\[1, 0, 3\\] becomes the maximum value.\n\n**Example 2:**\n\n**Input:** arr = \\[1,-2,-2,3\\]\n**Output:** 3\n**Explanation:** We just choose \\[3\\] and it's the maximum sum.\n\n**Example 3:**\n\n**Input:** arr = \\[-1,-1,-1,-1\\]\n**Output:** -1\n**Explanation:** The final subarray needs to be non-empty. You can't choose \\[-1\\] and delete -1 from it, then get an empty subarray to make the sum equals to 0.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `-104 <= arr[i] <= 104`",
          "output": "from threading import Semaphore\n\nclass H2O:\n    def __init__(self):\n        self.hydrogenSemaphore = Semaphore(2)\n        self.oxygenSemaphore = Semaphore(1)\n\n    def hydrogen(self, releaseHydrogen):\n        self.hydrogenSemaphore.acquire()\n        releaseHydrogen()\n        self.oxygenSemaphore.release()\n\n    def oxygen(self, releaseOxygen):\n        self.oxygenSemaphore.acquire()\n        releaseOxygen()\n        self.hydrogenSemaphore.release(2)\n"
     },
     {
          "instruction": "Given two integer arrays `arr1` and `arr2`, return the minimum number of operations (possibly zero) needed to make `arr1` strictly increasing.\n\nIn one operation, you can choose two indices `0 <= i < arr1.length` and `0 <= j < arr2.length` and do the assignment `arr1[i] = arr2[j]`.\n\nIf there is no way to make `arr1` strictly increasing, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[1,3,2,4\\]\n**Output:** 1\n**Explanation:** Replace `5` with `2`, then `arr1 = [1, 2, 3, 6, 7]`.\n\n**Example 2:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[4,3,1\\]\n**Output:** 2\n**Explanation:** Replace `5` with `3` and then replace `3` with `4`. `arr1 = [1, 3, 4, 6, 7]`.\n\n**Example 3:**\n\n**Input:** arr1 = \\[1,5,3,6,7\\], arr2 = \\[1,6,3,3\\]\n**Output:** -1\n**Explanation:** You can't make `arr1` strictly increasing.\n\n**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 2000`\n*   `0 <= arr1[i], arr2[i] <= 10^9`",
          "output": "from threading import Lock\n\nclass FooBar:\n    def __init__(self, n: int):\n        self.n = n\n        self.foo_lock = Lock()\n        self.bar_lock = Lock()\n        self.bar_lock.acquire()\n\n    def foo(self, printFoo) -> None:\n        for _ in range(self.n):\n            self.foo_lock.acquire()\n            printFoo()\n            self.bar_lock.release()\n\n    def bar(self, printBar) -> None:\n        for _ in range(self.n):\n            self.bar_lock.acquire()\n            printBar()\n            self.foo_lock.release()\n"
     },
     {
          "instruction": "You are given a tree with `n` nodes numbered from `0` to `n - 1` in the form of a parent array `parent` where `parent[i]` is the parent of `ith` node. The root of the tree is node `0`. Find the `kth` ancestor of a given node.\n\nThe `kth` ancestor of a tree node is the `kth` node in the path from that node to the root node.\n\nImplement the `TreeAncestor` class:\n\n*   `TreeAncestor(int n, int[] parent)` Initializes the object with the number of nodes in the tree and the parent array.\n*   `int getKthAncestor(int node, int k)` return the `kth` ancestor of the given node `node`. If there is no such ancestor, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input**\n\\[ \"TreeAncestor \",  \"getKthAncestor \",  \"getKthAncestor \",  \"getKthAncestor \"\\]\n\\[\\[7, \\[-1, 0, 0, 1, 1, 2, 2\\]\\], \\[3, 1\\], \\[5, 2\\], \\[6, 3\\]\\]\n**Output**\n\\[null, 1, 0, -1\\]\n\n**Explanation**\nTreeAncestor treeAncestor = new TreeAncestor(7, \\[-1, 0, 0, 1, 1, 2, 2\\]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor\n\n**Constraints:**\n\n*   `1 <= k <= n <= 5 * 104`\n*   `parent.length == n`\n*   `parent[0] == -1`\n*   `0 <= parent[i] < n` for all `0 < i < n`\n*   `0 <= node < n`\n*   There will be at most `5 * 104` queries.",
          "output": "def rank_teams(votes):\n    teams = len(votes[0])\n    ranks = [[0] * teams for _ in range(26)]\n\n    for vote in votes:\n        for i in range(teams):\n            ranks[ord(vote[i]) - ord('A')][i] += 1\n\n    result = list(votes[0])\n    result.sort(key=lambda ch: tuple([-ranks[ord(ch) - ord('A')][i] for i in range(teams)] + [ch]))\n    return ''.join(result)\n"
     },
     {
          "instruction": "Given an integer array `arr` and an integer `k`, modify the array by repeating it `k` times.\n\nFor example, if `arr = [1, 2]` and `k = 3` then the modified array will be `[1, 2, 1, 2, 1, 2]`.\n\nReturn the maximum sub-array sum in the modified array. Note that the length of the sub-array can be `0` and its sum in that case is `0`.\n\nAs the answer can be very large, return the answer **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,2\\], k = 3\n**Output:** 9\n\n**Example 2:**\n\n**Input:** arr = \\[1,-2,1\\], k = 5\n**Output:** 2\n\n**Example 3:**\n\n**Input:** arr = \\[-1,-2\\], k = 7\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= k <= 105`\n*   `-104 <= arr[i] <= 104`",
          "output": "def kConcatenationMaxSum(arr, k):\n    mod = 10**9 + 7\n    n = len(arr)\n    max_sum, max_left, max_right = 0, 0, 0\n    total_sum = sum(arr)\n    temp_sum = 0\n\n    for i in range(n):\n        temp_sum += arr[i]\n        max_sum = max(max_sum, temp_sum)\n        temp_sum = max(0, temp_sum)\n        max_left = max(max_left, temp_sum)\n\n    temp = total_sum\n    for i in range(n - 1, -1, -1):\n        temp -= arr[i]\n        max_right = max(max_right, temp)\n\n    ans = max(max_sum, max_left + max_right + total_sum * (k - 2), 0)\n    return ans % mod\n"
     },
     {
          "instruction": "You are an ant tasked with adding `n` new rooms numbered `0` to `n-1` to your colony. You are given the expansion plan as a **0-indexed** integer array of length `n`, `prevRoom`, where `prevRoom[i]` indicates that you must build room `prevRoom[i]` before building room `i`, and these two rooms must be connected **directly**. Room `0` is already built, so `prevRoom[0] = -1`. The expansion plan is given such that once all the rooms are built, every room will be reachable from room `0`.\n\nYou can only build **one room** at a time, and you can travel freely between rooms you have **already built** only if they are **connected**. You can choose to build **any room** as long as its **previous room** is already built.\n\nReturn _the **number of different orders** you can build all the rooms in_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** prevRoom = \\[-1,0,1\\]\n**Output:** 1\n**Explanation:** There is only one way to build the additional rooms: 0 -> 1 -> 2\n\n**Example 2:**\n\n**Input:** prevRoom = \\[-1,0,0,1,2\\]\n**Output:** 6\n**Explanation:**\nThe 6 ways are:\n0 -> 1 -> 3 -> 2 -> 4\n0 -> 2 -> 4 -> 1 -> 3\n0 -> 1 -> 2 -> 3 -> 4\n0 -> 1 -> 2 -> 4 -> 3\n0 -> 2 -> 1 -> 3 -> 4\n0 -> 2 -> 1 -> 4 -> 3\n\n**Constraints:**\n\n*   `n == prevRoom.length`\n*   `2 <= n <= 105`\n*   `prevRoom[0] == -1`\n*   `0 <= prevRoom[i] < n` for all `1 <= i < n`\n*   Every room is reachable from room `0` once all the rooms are built.",
          "output": "def findCenter(edges):\n    if edges[0][0] == edges[1][0] or edges[0][0] == edges[1][1]:\n        return edges[0][0]\n    return edges[0][1]\n"
     },
     {
          "instruction": "You have a 2-D `grid` of size `m x n` representing a box, and you have `n` balls. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left.\n\n*   A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`.\n*   A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V \" shaped pattern between two boards or if a board redirects the ball into either wall of the box.\n\nReturn _an array_ `answer` _of size_ `n` _where_ `answer[i]` _is the column that the ball falls out of at the bottom after dropping the ball from the_ `ith` _column at the top, or `-1` _if the ball gets stuck in the box_._\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[1,1,1,-1,-1\\],\\[1,1,1,-1,-1\\],\\[-1,-1,-1,1,1\\],\\[1,1,1,1,-1\\],\\[-1,-1,-1,-1,-1\\]\\]\n**Output:** \\[1,-1,-1,-1,-1\\]\n**Explanation:** This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[-1\\]\\]\n**Output:** \\[-1\\]\n**Explanation:** The ball gets stuck against the left wall.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,1,1\\],\\[-1,-1,-1,-1,-1,-1\\],\\[1,1,1,1,1,1\\],\\[-1,-1,-1,-1,-1,-1\\]\\]\n**Output:** \\[0,1,2,3,4,-1\\]\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 100`\n*   `grid[i][j]` is `1` or `-1`.",
          "output": "def minCostConnectPoints(points):\n    n = len(points)\n    cost = [float('inf')] * n\n    visited = [False] * n\n    cost[0] = 0\n\n    ans = 0\n\n    for _ in range(n):\n        min_cost = float('inf')\n        cur_point = -1\n        for j in range(n):\n            if not visited[j] and cost[j] < min_cost:\n                min_cost = cost[j]\n                cur_point = j\n\n        visited[cur_point] = True\n        ans += min_cost\n\n        for j in range(n):\n            if not visited[j]:\n                new_cost = abs(points[cur_point][0] - points[j][0]) + abs(points[cur_point][1] - points[j][1])\n                cost[j] = min(cost[j], new_cost)\n\n    return ans\n"
     },
     {
          "instruction": "Given an integer array `arr` and an integer `difference`, return the length of the longest subsequence in `arr` which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals `difference`.\n\nA **subsequence** is a sequence that can be derived from `arr` by deleting some or no elements without changing the order of the remaining elements.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,2,3,4\\], difference = 1\n**Output:** 4\n**Explanation:** The longest arithmetic subsequence is \\[1,2,3,4\\].\n\n**Example 2:**\n\n**Input:** arr = \\[1,3,5,7\\], difference = 1\n**Output:** 1\n**Explanation:** The longest arithmetic subsequence is any single element.\n\n**Example 3:**\n\n**Input:** arr = \\[1,5,7,8,5,3,4,2,1\\], difference = -2\n**Output:** 4\n**Explanation:** The longest arithmetic subsequence is \\[7,5,3,1\\].\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `-104 <= arr[i], difference <= 104`\n\nThe node of a binary tree is a leaf if and only if it has no children. The depth of the node of a binary tree is the number of nodes along the path from the root node down to the node itself.",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        def dfs(node):\n            if not node:\n                return (None, 0)\n            left, right = dfs(node.left), dfs(node.right)\n            if left[1] > right[1]:\n                return (left[0], left[1] + 1)\n            elif left[1] < right[1]:\n                return (right[0], right[1] + 1)\n            else:\n                return (node, left[1] + 1)\n        \n        return dfs(root)[0]\n"
     },
     {
          "instruction": "Given an integer `n`, your task is to count how many strings of length `n` can be formed under the following rules:\n\n*   Each character is a lower case vowel (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`)\n*   Each vowel `'a'` may only be followed by an `'e'`.\n*   Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n*   Each vowel `'i'` **may not** be followed by another `'i'`.\n*   Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n*   Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large, return it modulo `10^9 + 7.`\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** 5\n**Explanation:** All possible strings are:  \"a \",  \"e \",  \"i \" ,  \"o \" and  \"u \".\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 10\n**Explanation:** All possible strings are:  \"ae \",  \"ea \",  \"ei \",  \"ia \",  \"ie \",  \"io \",  \"iu \",  \"oi \",  \"ou \" and  \"ua \".\n\n**Example 3:**\n\n**Input:** n = 5\n**Output:** 68\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 10^4`",
          "output": "from typing import List\n\ndef smallestSufficientTeam(req_skills: List[str], people: List[List[str]]) -> List[int]:\n    skill_to_int = {s: i for i, s in enumerate(req_skills)}\n    people_skills = [sum(1 << skill_to_int[skill] for skill in person) for person in people]\n        \n    n = len(req_skills)\n    INF = 64\n    dp = [INF] * (1 << n)\n    dp[0] = 0\n    parent = [None] * (1 << n)\n        \n    for i, person_skills in enumerate(people_skills):\n        for completed_skills in range((1 << n) - 1, -1, -1):\n            with_person_skills = completed_skills | person_skills\n            if dp[with_person_skills] > dp[completed_skills] + 1:\n                dp[with_person_skills] = dp[completed_skills] + 1\n                parent[with_person_skills] = completed_skills\n                \n    ans = [0] * dp[-1]\n    cur = (1 << n) - 1\n    t = dp[-1] - 1\n        \n    for i in range(len(people) - 1, -1, -1):\n        old = parent[cur]\n        diff = cur ^ old\n        is_essential = (people_skills[i] & diff) > 0\n        if is_essential:\n            ans[t] = i\n            t -= 1\n        cur = old\n    return ans\n"
     },
     {
          "instruction": "A die simulator generates a random number from `1` to `6` for each roll. You introduced a constraint to the generator such that it cannot roll the number `i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\nGiven an array of integers `rollMax` and an integer `n`, return _the number of distinct sequences that can be obtained with exact_ `n` _rolls_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered different if at least one element differs from each other.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2, rollMax = \\[1,1,2,2,2,3\\]\n**Output:** 34\n**Explanation:** There will be 2 rolls of die, if there are no constraints on the die, there are 6 \\* 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.\n\n**Example 2:**\n\n**Input:** n = 2, rollMax = \\[1,1,1,1,1,1\\]\n**Output:** 30\n\n**Example 3:**\n\n**Input:** n = 3, rollMax = \\[1,1,1,2,2,3\\]\n**Output:** 181\n\n**Constraints:**\n\n*   `1 <= n <= 5000`\n*   `rollMax.length == 6`\n*   `1 <= rollMax[i] <= 15`",
          "output": "def areConnected(n, threshold, queries):\n    answer = [False] * len(queries)\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def unite(x, y):\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                rootx, rooty = rooty, rootx\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n    for i in range(threshold + 1, n + 1):\n        for j in range(i * 2, n + 1, i):\n            unite(i, j)\n\n    for i, query in enumerate(queries):\n        answer[i] = find(query[0]) == find(query[1])\n\n    return answer\n"
     },
     {
          "instruction": "We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.\n\nYou're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.\n\n",
          "input": "**Example 1:**\n\n**Input:** startTime = \\[1,2,3,3\\], endTime = \\[3,4,5,6\\], profit = \\[50,10,40,70\\]\n**Output:** 120\n**Explanation:** The subset chosen is the first and fourth job. \nTime range \\[1-3\\]+\\[3-6\\] , we get profit of 120 = 50 + 70.\n\n**Example 2:**\n\n**Input:** startTime = \\[1,2,3,4,6\\], endTime = \\[3,5,10,6,9\\], profit = \\[20,20,100,70,60\\]\n**Output:** 150\n**Explanation:** The subset chosen is the first, fourth and fifth job. \nProfit obtained 150 = 20 + 70 + 60.\n\n**Example 3:**\n\n**Input:** startTime = \\[1,1,1\\], endTime = \\[2,3,4\\], profit = \\[5,6,4\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n*   `1 <= startTime[i] < endTime[i] <= 109`\n*   `1 <= profit[i] <= 104`",
          "output": "from bisect import bisect_left\n\ndef jobScheduling(startTime, endTime, profit):\n    jobs = sorted(zip(endTime, startTime, profit))\n    dp = [jobs[0][2]]\n    \n    def latestNonConflict(index):\n        startTimeToFind = jobs[index][1]\n        index = bisect_left([job[0] for job in jobs], startTimeToFind)\n        if index:\n            return index - 1\n        return -1\n\n    for i in range(1, len(jobs)):\n        L = latestNonConflict(i)\n        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))\n\n    return dp[-1]\n"
     },
     {
          "instruction": "Given a rectangle of size `n` x `m`, return _the minimum number of integer-sided squares that tile the rectangle_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2, m = 3\n**Output:** 3\n**Explanation:** `3` squares are necessary to cover the rectangle.\n`2` (squares of `1x1`)\n`1` (square of `2x2`)\n\n**Example 2:**\n\n**Input:** n = 5, m = 8\n**Output:** 5\n\n**Example 3:**\n\n**Input:** n = 11, m = 13\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= n, m <= 13`",
          "output": "from functools import lru_cache\n\ndef stoneGameII(piles):\n    n = len(piles)\n    for i in range(n - 2, -1, -1):\n        piles[i] += piles[i + 1]\n\n    @lru_cache(None)\n    def search(idx, M):\n        if idx + 2 * M >= n:\n            return piles[idx]\n        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2 * M + 1))\n\n    return search(0, 1)\n"
     },
     {
          "instruction": "`n` passengers board an airplane with exactly `n` seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will:\n\n*   Take their own seat if it is still available, and\n*   Pick other seats randomly when they find their seat occupied\n\nReturn _the probability that the_ `nth` _person gets his own seat_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** 1.00000\n**Explanation:** The first person can only get the first seat.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 0.50000\n**Explanation:** The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n\n**Constraints:**\n\n*   `1 <= n <= 105`",
          "output": "from collections import defaultdict\n\ndef num_equiv_domino_pairs(dominoes):\n    freq = defaultdict(int)\n    result = 0\n    for domino in dominoes:\n        key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n        result += freq[key]\n        freq[key] += 1\n    return result\n"
     },
     {
          "instruction": "Given a list of `words`, list of single `letters` (might be repeating) and `score` of every character.\n\nReturn the maximum score of **any** valid set of words formed by using the given letters (`words[i]` cannot be used two or more times).\n\nIt is not necessary to use all characters in `letters` and each letter can only be used once. Score of letters `'a'`, `'b'`, `'c'`, ... ,`'z'` is given by `score[0]`, `score[1]`, ... , `score[25]` respectively.\n\n",
          "input": "**Example 1:**\n\n**Input:** words = \\[ \"dog \", \"cat \", \"dad \", \"good \"\\], letters = \\[ \"a \", \"a \", \"c \", \"d \", \"d \", \"d \", \"g \", \"o \", \"o \"\\], score = \\[1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0\\]\n**Output:** 23\n**Explanation:**\nScore  a=1, c=9, d=5, g=3, o=2\nGiven letters, we can form the words  \"dad \" (5+1+5) and  \"good \" (3+2+2+5) with a score of 23.\nWords  \"dad \" and  \"dog \" only get a score of 21.\n\n**Example 2:**\n\n**Input:** words = \\[ \"xxxz \", \"ax \", \"bx \", \"cx \"\\], letters = \\[ \"z \", \"a \", \"b \", \"c \", \"x \", \"x \", \"x \"\\], score = \\[4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10\\]\n**Output:** 27\n**Explanation:**\nScore  a=4, b=4, c=4, x=5, z=10\nGiven letters, we can form the words  \"ax \" (4+5),  \"bx \" (4+5) and  \"cx \" (4+5) with a score of 27.\nWord  \"xxxz \" only get a score of 25.\n\n**Example 3:**\n\n**Input:** words = \\[ \"leetcode \"\\], letters = \\[ \"l \", \"e \", \"t \", \"c \", \"o \", \"d \"\\], score = \\[0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0\\]\n**Output:** 0\n**Explanation:**\nLetter  \"e \" can only be used once.\n\n**Constraints:**\n\n*   `1 <= words.length <= 14`\n*   `1 <= words[i].length <= 15`\n*   `1 <= letters.length <= 100`\n*   `letters[i].length == 1`\n*   `score.length == 26`\n*   `0 <= score[i] <= 10`\n*   `words[i]`, `letters[i]` contains only lower case English letters.",
          "output": "def maxValueAfterReverse(nums):\n    total, diff = 0, 0\n    min2, max2 = float('inf'), float('-inf')\n    for i in range(len(nums) - 1):\n        total += abs(nums[i] - nums[i + 1])\n        min2 = min(min2, max(nums[i], nums[i + 1]))\n        max2 = max(max2, min(nums[i], nums[i + 1]))\n        diff = max(diff, abs(nums[i + 1] - nums[0]) - abs(nums[i + 1] - nums[i]))\n        diff = max(diff, abs(nums[i] - nums[-1]) - abs(nums[i] - nums[i + 1]))\n    return total + max(diff, 2 * (max2 - min2))\n"
     },
     {
          "instruction": "You are given an integer `n` representing the number of playing cards you have. A **house of cards** meets the following conditions:\n\n*   A **house of cards** consists of one or more rows of **triangles** and horizontal cards.\n*   **Triangles** are created by leaning two cards against each other.\n*   One card must be placed horizontally between **all adjacent** triangles in a row.\n*   Any triangle on a row higher than the first must be placed on a horizontal card from the previous row.\n*   Each triangle is placed in the **leftmost** available spot in the row.\n\nReturn _the number of **distinct** **house of cards** you can build using **all**_ `n` _cards._ Two houses of cards are considered distinct if there exists a row where the two houses contain a different number of cards.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 16\n**Output:** 2\n**Explanation:** The two valid houses of cards are shown.\nThe third house of cards in the diagram is not valid because the rightmost triangle on the top row is not placed on top of a horizontal card.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** The one valid house of cards is shown.\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 0\n**Explanation:** The three houses of cards in the diagram are not valid.\nThe first house of cards needs a horizontal card placed between the two triangles.\nThe second house of cards uses 5 cards.\nThe third house of cards uses 2 cards.\n\n**Constraints:**\n\n*   `1 <= n <= 500`",
          "output": "from collections import defaultdict\n\ndef maxQualityRec(adjDict, values, node, timeLeft, visited):\n    if timeLeft < 0:\n        return float('-inf')\n\n    maxQuality = 0\n    visited.add(node)\n    for neighbor, time in adjDict[node]:\n        adjDict[neighbor].remove((node, time))\n        maxQuality = max(maxQuality, maxQualityRec(adjDict, values, neighbor, timeLeft - time, visited))\n        adjDict[neighbor].append((node, time))\n    \n    visited.remove(node)\n    return maxQuality + (values[node] if node not in visited else 0)\n\ndef maxQuality(n, values, edges, maxTime):\n    adjDict = defaultdict(list)\n    for u, v, time in edges:\n        adjDict[u].append((v, time))\n        adjDict[v].append((u, time))\n\n    visited = set()\n    return maxQualityRec(adjDict, values, 0, maxTime, visited)\n"
     },
     {
          "instruction": "Given an integer array `nums`, return _the **maximum possible sum** of elements of the array such that it is divisible by three_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,6,5,1,8\\]\n**Output:** 18\n**Explanation:** Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).\n\n**Example 2:**\n\n**Input:** nums = \\[4\\]\n**Output:** 0\n**Explanation:** Since 4 is not divisible by 3, do not pick any number.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,4\\]\n**Output:** 12\n**Explanation:** Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).\n\n**Constraints:**\n\n*   `1 <= nums.length <= 4 * 104`\n*   `1 <= nums[i] <= 104`",
          "output": "from collections import defaultdict\nfrom random import randint\n\nclass MajorityChecker:\n    def __init__(self, arr: List[int]):\n        self.arr = arr\n        self.positions = defaultdict(list)\n        for i, num in enumerate(arr):\n            self.positions[num].append(i)\n\n    def query(self, left: int, right: int, threshold: int) -> int:\n        for _ in range(20):\n            randomIndex = randint(left, right)\n            num = self.arr[randomIndex]\n            lb = self.lower_bound(self.positions[num], left)\n            ub = self.upper_bound(self.positions[num], right)\n            if ub - lb >= threshold:\n                return num\n        return -1\n\n    def lower_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n\n    def upper_bound(self, nums, target):\n        l, r = 0, len(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if nums[mid] <= target:\n                l = mid + 1\n            else:\n                r = mid\n        return l\n"
     },
     {
          "instruction": "There are `n` **piles** of coins on a table. Each pile consists of a **positive number** of coins of assorted denominations.\n\nIn one move, you can choose any coin on **top** of any pile, remove it, and add it to your wallet.\n\nGiven a list `piles`, where `piles[i]` is a list of integers denoting the composition of the `ith` pile from **top to bottom**, and a positive integer `k`, return _the **maximum total value** of coins you can have in your wallet if you choose **exactly**_ `k` _coins optimally_.\n\n",
          "input": "**Example 1:**\n\n**Input:** piles = \\[\\[1,100,3\\],\\[7,8,9\\]\\], k = 2\n**Output:** 101\n**Explanation:**\nThe above diagram shows the different ways we can choose k coins.\nThe maximum total we can obtain is 101.\n\n**Example 2:**\n\n**Input:** piles = \\[\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[100\\],\\[1,1,1,1,1,1,700\\]\\], k = 7\n**Output:** 706\n**Explanation:**\nThe maximum total can be obtained if we choose all coins from the last pile.\n\n**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 1000`\n*   `1 <= piles[i][j] <= 105`\n*   `1 <= k <= sum(piles[i].length) <= 2000`",
          "output": "import heapq\n\ndef maxCoins(piles, k):\n    pq = []\n    for pile in piles:\n        for coin in pile:\n            heapq.heappush(pq, -coin)\n    \n    max_value = 0\n    while k > 0:\n        max_value += -heapq.heappop(pq)\n        k -= 1\n    return max_value\n"
     },
     {
          "instruction": "You have a pointer at index `0` in an array of size `arrLen`. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).\n\nGiven two integers `steps` and `arrLen`, return the number of ways such that your pointer is still at index `0` after **exactly** `steps` steps. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** steps = 3, arrLen = 2\n**Output:** 4\n**Explanation:** There are 4 differents ways to stay at index 0 after 3 steps.\nRight, Left, Stay\nStay, Right, Left\nRight, Stay, Left\nStay, Stay, Stay\n\n**Example 2:**\n\n**Input:** steps = 2, arrLen = 4\n**Output:** 2\n**Explanation:** There are 2 differents ways to stay at index 0 after 2 steps\nRight, Left\nStay, Stay\n\n**Example 3:**\n\n**Input:** steps = 4, arrLen = 2\n**Output:** 8\n\n**Constraints:**\n\n*   `1 <= steps <= 500`\n*   `1 <= arrLen <= 106`",
          "output": "from functools import lru_cache\n\nmod = 10**9 + 7\n\ndef numOfWays(steps: int, arrLen: int) -> int:\n    @lru_cache(None)\n    def dp(s, p):\n        if p < 0 or p >= arrLen or p > steps - p:\n            return 0\n        if s == 0:\n            return p == 0\n        return (dp(s - 1, p - 1) + dp(s - 1, p) + dp(s - 1, p + 1)) % mod\n\n    return dp(steps, 0)\n"
     },
     {
          "instruction": "Given a `m * n` matrix of ones and zeros, return how many **square** submatrices have all ones.\n\n",
          "input": "**Example 1:**\n\n**Input:** matrix =\n\\[\n  \\[0,1,1,1\\],\n  \\[1,1,1,1\\],\n  \\[0,1,1,1\\]\n\\]\n**Output:** 15\n**Explanation:** \nThere are **10** squares of side 1.\nThere are **4** squares of side 2.\nThere is  **1** square of side 3.\nTotal number of squares = 10 + 4 + 1 = **15**.\n\n**Example 2:**\n\n**Input:** matrix = \n\\[\n  \\[1,0,1\\],\n  \\[1,1,0\\],\n  \\[1,1,0\\]\n\\]\n**Output:** 7\n**Explanation:** \nThere are **6** squares of side 1.  \nThere is **1** square of side 2. \nTotal number of squares = 6 + 1 = **7**.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 300`\n*   `1 <= arr[0].length <= 300`\n*   `0 <= arr[i][j] <= 1`",
          "output": "def largest_multiple_of_three(digits):\n    count = [0] * 3\n    num_sum = sum(digits)\n    \n    for d in digits:\n        count[d % 3] += 1\n\n    if num_sum % 3 == 1:\n        if count[1] >= 1:\n            count[1] -= 1\n        else:\n            count[2] -= 2\n    elif num_sum % 3 == 2:\n        if count[2] >= 1:\n            count[2] -= 1\n        else:\n            count[1] -= 2\n\n    res = \"\"\n    for i in range(10):\n        res += str(i) * count[i % 3]\n    \n    if res and res[-1] == \"0\":\n        return \"0\"\n    return res[::-1]\n"
     },
     {
          "instruction": "You are given a string `s` containing lowercase letters and an integer `k`. You need to :\n\n*   First, change some characters of `s` to other lowercase English letters.\n*   Then divide `s` into `k` non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn _the minimal number of characters that you need to change to divide the string_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"abc \", k = 2\n**Output:** 1\n**Explanation:** You can split the string into  \"ab \" and  \"c \", and change 1 character in  \"ab \" to make it palindrome.\n\n**Example 2:**\n\n**Input:** s =  \"aabbc \", k = 3\n**Output:** 0\n**Explanation:** You can split the string into  \"aa \",  \"bb \" and  \"c \", all of them are palindrome.\n\n**Example 3:**\n\n**Input:** s =  \"leetcode \", k = 8\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= k <= s.length <= 100`.\n*   `s` only contains lowercase English letters.",
          "output": "def palindromePartition(s: str, k: int) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n\n    for len in range(2, n + 1):\n        for i in range(n - len + 1):\n            j = i + len - 1\n            dp[i][j] = dp[i + 1][j - 1] + (s[i] != s[j])\n\n    memo = [float('inf')] * n\n    for i in range(n):\n        if dp[0][i] == 0:\n            memo[i] = 0\n        else:\n            for j in range(i):\n                memo[i] = min(memo[i], memo[j] + dp[j + 1][i])\n\n    return memo[-1] + k\n"
     },
     {
          "instruction": "Given a string `s`. In one step you can insert any character at any index of the string.\n\nReturn _the minimum number of steps_ to make `s` palindrome.\n\nA **Palindrome String** is one that reads the same backward as well as forward.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"zzazz \"\n**Output:** 0\n**Explanation:** The string  \"zzazz \" is already palindrome we do not need any insertions.\n\n**Example 2:**\n\n**Input:** s =  \"mbadm \"\n**Output:** 2\n**Explanation:** String can be  \"mbdadbm \" or  \"mdbabdm \".\n\n**Example 3:**\n\n**Input:** s =  \"leetcode \"\n**Output:** 5\n**Explanation:** Inserting 5 characters the string becomes  \"leetcodocteel \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 500`\n*   `s` consists of lowercase English letters.",
          "output": "def extract_artifacts(n, artifacts, dig):\n    artifact_cells = {}\n    artifact_count = {}\n\n    for i, (r1, c1, r2, c2) in enumerate(artifacts):\n        for r in range(r1, r2 + 1):\n            for c in range(c1, c2 + 1):\n                cell = r * n + c\n                if cell not in artifact_cells:\n                    artifact_cells[cell] = set()\n                artifact_cells[cell].add(i)\n                artifact_count[i] = artifact_count.get(i, 0) + 1\n\n    ans = 0\n    for r, c in dig:\n        cell = r * n + c\n        if cell in artifact_cells:\n            for artifact_id in artifact_cells[cell]:\n                artifact_count[artifact_id] -= 1\n                if artifact_count[artifact_id] == 0:\n                    ans += 1\n            del artifact_cells[cell]\n\n    return ans\n"
     },
     {
          "instruction": "You have a keyboard layout as shown above in the **X-Y** plane, where each English uppercase letter is located at some coordinate.\n\n*   For example, the letter `'A'` is located at coordinate `(0, 0)`, the letter `'B'` is located at coordinate `(0, 1)`, the letter `'P'` is located at coordinate `(2, 3)` and the letter `'Z'` is located at coordinate `(4, 1)`.\n\nGiven the string `word`, return _the minimum total **distance** to type such string using only two fingers_.\n\nThe **distance** between coordinates `(x1, y1)` and `(x2, y2)` is `|x1 - x2| + |y1 - y2|`.\n\n**Note** that the initial positions of your two fingers are considered free so do not count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.\n\n",
          "input": "**Example 1:**\n\n**Input:** word =  \"CAKE \"\n**Output:** 3\n**Explanation:** Using two fingers, one optimal way to type  \"CAKE \" is: \nFinger 1 on letter 'C' -> cost = 0 \nFinger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \nFinger 2 on letter 'K' -> cost = 0 \nFinger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \nTotal distance = 3\n\n**Example 2:**\n\n**Input:** word =  \"HAPPY \"\n**Output:** 6\n**Explanation:** Using two fingers, one optimal way to type  \"HAPPY \" is:\nFinger 1 on letter 'H' -> cost = 0\nFinger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\nFinger 2 on letter 'P' -> cost = 0\nFinger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\nFinger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\nTotal distance = 6\n\n**Constraints:**\n\n*   `2 <= word.length <= 300`\n*   `word` consists of uppercase English letters.",
          "output": "def removeDuplicates(s: str, k: int) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1][0] == c:\n            stack[-1][1] += 1\n            if stack[-1][1] == k:\n                stack.pop()\n        else:\n            stack.append([c, 1])\n    return ''.join(c * n for c, n in stack)\n"
     },
     {
          "instruction": "There is a one-dimensional garden on the x-axis. The garden starts at the point `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0, 1, ..., n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where `ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i - ranges[i], i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole garden, If the garden cannot be watered return **\\-1**.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5, ranges = \\[3,4,1,1,0,0\\]\n**Output:** 1\n**Explanation:** The tap at point 0 can cover the interval \\[-3,3\\]\nThe tap at point 1 can cover the interval \\[-3,5\\]\nThe tap at point 2 can cover the interval \\[1,3\\]\nThe tap at point 3 can cover the interval \\[2,4\\]\nThe tap at point 4 can cover the interval \\[4,4\\]\nThe tap at point 5 can cover the interval \\[5,5\\]\nOpening Only the second tap will water the whole garden \\[0,5\\]\n\n**Example 2:**\n\n**Input:** n = 3, ranges = \\[0,0,0,0\\]\n**Output:** -1\n**Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `ranges.length == n + 1`\n*   `0 <= ranges[i] <= 100`",
          "output": "def sum_of_floored_pairs(nums):\n    mod = 10**9 + 7\n    max_val = max(nums)\n    count = [0] * (max_val + 1)\n    pref_sum = [0] * (max_val + 1)\n\n    for num in nums:\n        count[num] += 1\n\n    for i in range(1, max_val + 1):\n        pref_sum[i] = (pref_sum[i - 1] + count[i]) % mod\n\n    res = 0\n    for x in range(1, max_val + 1):\n        nx = x\n        k = 1\n        while nx <= max_val:\n            res = (res + ((pref_sum[nx] - pref_sum[nx - x] + mod) % mod) * k % mod * count[x] % mod) % mod\n            k += 1\n            nx += x\n    return res\n"
     },
     {
          "instruction": "There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[0,1,3\\],\\[1,2,1\\],\\[1,3,4\\],\\[2,3,1\\]\\], distanceThreshold = 4\n**Output:** 3\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> \\[City 1, City 2\\] \nCity 1 -> \\[City 0, City 2, City 3\\] \nCity 2 -> \\[City 0, City 1, City 3\\] \nCity 3 -> \\[City 1, City 2\\] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1,2\\],\\[0,4,8\\],\\[1,2,3\\],\\[1,4,2\\],\\[2,3,1\\],\\[3,4,1\\]\\], distanceThreshold = 2\n**Output:** 0\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> \\[City 1\\] \nCity 1 -> \\[City 0, City 4\\] \nCity 2 -> \\[City 3, City 4\\] \nCity 3 -> \\[City 2, City 4\\]\nCity 4 -> \\[City 1, City 2, City 3\\] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= n * (n - 1) / 2`\n*   `edges[i].length == 3`\n*   `0 <= fromi < toi < n`\n*   `1 <= weighti, distanceThreshold <= 10^4`\n*   All pairs `(fromi, toi)` are distinct.",
          "output": "def findTheCity(n, edges, distanceThreshold):\n    distance = [[1e5] * n for _ in range(n)]\n\n    for edge in edges:\n        distance[edge[0]][edge[1]] = edge[2]\n        distance[edge[1]][edge[0]] = edge[2]\n\n    for i in range(n):\n        distance[i][i] = 0\n\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n\n    res, minReachable = 0, n\n    for i in range(n):\n        reachable = sum(1 for j in range(n) if distance[i][j] <= distanceThreshold)\n        if reachable <= minReachable:\n            minReachable = reachable\n            res = i\n    return res\n"
     },
     {
          "instruction": "You want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To work on the `ith` job, you have to finish all the jobs `j` where `0 <= j < i`).\n\nYou have to finish **at least** one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the `d` days. The difficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array `jobDifficulty` and an integer `d`. The difficulty of the `ith` job is `jobDifficulty[i]`.\n\nReturn _the minimum difficulty of a job schedule_. If you cannot find a schedule for the jobs return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** jobDifficulty = \\[6,5,4,3,2,1\\], d = 2\n**Output:** 7\n**Explanation:** First day you can finish the first 5 jobs, total difficulty = 6.\nSecond day you can finish the last job, total difficulty = 1.\nThe difficulty of the schedule = 6 + 1 = 7 \n\n**Example 2:**\n\n**Input:** jobDifficulty = \\[9,9,9\\], d = 4\n**Output:** -1\n**Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n\n**Example 3:**\n\n**Input:** jobDifficulty = \\[1,1,1\\], d = 3\n**Output:** 3\n**Explanation:** The schedule is one job per day. total difficulty will be 3.\n\n**Constraints:**\n\n*   `1 <= jobDifficulty.length <= 300`\n*   `0 <= jobDifficulty[i] <= 1000`\n*   `1 <= d <= 10`",
          "output": "def max_candies(candies, k):\n    left, right = 1, max(candies)\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        count = sum(candy // mid for candy in candies)\n        if count >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n"
     },
     {
          "instruction": "Given `n` orders, each order consist in pickup and delivery services.\n\nCount all valid pickup/delivery possible sequences such that delivery(i) is always after of pickup(i).\n\nSince the answer may be too large, return it modulo 10^9 + 7.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** Unique order (P1, D1), Delivery 1 always is after of Pickup 1.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 6\n**Explanation:** All possible orders: \n(P1,P2,D1,D2), (P1,P2,D2,D1), (P1,D1,P2,D2), (P2,P1,D1,D2), (P2,P1,D2,D1) and (P2,D2,P1,D1).\nThis is an invalid order (P1,D2,P2,D1) because Pickup 2 is after of Delivery 2.\n\n**Example 3:**\n\n**Input:** n = 3\n**Output:** 90\n\n**Constraints:**\n\n*   `1 <= n <= 500`\n\nGiven 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that : p\\[0\\] = start, p\\[i\\] and p\\[i+1\\] differ by only one bit for all 0 <= i < 2^n - 1.",
          "output": "def circular_permutation(n, start):\n    result = [start ^ (i ^ (i >> 1)) for i in range(1 << n)]\n    return result\n"
     },
     {
          "instruction": "Given an array of integers `arr` and an integer `d`. In one step you can jump from index `i` to index:\n\n*   `i + x` where: `i + x < arr.length` and `0 < x <= d`.\n*   `i - x` where: `i - x >= 0` and `0 < x <= d`.\n\nIn addition, you can only jump from index `i` to index `j` if `arr[i] > arr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More formally `min(i, j) < k < max(i, j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum number of indices_ you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[6,4,14,6,8,13,9,7,10,6,12\\], d = 2\n**Output:** 4\n**Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\nNote that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\nSimilarly You cannot jump from index 3 to index 2 or index 1.\n\n**Example 2:**\n\n**Input:** arr = \\[3,3,3,3,3\\], d = 3\n**Output:** 1\n**Explanation:** You can start at any index. You always cannot jump to any index.\n\n**Example 3:**\n\n**Input:** arr = \\[7,6,5,4,3,2,1\\], d = 1\n**Output:** 7\n**Explanation:** Start at index 0. You can visit all the indicies. \n\n**Constraints:**\n\n*   `1 <= arr.length <= 1000`\n*   `1 <= arr[i] <= 105`\n*   `1 <= d <= arr.length`",
          "output": "import threading\n\nclass DiningPhilosophers:\n    def __init__(self):\n        self.forks = [threading.Lock() for _ in range(5)]\n        self.not_busy = [threading.Condition(self.forks[i]) for i in range(5)]\n\n    def wantsToEat(self, philosopher: int, pickLeftFork: 'Callable[[], None]', pickRightFork: 'Callable[[], None]', eat: 'Callable[[], None]', putLeftFork: 'Callable[[], None]', putRightFork: 'Callable[[], None]') -> None:\n        left_fork = philosopher\n        right_fork = (philosopher + 1) % 5\n\n        with self.forks[left_fork]:\n            with self.not_busy[left_fork]:\n                while not self.forks[right_fork].acquire(blocking=False):\n                    self.not_busy[left_fork].wait()\n            pickLeftFork()\n\n            with self.forks[right_fork]:\n                pickRightFork()\n                eat()\n                putRightFork()\n                self.forks[right_fork].release()\n                with self.not_busy[right_fork]:\n                    self.not_busy[right_fork].notify_all()\n\n            putLeftFork()\n            self.not_busy[left_fork].notify_all()\n"
     },
     {
          "instruction": "Given a `m * n` matrix `seats` that represent seats distributions in a classroom. If a seat is broken, it is denoted by `'#'` character otherwise it is denoted by a `'.'` character.\n\nStudents can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the **maximum** number of students that can take the exam together without any cheating being possible..\n\nStudents must be placed in seats in good condition.\n\n",
          "input": "**Example 1:**\n\n**Input:** seats = \\[\\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\],\n                \\[ \". \", \"# \", \"# \", \"# \", \"# \", \". \"\\],\n                \\[ \"# \", \". \", \"# \", \"# \", \". \", \"# \"\\]\\]\n**Output:** 4\n**Explanation:** Teacher can place 4 students in available seats so they don't cheat on the exam. \n\n**Example 2:**\n\n**Input:** seats = \\[\\[ \". \", \"# \"\\],\n                \\[ \"# \", \"# \"\\],\n                \\[ \"# \", \". \"\\],\n                \\[ \"# \", \"# \"\\],\n                \\[ \". \", \"# \"\\]\\]\n**Output:** 3\n**Explanation:** Place all students in available seats. \n\n**Example 3:**\n\n**Input:** seats = \\[\\[ \"# \", \". \", \"**.** \", \". \", \"# \"\\],\n                \\[ \"**.** \", \"# \", \"**.** \", \"# \", \"**.** \"\\],\n                \\[ \"**.** \", \". \", \"# \", \". \", \"**.** \"\\],\n                \\[ \"**.** \", \"# \", \"**.** \", \"# \", \"**.** \"\\],\n                \\[ \"# \", \". \", \"**.** \", \". \", \"# \"\\]\\]\n**Output:** 10\n**Explanation:** Place students in available seats in column 1, 3 and 5.\n\n**Constraints:**\n\n*   `seats` contains only characters `'.' and``'#'.`\n*   `m == seats.length`\n*   `n == seats[i].length`\n*   `1 <= m <= 8`\n*   `1 <= n <= 8`",
          "output": "from typing import List\n\ndef checkStraightLine(coordinates: List[List[int]]) -> bool:\n    dx = coordinates[1][0] - coordinates[0][0]\n    dy = coordinates[1][1] - coordinates[0][1]\n\n    for x, y in coordinates[2:]:\n        if dx * (y - coordinates[0][1]) != dy * (x - coordinates[0][0]):\n            return False\n\n    return True\n"
     },
     {
          "instruction": "You are given the `root` of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n*   Choose **any** node in the binary tree and a direction (right or left).\n*   If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n*   Change the direction from right to left or from left to right.\n*   Repeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn _the longest **ZigZag** path contained in that tree_.\n\n",
          "input": "**Example 1:**\n\n**Input:** root = \\[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1\\]\n**Output:** 3\n**Explanation:** Longest ZigZag path in blue nodes (right -> left -> right).\n\n**Example 2:**\n\n**Input:** root = \\[1,1,1,null,1,null,null,1,1,null,1\\]\n**Output:** 4\n**Explanation:** Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\n**Example 3:**\n\n**Input:** root = \\[1\\]\n**Output:** 0\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 5 * 104]`.\n*   `1 <= Node.val <= 100`",
          "output": "from math import gcd\nfrom functools import reduce\n\ndef is_good_array(nums):\n    gcd_value = reduce(gcd, nums)\n    return gcd_value == 1\n"
     },
     {
          "instruction": "Given a **binary tree** `root`, return _the maximum sum of all keys of **any** sub-tree which is also a Binary Search Tree (BST)_.\n\nAssume a BST is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than** the node's key.\n*   Both the left and right subtrees must also be binary search trees.\n\n",
          "input": "**Example 1:**\n\n**Input:** root = \\[1,4,3,2,4,2,5,null,null,null,null,null,null,4,6\\]\n**Output:** 20\n**Explanation:** Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n\n**Example 2:**\n\n**Input:** root = \\[4,3,null,1,2\\]\n**Output:** 2\n**Explanation:** Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n\n**Example 3:**\n\n**Input:** root = \\[-4,-2,-5\\]\n**Output:** 0\n**Explanation:** All values are negatives. Return an empty BST.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 4 * 104]`.\n*   `-4 * 104 <= Node.val <= 4 * 104`",
          "output": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxSumBST(self, root: TreeNode) -> int:\n        max_sum = [0]\n\n        def dfs(node):\n            if not node:\n                return 1, 0, float(\"inf\"), float(\"-inf\")\n\n            l = dfs(node.left)\n            r = dfs(node.right)\n\n            if not l[0] or not r[0] or node.val <= l[3] or node.val >= r[2]:\n                return 0, 0, 0, 0\n\n            curr_sum = node.val + l[1] + r[1]\n            max_sum[0] = max(max_sum[0], curr_sum)\n\n            return 1, curr_sum, min(node.val, l[2]), max(node.val, r[3])\n\n        dfs(root)\n        return max_sum[0]\n"
     },
     {
          "instruction": "There is a pizza with `3n` slices of varying size, you and your friends will take slices of pizza as follows:\n\n*   You will pick **any** pizza slice.\n*   Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n*   Your friend Bob will pick the next slice in the clockwise direction of your pick.\n*   Repeat until there are no more slices of pizzas.\n\nGiven an integer array `slices` that represent the sizes of the pizza slices in a clockwise direction, return _the maximum possible sum of slice sizes that you can pick_.\n\n",
          "input": "**Example 1:**\n\n**Input:** slices = \\[1,2,3,4,5,6\\]\n**Output:** 10\n**Explanation:** Pick pizza slice of size 4, Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6, finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n\n**Example 2:**\n\n**Input:** slices = \\[8,9,8,6,1,1\\]\n**Output:** 16\n**Explanation:** Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n\n**Constraints:**\n\n*   `3 * n == slices.length`\n*   `1 <= slices.length <= 500`\n*   `1 <= slices[i] <= 1000`",
          "output": "def maxSumDivThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[:]\n        for s in temp:\n            dp[(s + num) % 3] = max(dp[(s + num) % 3], s + num)\n    return dp[0]\n"
     },
     {
          "instruction": "A chef has collected data on the `satisfaction` level of his `n` dishes. Chef can cook any dish in 1 unit of time.\n\n**Like-time coefficient** of a dish is defined as the time taken to cook that dish including previous dishes multiplied by its satisfaction level i.e. `time[i] * satisfaction[i]`.\n\nReturn _the maximum sum of **like-time coefficient** that the chef can obtain after dishes preparation_.\n\nDishes can be prepared in **any** order and the chef can discard some dishes to get this maximum value.\n\n",
          "input": "**Example 1:**\n\n**Input:** satisfaction = \\[-1,-8,0,5,-9\\]\n**Output:** 14\n**Explanation:** After Removing the second and last dish, the maximum total **like-time coefficient** will be equal to (-1\\*1 + 0\\*2 + 5\\*3 = 14).\nEach dish is prepared in one unit of time.\n\n**Example 2:**\n\n**Input:** satisfaction = \\[4,3,2\\]\n**Output:** 20\n**Explanation:** Dishes can be prepared in any order, (2\\*1 + 3\\*2 + 4\\*3 = 20)\n\n**Example 3:**\n\n**Input:** satisfaction = \\[-1,-4,-5\\]\n**Output:** 0\n**Explanation:** People do not like the dishes. No dish is prepared.\n\n**Constraints:**\n\n*   `n == satisfaction.length`\n*   `1 <= n <= 500`\n*   `-1000 <= satisfaction[i] <= 1000`",
          "output": "def countSquares(matrix: List[List[int]]) -> int:\n    m, n, ans = len(matrix), len(matrix[0]), 0\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = matrix[i][j]\n            elif matrix[i][j]:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n            ans += dp[i][j]\n    return ans\n"
     },
     {
          "instruction": "There are `n` soldiers standing in a line. Each soldier is assigned a **unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n*   Choose 3 soldiers with index (`i`, `j`, `k`) with rating (`rating[i]`, `rating[j]`, `rating[k]`).\n*   A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be part of multiple teams).\n\n",
          "input": "**Example 1:**\n\n**Input:** rating = \\[2,5,3,4,1\\]\n**Output:** 3\n**Explanation:** We can form three teams given the conditions. (2,3,4), (5,4,1), (5,3,1). \n\n**Example 2:**\n\n**Input:** rating = \\[2,1,3\\]\n**Output:** 0\n**Explanation:** We can't form any team given the conditions.\n\n**Example 3:**\n\n**Input:** rating = \\[1,2,3,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `n == rating.length`\n*   `3 <= n <= 1000`\n*   `1 <= rating[i] <= 105`\n*   All the integers in `rating` are **unique**.\n\nIn one second, you can either: - Move vertically by one unit, - Move horizontally by one unit, or - Move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in one second). You have to visit the points in the same order as they appear in the array. You are allowed to pass through points, but they do not count as visited unless you stop on them.",
          "output": "def minTimeToVisitAllPoints(points: List[List[int]]) -> int:\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        time += max(dx, dy)\n    return time\n"
     },
     {
          "instruction": "Given the strings `s1` and `s2` of size `n` and the string `evil`, return _the number of **good** strings_.\n\nA **good** string has size `n`, it is alphabetically greater than or equal to `s1`, it is alphabetically smaller than or equal to `s2`, and it does not contain the string `evil` as a substring. Since the answer can be a huge number, return this **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2, s1 =  \"aa \", s2 =  \"da \", evil =  \"b \"\n**Output:** 51 \n**Explanation:** There are 25 good strings starting with 'a':  \"aa \", \"ac \", \"ad \",..., \"az \". Then there are 25 good strings starting with 'c':  \"ca \", \"cc \", \"cd \",..., \"cz \" and finally there is one good string starting with 'd':  \"da \". \n\n**Example 2:**\n\n**Input:** n = 8, s1 =  \"leetcode \", s2 =  \"leetgoes \", evil =  \"leet \"\n**Output:** 0 \n**Explanation:** All strings greater than or equal to s1 and smaller than or equal to s2 start with the prefix  \"leet \", therefore, there is not any good string.\n\n**Example 3:**\n\n**Input:** n = 2, s1 =  \"gx \", s2 =  \"gz \", evil =  \"x \"\n**Output:** 2\n\n**Constraints:**\n\n*   `s1.length == n`\n*   `s2.length == n`\n*   `s1 <= s2`\n*   `1 <= n <= 500`\n*   `1 <= evil.length <= 50`\n*   All strings consist of lowercase English letters.",
          "output": "from bisect import bisect_left\n\ndef suggestedProducts(products, searchWord):\n    products.sort()\n    result = []\n    current_prefix = \"\"\n    \n    for letter in searchWord:\n        current_prefix += letter\n        index = bisect_left(products, current_prefix)\n        suggestions = []\n        \n        for i in range(3):\n            if index < len(products) and products[index].startswith(current_prefix):\n                suggestions.append(products[index])\n                index += 1\n            else:\n                break\n        \n        result.append(suggestions)\n    \n    return result\n"
     },
     {
          "instruction": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits `s` and all we know is that all integers in the array were in the range `[1, k]` and there are no leading zeros in the array.\n\nGiven the string `s` and the integer `k`, return _the number of the possible arrays that can be printed as_ `s` _using the mentioned program_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"1000 \", k = 10000\n**Output:** 1\n**Explanation:** The only possible array is \\[1000\\]\n\n**Example 2:**\n\n**Input:** s =  \"1000 \", k = 10\n**Output:** 0\n**Explanation:** There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n\n**Example 3:**\n\n**Input:** s =  \"1317 \", k = 2000\n**Output:** 8\n**Explanation:** Possible arrays are \\[1317\\],\\[131,7\\],\\[13,17\\],\\[1,317\\],\\[13,1,7\\],\\[1,31,7\\],\\[1,3,17\\],\\[1,3,1,7\\]\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only digits and does not contain leading zeros.\n*   `1 <= k <= 109`",
          "output": "def numDecodings(s: str, k: int) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[n] = 1\n    MOD = 1000000007\n\n    for i in range(n - 1, -1, -1):\n        num = 0\n        for j in range(i, n):\n            num = num * 10 + int(s[j])\n            if num >= 1 and num <= k:\n                dp[i] = (dp[i] + dp[j + 1]) % MOD\n            if num > k:\n                break\n\n    return dp[0]\n"
     },
     {
          "instruction": "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n\n",
          "input": "**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`",
          "output": "def stoneGameIII(stoneValue):\n    n = len(stoneValue)\n    dp = [float(\"-inf\")] * (n + 1)\n    dp[n] = 0\n    \n    for i in range(n - 1, -1, -1):\n        curr = 0\n        for j in range(3):\n            if i + j < n:\n                curr += stoneValue[i + j]\n                dp[i] = max(dp[i], curr - dp[i + j + 1])\n                \n    return \"Tie \" if dp[0] == 0 else \"Alice \" if dp[0] > 0 else \"Bob \"\n"
     },
     {
          "instruction": "You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: **Red**, **Yellow,** or **Green** while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).\n\nGiven `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** 12\n**Explanation:** There are 12 possible way to paint the grid as shown.\n\n**Example 2:**\n\n**Input:** n = 5000\n**Output:** 30228214\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `1 <= n <= 5000`",
          "output": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    num = 0\n    while head:\n        num = (num << 1) | head.val\n        head = head.next\n    return num\n"
     },
     {
          "instruction": "There are `n` people and `40` types of hats labeled from `1` to `40`.\n\nGiven a 2D integer array `hats`, where `hats[i]` is a list of all hats preferred by the `ith` person.\n\nReturn _the number of ways that the `n` people wear different hats to each other_.\n\nSince the answer may be too large, return it modulo `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** hats = \\[\\[3,4\\],\\[4,5\\],\\[5\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n\n**Example 2:**\n\n**Input:** hats = \\[\\[3,5,1\\],\\[3,5\\]\\]\n**Output:** 4\n**Explanation:** There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n\n**Example 3:**\n\n**Input:** hats = \\[\\[1,2,3,4\\],\\[1,2,3,4\\],\\[1,2,3,4\\],\\[1,2,3,4\\]\\]\n**Output:** 24\n**Explanation:** Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n\n**Constraints:**\n\n*   `n == hats.length`\n*   `1 <= n <= 10`\n*   `1 <= hats[i].length <= 40`\n*   `1 <= hats[i][j] <= 40`\n*   `hats[i]` contains a list of **unique** integers.",
          "output": "def freqAlphabets(s):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + 2 < len(s) and s[i + 2] == '#':\n            result.append(chr(ord('a') + int(s[i:i + 2]) - 1))\n            i += 3\n        else:\n            result.append(chr(ord('a') + int(s[i]) - 1))\n            i += 1\n    return ''.join(result)\n"
     },
     {
          "instruction": "You are given three integers `n`, `m` and `k`. Consider the following algorithm to find the maximum element of an array of positive integers:\n\nYou should build the array arr which has the following properties:\n\n*   `arr` has exactly `n` integers.\n*   `1 <= arr[i] <= m` where `(0 <= i < n)`.\n*   After applying the mentioned algorithm to `arr`, the value `search_cost` is equal to `k`.\n\nReturn _the number of ways_ to build the array `arr` under the mentioned conditions. As the answer may grow large, the answer **must be** computed modulo `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2, m = 3, k = 1\n**Output:** 6\n**Explanation:** The possible arrays are \\[1, 1\\], \\[2, 1\\], \\[2, 2\\], \\[3, 1\\], \\[3, 2\\] \\[3, 3\\]\n\n**Example 2:**\n\n**Input:** n = 5, m = 2, k = 3\n**Output:** 0\n**Explanation:** There are no possible arrays that satisify the mentioned conditions.\n\n**Example 3:**\n\n**Input:** n = 9, m = 1, k = 1\n**Output:** 1\n**Explanation:** The only possible array is \\[1, 1, 1, 1, 1, 1, 1, 1, 1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= m <= 100`\n*   `0 <= k <= n`",
          "output": "def waysToBuildArray(n, m, k):\n    mod = 10**9 + 7\n    dp = [[0] * (k+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(k+1):\n            for x in range(1, m+1):\n                if j < i * (x-1):\n                    dp[i][j] = (dp[i][j] + dp[i-1][j-(i-1)*(x-1)]) % mod\n    return dp[n][k]\n"
     },
     {
          "instruction": "Given an array of integers `cost` and an integer `target`, return _the **maximum** integer you can paint under the following rules_:\n\n*   The cost of painting a digit `(i + 1)` is given by `cost[i]` (**0-indexed**).\n*   The total cost used must be equal to `target`.\n*   The integer does not have `0` digits.\n\nSince the answer may be very large, return it as a string. If there is no way to paint any integer given the condition, return `\"0 \"`.\n\n",
          "input": "**Example 1:**\n\n**Input:** cost = \\[4,3,2,5,6,7,2,5,5\\], target = 9\n**Output:**  \"7772 \"\n**Explanation:** The cost to paint the digit '7' is 2, and the digit '2' is 3. Then cost( \"7772 \") = 2\\*3+ 3\\*1 = 9. You could also paint  \"977 \", but  \"7772 \" is the largest number.\n**Digit    cost**\n  1  ->   4\n  2  ->   3\n  3  ->   2\n  4  ->   5\n  5  ->   6\n  6  ->   7\n  7  ->   2\n  8  ->   5\n  9  ->   5\n\n**Example 2:**\n\n**Input:** cost = \\[7,6,5,5,5,6,8,7,8\\], target = 12\n**Output:**  \"85 \"\n**Explanation:** The cost to paint the digit '8' is 7, and the digit '5' is 5. Then cost( \"85 \") = 7 + 5 = 12.\n\n**Example 3:**\n\n**Input:** cost = \\[2,4,6,2,4,6,4,4,4\\], target = 5\n**Output:**  \"0 \"\n**Explanation:** It is impossible to paint any integer with total cost equal to target.\n\n**Constraints:**\n\n*   `cost.length == 9`\n*   `1 <= cost[i], target <= 5000`",
          "output": "def largestNumber(cost, target):\n    dp = [\"\" for _ in range(target + 1)]\n    dp[0] = \"\"\n\n    for i in range(9):\n        for j in range(cost[i], target + 1):\n            if dp[j - cost[i]] != None and len(dp[j - cost[i]]) < j - cost[i] \\\n               and (dp[j] == None or len(dp[j - cost[i]]) + 1 > len(dp[j])):\n                dp[j] = dp[j - cost[i]] + str(i + 1)\n\n    return dp[target] if dp[target] else \"0\"\n"
     },
     {
          "instruction": "Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n",
          "input": "**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.",
          "output": "def number_of_steps(num):\n    steps = 0\n    while num:\n        steps += 1 if num % 2 == 0 else 2\n        num >>= 1\n    return steps - 1\n"
     },
     {
          "instruction": "You are given a `rows x cols` matrix `grid` representing a field of cherries where `grid[i][j]` represents the number of cherries that you can collect from the `(i, j)` cell.\n\nYou have two robots that can collect cherries for you:\n\n*   **Robot #1** is located at the **top-left corner** `(0, 0)`, and\n*   **Robot #2** is located at the **top-right corner** `(0, cols - 1)`.\n\nReturn _the maximum number of cherries collection using both robots by following the rules below_:\n\n*   From a cell `(i, j)`, robots can move to cell `(i + 1, j - 1)`, `(i + 1, j)`, or `(i + 1, j + 1)`.\n*   When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\n*   When both robots stay in the same cell, only one takes the cherries.\n*   Both robots cannot move outside of the grid at any moment.\n*   Both robots should reach the bottom row in `grid`.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[3,1,1\\],\\[2,5,1\\],\\[1,5,5\\],\\[2,1,1\\]\\]\n**Output:** 24\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0,0,0,1\\],\\[2,0,0,0,0,3,0\\],\\[2,0,9,0,0,0,0\\],\\[0,3,0,5,4,0,0\\],\\[1,0,2,3,0,0,6\\]\\]\n**Output:** 28\n**Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28.\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols == grid[i].length`\n*   `2 <= rows, cols <= 70`\n*   `0 <= grid[i][j] <= 100`",
          "output": "from typing import List\nimport heapq\n\ndef kWeakestRows(mat: List[List[int]], k: int) -> List[int]:\n    soldier_rows = [(row.count(1), i) for i, row in enumerate(mat)]\n    heapq.heapify(soldier_rows)\n    return [heapq.heappop(soldier_rows)[1] for _ in range(k)]\n"
     },
     {
          "instruction": "Given two arrays `nums1` and `nums2`.\n\nReturn the maximum dot product between **non-empty** subsequences of nums1 and nums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, `[2,3,5]` is a subsequence of `[1,2,3,4,5]` while `[1,5,3]` is not).\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[2,1,-2,5\\], nums2 = \\[3,0,-6\\]\n**Output:** 18\n**Explanation:** Take subsequence \\[2,-2\\] from nums1 and subsequence \\[3,-6\\] from nums2.\nTheir dot product is (2\\*3 + (-2)\\*(-6)) = 18.\n\n**Example 2:**\n\n**Input:** nums1 = \\[3,-2\\], nums2 = \\[2,-6,7\\]\n**Output:** 21\n**Explanation:** Take subsequence \\[3\\] from nums1 and subsequence \\[7\\] from nums2.\nTheir dot product is (3\\*7) = 21.\n\n**Example 3:**\n\n**Input:** nums1 = \\[-1,-1\\], nums2 = \\[1,1\\]\n**Output:** -1\n**Explanation:** Take subsequence \\[-1\\] from nums1 and subsequence \\[1\\] from nums2.\nTheir dot product is -1.\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 500`\n*   `-1000 <= nums1[i], nums2[i] <= 1000`",
          "output": "def sortByBits(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))\n"
     },
     {
          "instruction": "Given the array `houses` where `houses[i]` is the location of the `ith` house along a street and an integer `k`, allocate `k` mailboxes in the street.\n\nReturn _the **minimum** total distance between each house and its nearest mailbox_.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** houses = \\[1,4,8,10,20\\], k = 3\n**Output:** 5\n**Explanation:** Allocate mailboxes in position 3, 9 and 20.\nMinimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n\n**Example 2:**\n\n**Input:** houses = \\[2,3,5,12,18\\], k = 2\n**Output:** 9\n**Explanation:** Allocate mailboxes in position 3 and 14.\nMinimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n\n**Constraints:**\n\n*   `1 <= k <= houses.length <= 100`\n*   `1 <= houses[i] <= 104`\n*   All the integers of `houses` are **unique**.",
          "output": "def max_events(events):\n    events.sort(key=lambda x: x[1])\n\n    count = 0\n    last_day = -1\n\n    for event in events:\n        if event[0] > last_day:\n            count += 1\n            last_day = event[1]\n\n    return count\n"
     },
     {
          "instruction": "You are given an array of integers `arr` and an integer `target`.\n\nYou have to find **two non-overlapping sub-arrays** of `arr` each with a sum equal `target`. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is **minimum**.\n\nReturn _the minimum sum of the lengths_ of the two required sub-arrays, or return `-1` if you cannot find such two sub-arrays.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[3,2,2,4,3\\], target = 3\n**Output:** 2\n**Explanation:** Only two sub-arrays have sum = 3 (\\[3\\] and \\[3\\]). The sum of their lengths is 2.\n\n**Example 2:**\n\n**Input:** arr = \\[7,3,4,7\\], target = 7\n**Output:** 2\n**Explanation:** Although we have three non-overlapping sub-arrays of sum = 7 (\\[7\\], \\[3,4\\] and \\[7\\]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n\n**Example 3:**\n\n**Input:** arr = \\[4,3,2,6,2,3,4\\], target = 6\n**Output:** -1\n**Explanation:** We have only one sub-array of sum = 6.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 1000`\n*   `1 <= target <= 108`",
          "output": "class ProductOfNumbers:\n    def __init__(self):\n        self.products = [1]\n\n    def add(self, num: int) -> None:\n        if num == 0:\n            self.products = [1]\n        else:\n            self.products.append(self.products[-1] * num)\n\n    def getProduct(self, k: int) -> int:\n        if k >= len(self.products):\n            return 0\n        else:\n            return self.products[-1] // self.products[-k - 1]\n"
     },
     {
          "instruction": "Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`.\n\nAll the balls will be **shuffled uniformly at random**, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully).\n\nPlease note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a)` (Please read the explanation of the first example carefully).\n\nReturn _the probability_ that the two boxes have the same number of distinct balls. Answers within `10-5` of the actual value will be accepted as correct.\n\n",
          "input": "**Example 1:**\n\n**Input:** balls = \\[1,1\\]\n**Output:** 1.00000\n**Explanation:** Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1\n\n**Example 2:**\n\n**Input:** balls = \\[2,1,1\\]\n**Output:** 0.66667\n**Explanation:** We have the set of balls \\[1, 1, 2, 3\\]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n\\[1,1 / 2,3\\], \\[1,1 / 3,2\\], \\[1,2 / 1,3\\], \\[1,2 / 3,1\\], \\[1,3 / 1,2\\], \\[1,3 / 2,1\\], \\[2,1 / 1,3\\], \\[2,1 / 3,1\\], \\[2,3 / 1,1\\], \\[3,1 / 1,2\\], \\[3,1 / 2,1\\], \\[3,2 / 1,1\\]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667\n\n**Example 3:**\n\n**Input:** balls = \\[1,2,1,2\\]\n**Output:** 0.60000\n**Explanation:** The set of balls is \\[1, 2, 2, 3, 4, 4\\]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6\n\n**Constraints:**\n\n*   `1 <= balls.length <= 8`\n*   `1 <= balls[i] <= 6`\n*   `sum(balls)` is even.",
          "output": "from math import factorial\n\ndef count_combinations(balls, combinations, curr_ball):\n    total_combinations = 1\n    for i in range(curr_ball):\n        total_combinations *= factorial(balls[i] + combinations[i]) / (factorial(balls[i]) * factorial(combinations[i]))\n\n    return total_combinations\n\ndef dfs(balls, combinations, curr_ball):\n    if curr_ball == len(balls):\n        if combinations[-1] == combinations[0]:\n            return count_combinations(balls, combinations, curr_ball)\n        else:\n            return 0\n\n    result = 0\n    for i in range(balls[curr_ball] + 1):\n        combinations.append(i)\n        result += dfs(balls, combinations, curr_ball + 1)\n        combinations.pop()\n\n    return result\n\ndef get_probability(balls):\n    sum_balls = sum(balls)\n\n    total_combinations = 1\n    for ball in balls:\n        total_combinations *= factorial(ball)\n\n    combinations = []\n    return dfs(balls, combinations, 0) / total_combinations\n"
     },
     {
          "instruction": "There is a row of `m` houses in a small city, each house must be painted with one of the `n` colors (labeled from `1` to `n`), some houses that have been painted last summer should not be painted again.\n\nA neighborhood is a maximal group of continuous houses that are painted with the same color.\n\n*   For example: `houses = [1,2,2,3,3,2,1,1]` contains `5` neighborhoods `[{1}, {2,2}, {3,3}, {2}, {1,1}]`.\n\nGiven an array `houses`, an `m x n` matrix `cost` and an integer `target` where:\n\n*   `houses[i]`: is the color of the house `i`, and `0` if the house is not painted yet.\n*   `cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.\n\nReturn _the minimum cost of painting all the remaining houses in such a way that there are exactly_ `target` _neighborhoods_. If it is not possible, return `-1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** houses = \\[0,0,0,0,0\\], cost = \\[\\[1,10\\],\\[10,1\\],\\[10,1\\],\\[1,10\\],\\[5,1\\]\\], m = 5, n = 2, target = 3\n**Output:** 9\n**Explanation:** Paint houses of this way \\[1,2,2,1,1\\]\nThis array contains target = 3 neighborhoods, \\[{1}, {2,2}, {1,1}\\].\nCost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n\n**Example 2:**\n\n**Input:** houses = \\[0,2,1,2,0\\], cost = \\[\\[1,10\\],\\[10,1\\],\\[10,1\\],\\[1,10\\],\\[5,1\\]\\], m = 5, n = 2, target = 3\n**Output:** 11\n**Explanation:** Some houses are already painted, Paint the houses of this way \\[2,2,1,2,2\\]\nThis array contains target = 3 neighborhoods, \\[{2,2}, {1}, {2,2}\\]. \nCost of paint the first and last house (10 + 1) = 11.\n\n**Example 3:**\n\n**Input:** houses = \\[3,1,2,3\\], cost = \\[\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\],\\[1,1,1\\]\\], m = 4, n = 3, target = 3\n**Output:** -1\n**Explanation:** Houses are already painted with a total of 4 neighborhoods \\[{3},{1},{2},{3}\\] different of target = 3.\n\n**Constraints:**\n\n*   `m == houses.length == cost.length`\n*   `n == cost[i].length`\n*   `1 <= m <= 100`\n*   `1 <= n <= 20`\n*   `1 <= target <= m`\n*   `0 <= houses[i] <= n`\n*   `1 <= cost[i][j] <= 104`",
          "output": "def findTheLongestSubstring(s: str) -> int:\n    pos = {-1: 0}\n    ans = cur = 0\n    for i, c in enumerate(s):\n        cur ^= 1 << (\"aeiou\".find(c) + 1) >> 1\n        if cur not in pos:\n            pos[cur] = i + 1\n        ans = max(ans, i + 1 - pos[cur])\n    return ans\n"
     },
     {
          "instruction": "Given a binary array `nums`, you should delete one element from it.\n\nReturn _the size of the longest non-empty subarray containing only_ `1`_'s in the resulting array_. Return `0` if there is no such subarray.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,1,0,1\\]\n**Output:** 3\n**Explanation:** After deleting the number in position 2, \\[1,1,1\\] contains 3 numbers with value of 1's.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,1,1,0,1,1,0,1\\]\n**Output:** 5\n**Explanation:** After deleting the number in position 4, \\[0,1,1,1,1,1,0,1\\] longest subarray with value of 1's is \\[1,1,1,1,1\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 2\n**Explanation:** You must delete one element.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
          "output": "from collections import defaultdict\n\ndef frogPosition(n, edges, t, target):\n    graph = defaultdict(list)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    return dfs(1, -1, t, target, graph)\n\ndef dfs(node, parent, t, target, graph):\n    if t == 0:\n        return 1.0 if node == target else 0.0\n    probability = 0.0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            probability += dfs(neighbor, node, t - 1, target, graph)\n    return probability / (len(graph[node]) - (0 if parent == -1 else 1))\n"
     },
     {
          "instruction": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.\n\nIn one semester, you can take **at most** `k` courses as long as you have taken all the prerequisites in the **previous** semesters for the courses you are taking.\n\nReturn _the **minimum** number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 4, relations = \\[\\[2,1\\],\\[3,1\\],\\[1,4\\]\\], k = 2\n**Output:** 3\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can take courses 2 and 3.\nIn the second semester, you can take course 1.\nIn the third semester, you can take course 4.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[2,1\\],\\[3,1\\],\\[4,1\\],\\[1,5\\]\\], k = 2\n**Output:** 4\n**Explanation:** The figure above represents the given graph.\nIn the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.\nIn the second semester, you can take course 4.\nIn the third semester, you can take course 1.\nIn the fourth semester, you can take course 5.\n\n**Constraints:**\n\n*   `1 <= n <= 15`\n*   `1 <= k <= n`\n*   `0 <= relations.length <= n * (n-1) / 2`\n*   `relations[i].length == 2`\n*   `1 <= prevCoursei, nextCoursei <= n`\n*   `prevCoursei != nextCoursei`\n*   All the pairs `[prevCoursei, nextCoursei]` are **unique**.\n*   The given graph is a directed acyclic graph.",
          "output": "from collections import deque\n\ndef minNumberOfSemesters(n, relations, k):\n    indegree = [0] * (n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for prev_course, next_course in relations:\n        graph[prev_course].append(next_course)\n        indegree[next_course] += 1\n\n    semesters = 0\n    while n > 0:\n        zero_indegree = deque()\n        for i in range(1, len(indegree)):\n            if indegree[i] == 0:\n                zero_indegree.append(i)\n                indegree[i] = -1\n\n        courses = 0\n        while zero_indegree and courses < k:\n            curr_course = zero_indegree.popleft()\n            n -= 1\n\n            for next_course in graph[curr_course]:\n                indegree[next_course] -= 1\n            courses += 1\n        semesters += 1\n    return semesters\n"
     },
     {
          "instruction": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there are `n` stones in a pile. On each player's turn, that player makes a _move_ consisting of removing **any** non-zero **square number** of stones in the pile.\n\nAlso, if a player cannot make a move, he/she loses the game.\n\nGiven a positive integer `n`, return `true` if and only if Alice wins the game otherwise return `false`, assuming both players play optimally.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** false\n**Explanation:** Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** true\n**Explanation:** n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n\n**Constraints:**\n\n*   `1 <= n <= 105`",
          "output": "def find_lucky(arr):\n    freq = {}\n\n    for n in arr:\n        if n in freq:\n            freq[n] += 1\n        else:\n            freq[n] = 1\n\n    lucky = -1\n    for key, value in freq.items():\n        if key == value:\n            lucky = max(lucky, key)\n\n    return lucky\n"
     },
     {
          "instruction": "Given an `m x n` binary matrix `mat`, _return the number of **submatrices** that have all ones_.\n\n",
          "input": "**Example 1:**\n\n**Input:** mat = \\[\\[1,0,1\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 13\n**Explanation:** \nThere are 6 rectangles of side 1x1.\nThere are 2 rectangles of side 1x2.\nThere are 3 rectangles of side 2x1.\nThere is 1 rectangle of side 2x2. \nThere is 1 rectangle of side 3x1.\nTotal number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[0,1,1,0\\],\\[0,1,1,1\\],\\[1,1,1,0\\]\\]\n**Output:** 24\n**Explanation:** \nThere are 8 rectangles of side 1x1.\nThere are 5 rectangles of side 1x2.\nThere are 2 rectangles of side 1x3. \nThere are 4 rectangles of side 2x1.\nThere are 2 rectangles of side 2x2. \nThere are 2 rectangles of side 3x1. \nThere is 1 rectangle of side 3x2. \nTotal number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.\n\n**Constraints:**\n\n*   `1 <= m, n <= 150`\n*   `mat[i][j]` is either `0` or `1`.",
          "output": "def numSubmat(mat: List[List[int]]) -> int:\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    ans = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if mat[i][j]:\n                dp[i][j] = 1 if j == 0 else dp[i][j-1] + 1\n                width = dp[i][j]\n                for k in range(i, -1, -1):\n                    width = min(width, dp[k][j])\n                    ans += width\n    \n    return ans\n"
     },
     {
          "instruction": "Given an array of integers `arr`, return _the number of subarrays with an **odd** sum_.\n\nSince the answer can be very large, return it modulo `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** arr = \\[1,3,5\\]\n**Output:** 4\n**Explanation:** All subarrays are \\[\\[1\\],\\[1,3\\],\\[1,3,5\\],\\[3\\],\\[3,5\\],\\[5\\]\\]\nAll sub-arrays sum are \\[1,4,9,3,8,5\\].\nOdd sums are \\[1,9,3,5\\] so the answer is 4.\n\n**Example 2:**\n\n**Input:** arr = \\[2,4,6\\]\n**Output:** 0\n**Explanation:** All subarrays are \\[\\[2\\],\\[2,4\\],\\[2,4,6\\],\\[4\\],\\[4,6\\],\\[6\\]\\]\nAll sub-arrays sum are \\[2,6,12,4,10,6\\].\nAll sub-arrays have even sum and the answer is 0.\n\n**Example 3:**\n\n**Input:** arr = \\[1,2,3,4,5,6,7\\]\n**Output:** 16\n\n**Constraints:**\n\n*   `1 <= arr.length <= 105`\n*   `1 <= arr[i] <= 100`",
          "output": "def stringMatching(words):\n    result = []\n    for word1 in words:\n        for word2 in words:\n            if word1 != word2 and word1 in word2:\n                result.append(word1)\n                break\n    return result\n"
     },
     {
          "instruction": "You are given a string `s`.\n\nA split is called **good** if you can split `s` into two non-empty strings `sleft` and `sright` where their concatenation is equal to `s` (i.e., `sleft + sright = s`) and the number of distinct letters in `sleft` and `sright` is the same.\n\nReturn _the number of **good splits** you can make in `s`_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aacaba \"\n**Output:** 2\n**Explanation:** There are 5 ways to split ` \"aacaba \"` and 2 of them are good. \n( \"a \",  \"acaba \") Left string and right string contains 1 and 3 different letters respectively.\n( \"aa \",  \"caba \") Left string and right string contains 1 and 3 different letters respectively.\n( \"aac \",  \"aba \") Left string and right string contains 2 and 2 different letters respectively (good split).\n( \"aaca \",  \"ba \") Left string and right string contains 2 and 2 different letters respectively (good split).\n( \"aacab \",  \"a \") Left string and right string contains 3 and 1 different letters respectively.\n\n**Example 2:**\n\n**Input:** s =  \"abcd \"\n**Output:** 1\n**Explanation:** Split the string as follows ( \"ab \",  \"cd \").\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only lowercase English letters.",
          "output": "def process_queries(queries, m):\n    nums = list(range(1, m+1))\n    result = []\n    for q in queries:\n        pos = nums.index(q)\n        result.append(pos)\n        del nums[pos]\n        nums.insert(0, q)\n    return result\n"
     },
     {
          "instruction": "You are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment each value by one.\n\nReturn _the minimum number of operations to form a_ `target` _array from_ `initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n",
          "input": "**Example 1:**\n\n**Input:** target = \\[1,2,3,2,1\\]\n**Output:** 3\n**Explanation:** We need at least 3 operations to form the target array from the initial array.\n\\[**0,0,0,0,0**\\] increment 1 from index 0 to 4 (inclusive).\n\\[1,**1,1,1**,1\\] increment 1 from index 1 to 3 (inclusive).\n\\[1,2,**2**,2,1\\] increment 1 at index 2.\n\\[1,2,3,2,1\\] target array is formed.\n\n**Example 2:**\n\n**Input:** target = \\[3,1,1,2\\]\n**Output:** 4\n**Explanation:** \\[**0,0,0,0**\\] -> \\[1,1,1,**1**\\] -> \\[**1**,1,1,2\\] -> \\[**2**,1,1,2\\] -> \\[3,1,1,2\\]\n\n**Example 3:**\n\n**Input:** target = \\[3,1,5,4,2\\]\n**Output:** 7\n**Explanation:** \\[**0,0,0,0,0**\\] -> \\[**1**,1,1,1,1\\] -> \\[**2**,1,1,1,1\\] -> \\[3,1,**1,1,1**\\] -> \\[3,1,**2,2**,2\\] -> \\[3,1,**3,3**,2\\] -> \\[3,1,**4**,4,2\\] -> \\[3,1,5,4,2\\].\n\n**Constraints:**\n\n*   `1 <= target.length <= 105`\n*   `1 <= target[i] <= 105`",
          "output": "def entityParser(text: str) -> str:\n    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)\n"
     },
     {
          "instruction": "[Run-length encoding](http://en.wikipedia.org/wiki/Run-length_encoding) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string `\"aabccc \"` we replace `\"aa \"` by `\"a2 \"` and replace `\"ccc \"` by `\"c3 \"`. Thus the compressed string becomes `\"a2bc3 \"`.\n\nNotice that in this problem, we are not adding `'1'` after single characters.\n\nGiven a string `s` and an integer `k`. You need to delete **at most** `k` characters from `s` such that the run-length encoded version of `s` has minimum length.\n\nFind the _minimum length of the run-length encoded version of_ `s` _after deleting at most_ `k` _characters_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aaabcccd \", k = 2\n**Output:** 4\n**Explanation:** Compressing s without deleting anything will give us  \"a3bc3d \" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s =  \"abcccd \" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be  \"a3c3 \" of length 4.\n\n**Example 2:**\n\n**Input:** s =  \"aabbaa \", k = 2\n**Output:** 2\n**Explanation:** If we delete both 'b' characters, the resulting compressed string would be  \"a4 \" of length 2.\n\n**Example 3:**\n\n**Input:** s =  \"aaaaaaaaaaa \", k = 0\n**Output:** 3\n**Explanation:** Since k is zero, we cannot delete anything. The compressed string is  \"a11 \" of length 3.\n\n**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `0 <= k <= s.length`\n*   `s` contains only lowercase English letters.",
          "output": "def number_ways(hats):\n    kMod = 1000000007\n    kMaxHats = 40\n\n    num_people = len(hats)\n    people_with_hat = [[] for _ in range(kMaxHats)]\n\n    for i in range(num_people):\n        for hat in hats[i]:\n            people_with_hat[hat - 1].append(i)\n\n    dp = [[0] * (kMaxHats + 1) for _ in range(1 << num_people)]\n    dp[0][0] = 1\n\n    for hat in range(kMaxHats):\n        for mask in reversed(range(1 << num_people)):\n            dp[mask][hat + 1] = (dp[mask][hat + 1] + dp[mask][hat]) % kMod\n            for person in people_with_hat[hat]:\n                if mask & (1 << person) == 0:\n                    dp[mask | (1 << person)][hat + 1] = (dp[mask | (1 << person)][hat + 1] + dp[mask][hat]) % kMod\n\n    return dp[(1 << num_people) - 1][kMaxHats]\n"
     },
     {
          "instruction": "You are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid path** is defined as follows:\n\n*   Choose array `nums1` or `nums2` to traverse (from index-0).\n*   Traverse the current array from left to right.\n*   If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible **valid paths**_. Since the answer may be too large, return it modulo `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[2,4,5,8,10\\], nums2 = \\[4,6,8,9\\]\n**Output:** 30\n**Explanation:** Valid paths:\n\\[2,4,5,8,10\\], \\[2,4,5,8,9\\], \\[2,4,6,8,9\\], \\[2,4,6,8,10\\],  (starting from nums1)\n\\[4,6,8,9\\], \\[4,5,8,10\\], \\[4,5,8,9\\], \\[4,6,8,10\\]    (starting from nums2)\nThe maximum is obtained with the path in green **\\[2,4,6,8,10\\]**.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,3,5,7,9\\], nums2 = \\[3,5,100\\]\n**Output:** 109\n**Explanation:** Maximum sum is obtained with the path **\\[1,3,5,100\\]**.\n\n**Example 3:**\n\n**Input:** nums1 = \\[1,2,3,4,5\\], nums2 = \\[6,7,8,9,10\\]\n**Output:** 40\n**Explanation:** There are no common elements between nums1 and nums2.\nMaximum sum is obtained with the path \\[6,7,8,9,10\\].\n\n**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 105`\n*   `1 <= nums1[i], nums2[i] <= 107`\n*   `nums1` and `nums2` are strictly increasing.",
          "output": "def maxScore(s):\n    left_zeros, right_ones, max_score = 0, s.count('1'), 0\n    for i in range(len(s) - 1):\n        if s[i] == '0': left_zeros += 1\n        else: right_ones -= 1\n        max_score = max(max_score, left_zeros + right_ones)\n    return max_score\n"
     },
     {
          "instruction": "Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible.\n\n**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.",
          "output": "def destCity(paths):\n    starting_cities = set()\n    \n    for path in paths:\n        starting_cities.add(path[0])\n\n    for path in paths:\n        if path[1] not in starting_cities:\n            return path[1]\n\n    return \"\"\n"
     },
     {
          "instruction": "There are `n` oranges in the kitchen and you decided to eat some of these oranges every day as follows:\n\n*   Eat one orange.\n*   If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges.\n*   If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges.\n\nYou can only choose one of the actions per day.\n\nGiven the integer `n`, return _the minimum number of days to eat_ `n` _oranges_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** You have 10 oranges.\nDay 1: Eat 1 orange,  10 - 1 = 9.  \nDay 2: Eat 6 oranges, 9 - 2\\*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\nDay 3: Eat 2 oranges, 3 - 2\\*(3/3) = 3 - 2 = 1. \nDay 4: Eat the last orange  1 - 1  = 0.\nYou need at least 4 days to eat the 10 oranges.\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 3\n**Explanation:** You have 6 oranges.\nDay 1: Eat 3 oranges, 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\nDay 2: Eat 2 oranges, 3 - 2\\*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\nDay 3: Eat the last orange  1 - 1  = 0.\nYou need at least 3 days to eat the 6 oranges.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 109`",
          "output": "def countTriplets(arr):\n    n = len(arr)\n    XOR = [0] * (n + 1)\n    \n    for i in range(n):\n        XOR[i+1] = XOR[i] ^ arr[i]\n    \n    count = 0\n    for i in range(n):\n        for k in range(i+1, n):\n            if XOR[i] == XOR[k+1]:\n                count += k-i\n    return count\n"
     },
     {
          "instruction": "You are given an array of **distinct** positive integers locations where `locations[i]` represents the position of city `i`. You are also given integers `start`, `finish` and `fuel` representing the starting city, ending city, and the initial amount of fuel you have, respectively.\n\nAt each step, if you are at city `i`, you can pick any city `j` such that `j != i` and `0 <= j < locations.length` and move to city `j`. Moving from city `i` to city `j` reduces the amount of fuel you have by `|locations[i] - locations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.\n\nNotice that `fuel` **cannot** become negative at any point in time, and that you are **allowed** to visit any city more than once (including `start` and `finish`).\n\nReturn _the count of all possible routes from_ `start` _to_ `finish`. Since the answer may be too large, return it modulo `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** locations = \\[2,3,6,8,4\\], start = 1, finish = 3, fuel = 5\n**Output:** 4\n**Explanation:** The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3\n\n**Example 2:**\n\n**Input:** locations = \\[4,3,1\\], start = 1, finish = 0, fuel = 6\n**Output:** 5\n**Explanation:** The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n\n**Example 3:**\n\n**Input:** locations = \\[5,2,1\\], start = 0, finish = 2, fuel = 3\n**Output:** 0\n**Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n\n**Constraints:**\n\n*   `2 <= locations.length <= 100`\n*   `1 <= locations[i] <= 109`\n*   All integers in `locations` are **distinct**.\n*   `0 <= start, finish < locations.length`\n*   `1 <= fuel <= 200`",
          "output": "def maxArea(h, w, horizontalCuts, verticalCuts):\n    horizontalCuts.sort()\n    verticalCuts.sort()\n\n    maxH = max(horizontalCuts[0], h - horizontalCuts[-1])\n    maxV = max(verticalCuts[0], w - verticalCuts[-1])\n\n    for i in range(1, len(horizontalCuts)):\n        maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i - 1])\n\n    for i in range(1, len(verticalCuts)):\n        maxV = max(maxV, verticalCuts[i] - verticalCuts[i - 1])\n\n    return (maxH * maxV) % (10**9 + 7)\n"
     },
     {
          "instruction": "There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game, Alice divides the row into **two non-empty rows** (i.e. left row and right row), then Bob calculates the value of each row which is the sum of the values of all the stones in this row. Bob throws away the row which has the maximum value, and Alice's score increases by the value of the remaining row. If the value of the two rows are equal, Bob lets Alice decide which row will be thrown away. The next round starts with the remaining row.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially **zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n",
          "input": "**Example 1:**\n\n**Input:** stoneValue = \\[6,2,3,4,5,5\\]\n**Output:** 18\n**Explanation:** In the first round, Alice divides the row to \\[6,2,3\\], \\[4,5,5\\]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\nIn the second round Alice divides the row to \\[6\\], \\[2,3\\]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\nThe last round Alice has only one choice to divide the row which is \\[2\\], \\[3\\]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n\n**Example 2:**\n\n**Input:** stoneValue = \\[7,7,7,7,7,7,7\\]\n**Output:** 28\n\n**Example 3:**\n\n**Input:** stoneValue = \\[4\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 500`\n*   `1 <= stoneValue[i] <= 106`",
          "output": "from math import acos, cos, sin, sqrt\n\ndef max_number_of_darts(darts, r):\n    n = len(darts)\n    max_darts = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)\n            if dist > 2.0 * r: continue\n\n            angle = acos(dist / (2.0 * r))\n            for k in range(2):\n                loc_angle = angle * (1 if k == 0 else -1)\n                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)\n                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)\n\n                cnt = 0\n                for l in range(n):\n                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)\n                    if new_dist <= r + 1e-5: cnt += 1\n\n                max_darts = max(max_darts, cnt)\n\n    return max_darts\n"
     },
     {
          "instruction": "We have `n` cities and `m` bi-directional `roads` where `roads[i] = [ai, bi]` connects city `ai` with city `bi`. Each city has a name consisting of exactly three upper-case English letters given in the string array `names`. Starting at any city `x`, you can reach any city `y` where `y != x` (i.e., the cities and the roads are forming an undirected connected graph).\n\nYou will be given a string array `targetPath`. You should find a path in the graph of the **same length** and with the **minimum edit distance** to `targetPath`.\n\nYou need to return _the order of the nodes in the path with the minimum edit distance_. The path should be of the same length of `targetPath` and should be valid (i.e., there should be a direct road between `ans[i]` and `ans[i + 1]`). If there are multiple answers return any one of them.\n\nThe **edit distance** is defined as follows:\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5, roads = \\[\\[0,2\\],\\[0,3\\],\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[2,4\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"DXB \", \"HND \"\\], targetPath = \\[ \"ATL \", \"DXB \", \"HND \", \"LAX \"\\]\n**Output:** \\[0,2,4,2\\]\n**Explanation:** \\[0,2,4,2\\], \\[0,3,0,2\\] and \\[0,3,1,2\\] are accepted answers.\n\\[0,2,4,2\\] is equivalent to \\[ \"ATL \", \"LAX \", \"HND \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\\[0,3,0,2\\] is equivalent to \\[ \"ATL \", \"DXB \", \"ATL \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\\[0,3,1,2\\] is equivalent to \\[ \"ATL \", \"DXB \", \"PEK \", \"LAX \"\\] which has edit distance = 1 with targetPath.\n\n**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,0\\],\\[2,0\\],\\[3,0\\],\\[2,1\\],\\[3,1\\],\\[3,2\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"DXB \"\\], targetPath = \\[ \"ABC \", \"DEF \", \"GHI \", \"JKL \", \"MNO \", \"PQR \", \"STU \", \"VWX \"\\]\n**Output:** \\[0,1,0,1,0,1,0,1\\]\n**Explanation:** Any path in this graph has edit distance = 8 with targetPath.\n\n**Example 3:**\n\n**Input:** n = 6, roads = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\], names = \\[ \"ATL \", \"PEK \", \"LAX \", \"ATL \", \"DXB \", \"HND \"\\], targetPath = \\[ \"ATL \", \"DXB \", \"HND \", \"DXB \", \"ATL \", \"LAX \", \"PEK \"\\]\n**Output:** \\[3,4,5,4,3,2,1\\]\n**Explanation:** \\[3,4,5,4,3,2,1\\] is the only path with edit distance = 0 with targetPath.\nIt's equivalent to \\[ \"ATL \", \"DXB \", \"HND \", \"DXB \", \"ATL \", \"LAX \", \"PEK \"\\]\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `m == roads.length`\n*   `n - 1 <= m <= (n * (n - 1) / 2)`\n*   `0 <= ai, bi <= n - 1`\n*   `ai != bi`\n*   The graph is guaranteed to be **connected** and each pair of nodes may have **at most one** direct road.\n*   `names.length == n`\n*   `names[i].length == 3`\n*   `names[i]` consists of upper-case English letters.\n*   There can be two cities with **the same** name.\n*   `1 <= targetPath.length <= 100`\n*   `targetPath[i].length == 3`\n*   `targetPath[i]` consists of upper-case English letters.\n\n**Follow up:** If each node can be visited only once in the path, What should you change in your solution?",
          "output": "def kLengthApart(nums, k):\n    last_one = -1\n    for i, num in enumerate(nums):\n        if num == 1:\n            if last_one != -1 and i - last_one <= k:\n                return False\n            last_one = i\n    return True\n"
     },
     {
          "instruction": "Given an array of integers `nums`, find the maximum length of a subarray where the product of all its elements is positive.\n\nA subarray of an array is a consecutive sequence of zero or more values taken out of that array.\n\nReturn _the maximum length of a subarray with positive product_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,-2,-3,4\\]\n**Output:** 4\n**Explanation:** The array nums already has a positive product of 24.\n\n**Example 2:**\n\n**Input:** nums = \\[0,1,-2,-3,-4\\]\n**Output:** 3\n**Explanation:** The longest subarray with positive product is \\[1,-2,-3\\] which has a product of 6.\nNotice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\n\n**Example 3:**\n\n**Input:** nums = \\[-1,-2,-3,0,1\\]\n**Output:** 2\n**Explanation:** The longest subarray with positive product is \\[-1,-2\\] or \\[-2,-3\\].\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
          "output": "def max_vowels(s, k):\n    max_count = count = 0\n    for i, c in enumerate(s):\n        count += int(c in 'aeiou')\n        if i >= k:\n            count -= int(s[i - k] in 'aeiou')\n        max_count = max(max_count, count)\n    return max_count\n"
     },
     {
          "instruction": "Given an array `nums` that represents a permutation of integers from `1` to `n`. We are going to construct a binary search tree (BST) by inserting the elements of `nums` in order into an initially empty BST. Find the number of different ways to reorder `nums` so that the constructed BST is identical to that formed from the original array `nums`.\n\n*   For example, given `nums = [2,1,3]`, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array `[2,3,1]` also yields the same BST but `[3,2,1]` yields a different BST.\n\nReturn _the number of ways to reorder_ `nums` _such that the BST formed is identical to the original BST formed from_ `nums`.\n\nSince the answer may be very large, **return it modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,1,3\\]\n**Output:** 1\n**Explanation:** We can reorder nums to be \\[2,3,1\\] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 5\n**Explanation:** The following 5 arrays will yield the same BST: \n\\[3,1,2,4,5\\]\n\\[3,1,4,2,5\\]\n\\[3,1,4,5,2\\]\n\\[3,4,1,2,5\\]\n\\[3,4,1,5,2\\]\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** There are no other orderings of nums that will yield the same BST.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= nums.length`\n*   All integers in `nums` are **distinct**.",
          "output": "def maxDotProduct(nums1, nums2):\n    n, m = len(nums1), len(nums2)\n    dp = [[float('-inf') for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + nums1[i - 1] * nums2[j - 1], nums1[i - 1] * nums2[j - 1])\n    return dp[n][m]\n"
     },
     {
          "instruction": "Alice has `n` balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.\n\nAlice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.\n\nReturn _the **minimum time** Bob needs to make the rope **colorful**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** colors =  \"abaac \", neededTime = \\[1,2,3,4,5\\]\n**Output:** 3\n**Explanation:** In the above image, 'a' is blue, 'b' is red, and 'c' is green.\nBob can remove the blue balloon at index 2. This takes 3 seconds.\nThere are no longer two consecutive balloons of the same color. Total time = 3.\n\n**Example 2:**\n\n**Input:** colors =  \"abc \", neededTime = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** The rope is already colorful. Bob does not need to remove any balloons from the rope.\n\n**Example 3:**\n\n**Input:** colors =  \"aabaa \", neededTime = \\[1,2,3,4,1\\]\n**Output:** 2\n**Explanation:** Bob will remove the ballons at indices 0 and 4. Each ballon takes 1 second to remove.\nThere are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.\n\n**Constraints:**\n\n*   `n == colors.length == neededTime.length`\n*   `1 <= n <= 105`\n*   `1 <= neededTime[i] <= 104`\n*   `colors` contains only lowercase English letters.",
          "output": "def minTime(colors: str, neededTime: List[int]) -> int:\n    res, prev = 0, -1\n    for i in range(len(colors) - 1):\n        if colors[i] == colors[i + 1]:\n            if prev == -1 or neededTime[i] < neededTime[prev]:\n                prev = i\n            if neededTime[i + 1] < neededTime[prev]:\n                prev = i + 1\n            res += neededTime[prev]\n            neededTime[prev] = 1000000\n            prev = -1\n    return res\n"
     },
     {
          "instruction": "You are given a `m x n` matrix `grid`. Initially, you are located at the top-left corner `(0, 0)`, and in each step, you can only **move right or down** in the matrix.\n\nAmong all possible paths starting from the top-left corner `(0, 0)` and ending in the bottom-right corner `(m - 1, n - 1)`, find the path with the **maximum non-negative product**. The product of a path is the product of all integers in the grid cells visited along the path.\n\nReturn the _maximum non-negative product **modulo**_ `109 + 7`. _If the maximum product is **negative**, return_ `-1`.\n\nNotice that the modulo is performed after getting the maximum product.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[-1,-2,-3\\],\\[-2,-3,-3\\],\\[-3,-3,-2\\]\\]\n**Output:** -1\n**Explanation:** It is not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,-2,1\\],\\[1,-2,1\\],\\[3,-4,1\\]\\]\n**Output:** 8\n**Explanation:** Maximum non-negative product is shown (1 \\* 1 \\* -2 \\* -4 \\* 1 = 8).\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,3\\],\\[0,-4\\]\\]\n**Output:** 0\n**Explanation:** Maximum non-negative product is shown (1 \\* 0 \\* -4 = 0).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 15`\n*   `-4 <= grid[i][j] <= 4`",
          "output": "def maxProductPath(self, grid: List[List[int]]) -> int:\n    m, n, mod = len(grid), len(grid[0]), 10**9 + 7\n    dp = [[[0, 0] for _ in range(n)] for _ in range(m)]\n    dp[0][0] = [grid[0][0], grid[0][0]]\n    for i in range(1, m):\n        dp[i][0] = [grid[i][0] * dp[i - 1][0][0], grid[i][0] * dp[i - 1][0][0]]\n    for j in range(1, n):\n        dp[0][j] = [grid[0][j] * dp[0][j - 1][0], grid[0][j] * dp[0][j - 1][0]]\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] < 0:\n                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])\n                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])\n            else:\n                dp[i][j][0] = min(grid[i][j] * dp[i - 1][j][0], grid[i][j] * dp[i][j - 1][0])\n                dp[i][j][1] = max(grid[i][j] * dp[i - 1][j][1], grid[i][j] * dp[i][j - 1][1])\n    return -1 if dp[-1][-1][1] < 0 else dp[-1][-1][1] % mod\n"
     },
     {
          "instruction": "You are given two groups of points where the first group has `size1` points, the second group has `size2` points, and `size1 >= size2`.\n\nThe `cost` of the connection between any two points are given in an `size1 x size2` matrix where `cost[i][j]` is the cost of connecting point `i` of the first group and point `j` of the second group. The groups are connected if **each point in both groups is connected to one or more points in the opposite group**. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.\n\nReturn _the minimum cost it takes to connect the two groups_.\n\n",
          "input": "**Example 1:**\n\n**Input:** cost = \\[\\[15, 96\\], \\[36, 2\\]\\]\n**Output:** 17\n**Explanation**: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.\n\n**Example 2:**\n\n**Input:** cost = \\[\\[1, 3, 5\\], \\[4, 1, 1\\], \\[1, 5, 3\\]\\]\n**Output:** 4\n**Explanation**: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n\n**Example 3:**\n\n**Input:** cost = \\[\\[2, 5, 1\\], \\[3, 4, 7\\], \\[8, 1, 2\\], \\[6, 2, 4\\], \\[3, 8, 8\\]\\]\n**Output:** 10\n\n**Constraints:**\n\n*   `size1 == cost.length`\n*   `size2 == cost[i].length`\n*   `1 <= size1, size2 <= 12`\n*   `size1 >= size2`\n*   `0 <= cost[i][j] <= 100`",
          "output": "def connectTwoGroups(cost):\n    size1, size2 = len(cost), len(cost[0])\n    min_cost = [float('inf')] * size2\n\n    for i in range(size1):\n        for j in range(size2):\n            min_cost[j] = min(min_cost[j], cost[i][j])\n\n    total_cost = 0\n    for i in range(size1):\n        total_cost += min(cost[i])\n\n    for j in range(size2):\n        total_cost += min_cost[j]\n\n    return total_cost\n"
     },
     {
          "instruction": "Given `n` points on a 1-D plane, where the `ith` point (from `0` to `n-1`) is at `x = i`, find the number of ways we can draw **exactly** `k` **non-overlapping** line segments such that each segment covers two or more points. The endpoints of each segment must have **integral coordinates**. The `k` line segments **do not** have to cover all `n` points, and they are **allowed** to share endpoints.\n\nReturn _the number of ways we can draw_ `k` _non-overlapping line segments__._ Since this number can be huge, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 4, k = 2\n**Output:** 5\n**Explanation:** The two line segments are shown in red and blue.\nThe image above shows the 5 different ways {(0,2),(2,3)}, {(0,1),(1,3)}, {(0,1),(2,3)}, {(1,2),(2,3)}, {(0,1),(1,2)}.\n\n**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 3\n**Explanation:** The 3 ways are {(0,1)}, {(0,2)}, {(1,2)}.\n\n**Example 3:**\n\n**Input:** n = 30, k = 7\n**Output:** 796297179\n**Explanation:** The total number of possible ways to draw 7 line segments is 3796297200. Taking this number modulo 109 + 7 gives us 796297179.\n\n**Constraints:**\n\n*   `2 <= n <= 1000`\n*   `1 <= k <= n-1`",
          "output": "def numSubseq(nums, target):\n    nums.sort()\n    n = len(nums)\n    mod = 10**9 + 7\n\n    power = [1] * n\n    for i in range(1, n):\n        power[i] = (power[i - 1] * 2) % mod\n\n    ans = 0\n    r = n\n    for l in range(n):\n        while r > l and nums[l] + nums[r - 1] > target:\n            r -= 1\n\n        ans = (ans + power[r - l]) % mod\n\n    return ans\n"
     },
     {
          "instruction": "A game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n*   Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n*   Floors are represented by the character `'.'` and can be walked on.\n*   Walls are represented by the character `'#'` and cannot be walked on.\n*   Food is represented by the character `'F'` and can be walked on.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n*   Mouse **moves first**, then they take turns to move.\n*   During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n*   `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n*   Staying in the same position is allowed.\n*   Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n*   If Cat occupies the same position as Mouse, Cat wins.\n*   If Cat reaches the food first, Cat wins.\n*   If Mouse reaches the food first, Mouse wins.\n*   If Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` _if Mouse can win the game if both Cat and Mouse play optimally, otherwise return_ `false`.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[ \"####F \", \"#C... \", \"M.... \"\\], catJump = 1, mouseJump = 2\n**Output:** true\n**Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 4\n**Output:** true\n\n**Example 3:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 3\n**Output:** false\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols = grid[i].length`\n*   `1 <= rows, cols <= 8`\n*   `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n*   `1 <= catJump, mouseJump <= 8`",
          "output": "class Fancy:\n    def __init__(self):\n        self.sequence = []\n\n    def append(self, val):\n        self.sequence.append(val)\n\n    def addAll(self, inc):\n        self.sequence = [num + inc for num in self.sequence]\n\n    def multAll(self, m):\n        self.sequence = [num * m for num in self.sequence]\n\n    def getIndex(self, idx):\n        if idx >= len(self.sequence):\n            return -1\n        return self.sequence[idx]\n"
     },
     {
          "instruction": "Given an integer `n`, you must transform it into `0` using the following operations any number of times:\n\n*   Change the rightmost (`0th`) bit in the binary representation of `n`.\n*   Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`.\n\nReturn _the minimum number of operations to transform_ `n` _into_ `0`_._\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** The binary representation of 3 is  \"11 \".\n \"11 \" ->  \"01 \" with the 2nd operation since the 0th bit is 1.\n \"01 \" ->  \"00 \" with the 1st operation.\n\n**Example 2:**\n\n**Input:** n = 6\n**Output:** 4\n**Explanation:** The binary representation of 6 is  \"110 \".\n \"110 \" ->  \"010 \" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n \"010 \" ->  \"011 \" with the 1st operation.\n \"011 \" ->  \"001 \" with the 2nd operation since the 0th bit is 1.\n \"001 \" ->  \"000 \" with the 1st operation.\n\n**Constraints:**\n\n*   `0 <= n <= 109`",
          "output": "def get_folder_names(names):\n    name_count = {}\n    ans = []\n\n    for name in names:\n        if name not in name_count:\n            ans.append(name)\n            name_count[name] = 1\n        else:\n            k = name_count[name]\n            new_name = f\"{name}({k})\"\n            while new_name in name_count:\n                k += 1\n                new_name = f\"{name}({k})\"\n            ans.append(new_name)\n            name_count[new_name] = 1\n            name_count[name] = k + 1\n\n    return ans\n"
     },
     {
          "instruction": "There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.",
          "output": "def winnerSquareGame(n: int) -> bool:\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]\n"
     },
     {
          "instruction": "Given two strings `s` and `t`, find the number of ways you can choose a non-empty substring of `s` and replace a **single character** by a different character such that the resulting substring is a substring of `t`. In other words, find the number of substrings in `s` that differ from some substring in `t` by **exactly** one character.\n\nFor example, the underlined substrings in `\"computer \"` and `\"computation \"` only differ by the `'e'`/`'a'`, so this is a valid way.\n\nReturn _the number of substrings that satisfy the condition above._\n\nA **substring** is a contiguous sequence of characters within a string.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aba \", t =  \"baba \"\n**Output:** 6\n**Explanation:** The following are the pairs of substrings from s and t that differ by exactly 1 character:\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\n( \"aba \",  \"baba \")\nThe underlined portions are the substrings that are chosen from s and t.\n\n\u00e2\u20ac\u2039\u00e2\u20ac\u2039**Example 2:**\n\n**Input:** s =  \"ab \", t =  \"bb \"\n**Output:** 3\n**Explanation:** The following are the pairs of substrings from s and t that differ by 1 character:\n( \"ab \",  \"bb \")\n( \"ab \",  \"bb \")\n( \"ab \",  \"bb \")\n\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039The underlined portions are the substrings that are chosen from s and t.\n\n**Constraints:**\n\n*   `1 <= s.length, t.length <= 100`\n*   `s` and `t` consist of lowercase English letters only.",
          "output": "def get_min_dist_sum(positions: List[List[int]]) -> float:\n    x, y = 0, 0\n    n = len(positions)\n    for pos in positions:\n        x += pos[0]\n        y += pos[1]\n    x /= n\n    y /= n\n    return x\n"
     },
     {
          "instruction": "You are given a list of strings of the **same length** `words` and a string `target`.\n\nYour task is to form `target` using the given `words` under the following rules:\n\n*   `target` should be formed from left to right.\n*   To form the `ith` character (**0-indexed**) of `target`, you can choose the `kth` character of the `jth` string in `words` if `target[i] = words[j][k]`.\n*   Once you use the `kth` character of the `jth` string of `words`, you **can no longer** use the `xth` character of any string in `words` where `x <= k`. In other words, all characters to the left of or at index `k` become unusuable for every string.\n*   Repeat the process until you form the string `target`.\n\n**Notice** that you can use **multiple characters** from the **same string** in `words` provided the conditions above are met.\n\nReturn _the number of ways to form `target` from `words`_. Since the answer may be too large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** words = \\[ \"acca \", \"bbbb \", \"caca \"\\], target =  \"aba \"\n**Output:** 6\n**Explanation:** There are 6 ways to form target.\n \"aba \" -> index 0 ( \"acca \"), index 1 ( \"bbbb \"), index 3 ( \"caca \")\n \"aba \" -> index 0 ( \"acca \"), index 2 ( \"bbbb \"), index 3 ( \"caca \")\n \"aba \" -> index 0 ( \"acca \"), index 1 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 0 ( \"acca \"), index 2 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 1 ( \"caca \"), index 2 ( \"bbbb \"), index 3 ( \"acca \")\n \"aba \" -> index 1 ( \"caca \"), index 2 ( \"bbbb \"), index 3 ( \"caca \")\n\n**Example 2:**\n\n**Input:** words = \\[ \"abba \", \"baab \"\\], target =  \"bab \"\n**Output:** 4\n**Explanation:** There are 4 ways to form target.\n \"bab \" -> index 0 ( \"baab \"), index 1 ( \"baab \"), index 2 ( \"abba \")\n \"bab \" -> index 0 ( \"baab \"), index 1 ( \"baab \"), index 3 ( \"baab \")\n \"bab \" -> index 0 ( \"baab \"), index 2 ( \"baab \"), index 3 ( \"baab \")\n \"bab \" -> index 1 ( \"abba \"), index 2 ( \"baab \"), index 3 ( \"baab \")\n\n**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   All strings in `words` have the same length.\n*   `1 <= target.length <= 1000`\n*   `words[i]` and `target` contain only lowercase English letters.",
          "output": "def numWays(words, target):\n    n = len(words)\n    m = len(target)\n    count = [[0] * 26 for _ in range(n)]\n    dp = [[0] * n for _ in range(m)]\n    mod = 1000000007\n\n    for i, word in enumerate(words):\n        for c in word:\n            count[i][ord(c) - ord('a')] += 1\n\n    for i in range(n):\n        dp[0][i] = count[i][ord(target[0]) - ord('a')]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(n):\n                dp[i][j] = (dp[i][j] + dp[i-1][k] * count[j][ord(target[i]) - ord('a')]) % mod\n\n    return sum(dp[m-1]) % mod\n"
     },
     {
          "instruction": "You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the **sum** of scores of all the players in the team.\n\nHowever, the basketball team is not allowed to have **conflicts**. A **conflict** exists if a younger player has a **strictly higher** score than an older player. A conflict does **not** occur between players of the same age.\n\nGiven two lists, `scores` and `ages`, where each `scores[i]` and `ages[i]` represents the score and age of the `ith` player, respectively, return _the highest overall score of all possible basketball teams_.\n\n",
          "input": "**Example 1:**\n\n**Input:** scores = \\[1,3,5,10,15\\], ages = \\[1,2,3,4,5\\]\n**Output:** 34\n**Explanation:** You can choose all the players.\n\n**Example 2:**\n\n**Input:** scores = \\[4,5,6,5\\], ages = \\[2,1,2,1\\]\n**Output:** 16\n**Explanation:** It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n\n**Example 3:**\n\n**Input:** scores = \\[1,2,3,5\\], ages = \\[8,9,10,1\\]\n**Output:** 6\n**Explanation:** It is best to choose the first 3 players. \n\n**Constraints:**\n\n*   `1 <= scores.length, ages.length <= 1000`\n*   `scores.length == ages.length`\n*   `1 <= scores[i] <= 106`\n*   `1 <= ages[i] <= 1000`",
          "output": "def can_make_arithmetic_progression(arr):\n    arr.sort()\n    difference = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i - 1] != difference:\n            return False\n    return True\n"
     },
     {
          "instruction": "You are given a string `s` consisting only of characters `'a'` and `'b'`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039.\n\nYou can delete any number of characters in `s` to make `s` **balanced**. `s` is **balanced** if there is no pair of indices `(i,j)` such that `i < j` and `s[i] = 'b'` and `s[j]= 'a'`.\n\nReturn _the **minimum** number of deletions needed to make_ `s` _**balanced**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"aababbab \"\n**Output:** 2\n**Explanation:** You can either:\nDelete the characters at 0-indexed positions 2 and 6 ( \"aababbab \" ->  \"aaabbb \"), or\nDelete the characters at 0-indexed positions 3 and 6 ( \"aababbab \" ->  \"aabbbb \").\n\n**Example 2:**\n\n**Input:** s =  \"bbaaaaabb \"\n**Output:** 2\n**Explanation:** The only solution is to delete the first two characters.\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is `'a'` or `'b'`\u00e2\u20ac\u2039\u00e2\u20ac\u2039.",
          "output": "def dfs(root, distance, depths):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        depths.append(0)\n        return 1\n    left, right = [], []\n    count = dfs(root.left, distance, left) + dfs(root.right, distance, right)\n    for l in left:\n        for r in right:\n            if l + r + 2 <= distance:\n                count += 1\n    depths.extend(l + 1 for l in left)\n    depths.extend(r + 1 for r in right)\n    return count\n\ndef countPairs(root, distance):\n    depths = []\n    return dfs(root, distance, depths)\n"
     },
     {
          "instruction": "A certain bug's home is on the x-axis at position `x`. Help them get there from position `0`.\n\nThe bug jumps according to the following rules:\n\n*   It can jump exactly `a` positions **forward** (to the right).\n*   It can jump exactly `b` positions **backward** (to the left).\n*   It cannot jump backward twice in a row.\n*   It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward **beyond** its home, but it **cannot jump** to positions numbered with **negative** integers.\n\nGiven an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `-1.`\n\n",
          "input": "**Example 1:**\n\n**Input:** forbidden = \\[14,4,18,1,15\\], a = 3, b = 15, x = 9\n**Output:** 3\n**Explanation:** 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n\n**Example 2:**\n\n**Input:** forbidden = \\[8,3,16,6,12,20\\], a = 15, b = 13, x = 11\n**Output:** -1\n\n**Example 3:**\n\n**Input:** forbidden = \\[1,6,2,14,5,17,4\\], a = 16, b = 9, x = 7\n**Output:** 2\n**Explanation:** One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n\n**Constraints:**\n\n*   `1 <= forbidden.length <= 1000`\n*   `1 <= a, b, forbidden[i] <= 2000`\n*   `0 <= x <= 2000`\n*   All the elements in `forbidden` are distinct.\n*   Position `x` is not forbidden.",
          "output": "from collections import deque\n\ndef minimumJumps(forbidden, a, b, x):\n    forbidden_positions = set(forbidden)\n    q = deque([(0, 0, 0)])\n    visited = {(0, 0)}\n    while q:\n        pos, steps, backward = q.popleft()\n        if pos == x:\n            return steps\n        forward_pos = pos + a\n        backward_pos = pos - b\n        if forward_pos <= 6000 and forward_pos not in forbidden_positions and (forward_pos, 0) not in visited:\n            visited.add((forward_pos, 0))\n            q.append((forward_pos, steps + 1, 0))\n        if backward == 0 and backward_pos > 0 and backward_pos not in forbidden_positions and (backward_pos, 1) not in visited:\n            visited.add((backward_pos, 1))\n            q.append((backward_pos, steps + 1, 1))\n    return -1\n"
     },
     {
          "instruction": "You are given an array of `n` integers, `nums`, where there are at most `50` unique values in the array. You are also given an array of `m` customer order quantities, `quantity`, where `quantity[i]` is the amount of integers the `ith` customer ordered. Determine if it is possible to distribute `nums` such that:\n\n*   The `ith` customer gets **exactly** `quantity[i]` integers,\n*   The integers the `ith` customer gets are **all equal**, and\n*   Every customer is satisfied.\n\nReturn `true` _if it is possible to distribute_ `nums` _according to the above conditions_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\], quantity = \\[2\\]\n**Output:** false\n**Explanation:** The 0th customer cannot be given two different integers.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,3,3\\], quantity = \\[2\\]\n**Output:** true\n**Explanation:** The 0th customer is given \\[3,3\\]. The integers \\[1,2\\] are not used.\n\n**Example 3:**\n\n**Input:** nums = \\[1,1,2,2\\], quantity = \\[2,2\\]\n**Output:** true\n**Explanation:** The 0th customer is given \\[1,1\\], and the 1st customer is given \\[2,2\\].\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 1000`\n*   `m == quantity.length`\n*   `1 <= m <= 10`\n*   `1 <= quantity[i] <= 105`\n*   There are at most `50` unique values in `nums`.",
          "output": "from collections import Counter\n\ndef canDistribute(nums, quantity):\n    counts = Counter(nums)\n    values = list(counts.values())\n    quantity.sort(reverse=True)\n\n    def dfs(index, values):\n        if index == len(quantity):\n            return True\n        for i in range(len(values)):\n            if values[i] >= quantity[index]:\n                values[i] -= quantity[index]\n                if dfs(index + 1, values):\n                    return True\n                values[i] += quantity[index]\n        return False\n\n    return dfs(0, values)\n"
     },
     {
          "instruction": "Given an integer `n`, return _the number of strings of length_ `n` _that consist only of vowels (_`a`_,_ `e`_,_ `i`_,_ `o`_,_ `u`_) and are **lexicographically sorted**._\n\nA string `s` is **lexicographically sorted** if for all valid `i`, `s[i]` is the same as or comes before `s[i+1]` in the alphabet.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 1\n**Output:** 5\n**Explanation:** The 5 sorted strings that consist of vowels only are `[ \"a \", \"e \", \"i \", \"o \", \"u \"].`\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 15\n**Explanation:** The 15 sorted strings that consist of vowels only are\n\\[ \"aa \", \"ae \", \"ai \", \"ao \", \"au \", \"ee \", \"ei \", \"eo \", \"eu \", \"ii \", \"io \", \"iu \", \"oo \", \"ou \", \"uu \"\\].\nNote that  \"ea \" is not a valid string since 'e' comes after 'a' in the alphabet.\n\n**Example 3:**\n\n**Input:** n = 33\n**Output:** 66045\n\n**Constraints:**\n\n*   `1 <= n <= 50`",
          "output": "def countVowelStrings(n: int) -> int:\n    dp = [1, 1, 1, 1, 1]\n    for i in range(2, n + 1):\n        for j in range(3, -1, -1):\n            dp[j] = dp[j] + dp[j + 1]\n    return sum(dp)\n"
     },
     {
          "instruction": "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `nums`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039, return _the **minimum** number of elements to remove to make_ `nums_\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039_` _a **mountain array**._\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,3,1\\]\n**Output:** 0\n**Explanation:** The array itself is a mountain array so we do not need to remove any elements.\n\n**Example 2:**\n\n**Input:** nums = \\[2,1,1,5,6,2,3,1\\]\n**Output:** 3\n**Explanation:** One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \\[1,5,6,3,1\\].\n\n**Constraints:**\n\n*   `3 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 109`\n*   It is guaranteed that you can make a mountain array out of `nums`.",
          "output": "def minimumMountainRemovals(nums):\n    n = len(nums)\n    left, right = [0] * n, [0] * n\n    for i in range(1, n):\n        left[i] = left[i - 1] + int(nums[i] > nums[i - 1])\n        right[n - i - 1] = right[n - i] + int(nums[n - i - 1] > nums[n - i])\n    ans = n - 3\n    for i in range(1, n - 1):\n        ans = min(ans, n - 1 - left[i] - right[i])\n    return ans\n"
     },
     {
          "instruction": "You are given an integer `n`. A **0-indexed** integer array `nums` of length `n + 1` is generated in the following way:\n\n*   `nums[0] = 0`\n*   `nums[1] = 1`\n*   `nums[2 * i] = nums[i]` when `2 <= 2 * i <= n`\n*   `nums[2 * i + 1] = nums[i] + nums[i + 1]` when `2 <= 2 * i + 1 <= n`\n\nReturn _the **maximum** integer in the array_ `nums`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 7\n**Output:** 3\n**Explanation:** According to the given rules:\n  nums\\[0\\] = 0\n  nums\\[1\\] = 1\n  nums\\[(1 \\* 2) = 2\\] = nums\\[1\\] = 1\n  nums\\[(1 \\* 2) + 1 = 3\\] = nums\\[1\\] + nums\\[2\\] = 1 + 1 = 2\n  nums\\[(2 \\* 2) = 4\\] = nums\\[2\\] = 1\n  nums\\[(2 \\* 2) + 1 = 5\\] = nums\\[2\\] + nums\\[3\\] = 1 + 2 = 3\n  nums\\[(3 \\* 2) = 6\\] = nums\\[3\\] = 2\n  nums\\[(3 \\* 2) + 1 = 7\\] = nums\\[3\\] + nums\\[4\\] = 2 + 1 = 3\nHence, nums = \\[0,1,1,2,1,3,2,3\\], and the maximum is max(0,1,1,2,1,3,2,3) = 3.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** According to the given rules, nums = \\[0,1,1\\]. The maximum is max(0,1,1) = 1.\n\n**Example 3:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** According to the given rules, nums = \\[0,1,1,2\\]. The maximum is max(0,1,1,2) = 2.\n\n**Constraints:**\n\n*   `0 <= n <= 100`",
          "output": "def findKthPositive(arr, k):\n    i, num = 0, 1\n    while k > 0:\n        if i < len(arr) and arr[i] == num:\n            i += 1\n        else:\n            k -= 1\n        num += 1\n    return num - 1\n"
     },
     {
          "instruction": "You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.\n\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you **do not** have to have all the people living in the grid.\n\nThe **happiness** of each person is calculated as follows:\n\n*   Introverts **start** with `120` happiness and **lose** `30` happiness for each neighbor (introvert or extrovert).\n*   Extroverts **start** with `40` happiness and **gain** `20` happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\n\nThe **grid happiness** is the **sum** of each person's happiness. Return _the **maximum possible grid happiness**._\n\n",
          "input": "**Example 1:**\n\n**Input:** m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\n**Output:** 240\n**Explanation:** Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 \\* 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 \\* 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 \\* 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.\n\n**Example 2:**\n\n**Input:** m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\n**Output:** 260\n**Explanation:** Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 \\* 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 \\* 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 \\* 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.\n\n**Example 3:**\n\n**Input:** m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\n**Output:** 240\n\n**Constraints:**\n\n*   `1 <= m, n <= 5`\n*   `0 <= introvertsCount, extrovertsCount <= min(m * n, 6)`",
          "output": "def maxSum(nums1, nums2):\n    mod = 10**9 + 7\n    m, n = len(nums1), len(nums2)\n    dp1, dp2 = [0] * (m + 1), [0] * (n + 1)\n    i, j = m - 1, n - 1\n    while i >= 0 or j >= 0:\n        a = dp1[i] + nums1[i] if i >= 0 else float('-inf')\n        b = dp2[j] + nums2[j] if j >= 0 else float('-inf')\n        seen = set()\n        if a > b:\n            dp1[i] = a % mod\n            i -= 1\n            seen.add(nums1[i + 1])\n        else:\n            dp2[j] = b % mod\n            j -= 1\n            seen.add(nums2[j + 1])\n    return max(dp1[0], dp2[0]) % mod\n"
     },
     {
          "instruction": "You are given an integer array `nums`. You can choose **exactly one** index (**0-indexed**) and remove the element. Notice that the index of the elements may change after the removal.\n\nFor example, if `nums = [6,1,7,4,1]`:\n\n*   Choosing to remove index `1` results in `nums = [6,7,4,1]`.\n*   Choosing to remove index `2` results in `nums = [6,1,4,1]`.\n*   Choosing to remove index `4` results in `nums = [6,1,7,4]`.\n\nAn array is **fair** if the sum of the odd-indexed values equals the sum of the even-indexed values.\n\nReturn the _**number** of indices that you could choose such that after the removal,_ `nums` _is **fair**._\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,1,6,4\\]\n**Output:** 1\n**Explanation:**\nRemove index 0: \\[1,6,4\\] -> Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.\nRemove index 1: \\[2,6,4\\] -> Even sum: 2 + 4 = 6. Odd sum: 6. Fair.\nRemove index 2: \\[2,1,4\\] -> Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.\nRemove index 3: \\[2,1,6\\] -> Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.\nThere is 1 index that you can remove to make nums fair.\n\n**Example 2:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** 3\n**Explanation:** You can remove any index and the remaining array is fair.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 0\n**Explanation:** You cannot make a fair array after removing any index.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`",
          "output": "def numberOfFairs(nums):\n    even_sum = sum(nums[0::2])\n    odd_sum = sum(nums[1::2])\n    l_even = l_odd = count = 0\n    for i, num in enumerate(nums):\n        if i % 2 == 0:\n            even_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_even += num\n        else:\n            odd_sum -= num\n            if l_even + odd_sum == l_odd + even_sum:\n                count += 1\n            l_odd += num\n    return count\n"
     },
     {
          "instruction": "You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a **limit** on the **number of boxes** and the **total weight** that it can carry.\n\nYou are given an array `boxes`, where `boxes[i] = [ports\u00e2\u20ac\u2039\u00e2\u20ac\u2039i\u00e2\u20ac\u2039, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.\n\n*   `ports\u00e2\u20ac\u2039\u00e2\u20ac\u2039i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n*   `portsCount` is the number of ports.\n*   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered **in the order they are given**. The ship will follow these steps:\n\n*   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.\n*   For each loaded box **in order**, the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no **trip** is needed, and the box can immediately be delivered.\n*   The ship then makes a return **trip** to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn _the **minimum** number of **trips** the ship needs to make to deliver all boxes to their respective ports._\n\n",
          "input": "**Example 1:**\n\n**Input:** boxes = \\[\\[1,1\\],\\[2,1\\],\\[1,1\\]\\], portsCount = 2, maxBoxes = 3, maxWeight = 3\n**Output:** 4\n**Explanation:** The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n\n**Example 2:**\n\n**Input:** boxes = \\[\\[1,2\\],\\[3,3\\],\\[3,1\\],\\[3,1\\],\\[2,4\\]\\], portsCount = 3, maxBoxes = 3, maxWeight = 6\n**Output:** 6\n**Explanation:** The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Example 3:**\n\n**Input:** boxes = \\[\\[1,4\\],\\[1,2\\],\\[2,1\\],\\[2,1\\],\\[3,2\\],\\[3,4\\]\\], portsCount = 3, maxBoxes = 6, maxWeight = 7\n**Output:** 6\n**Explanation:** The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n\n**Constraints:**\n\n*   `1 <= boxes.length <= 105`\n*   `1 <= portsCount, maxBoxes, maxWeight <= 105`\n*   `1 <= ports\u00e2\u20ac\u2039\u00e2\u20ac\u2039i <= portsCount`\n*   `1 <= weightsi <= maxWeight`",
          "output": "def min_trips(boxes, portsCount, maxBoxes, maxWeight):\n    trips = 0\n    idx = 0\n    n = len(boxes)\n    while idx < n:\n        curr_limit = maxWeight\n        prev_port = 0\n        count = 0\n        while count < maxBoxes and idx < n:\n            if boxes[idx][1] <= curr_limit:\n                if prev_port != boxes[idx][0]:\n                    prev_port = boxes[idx][0]\n                    trips += 1\n                curr_limit -= boxes[idx][1]\n                count += 1\n                idx += 1\n            else:\n                break\n        trips += 1\n    return trips\n"
     },
     {
          "instruction": "Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, they can **remove** either the leftmost stone or the rightmost stone from the row and receive points equal to the **sum** of the remaining stones' values in the row. The winner is the one with the higher score when there are no stones left to remove.\n\nBob found that he will always lose this game (poor Bob, he always loses), so he decided to **minimize the score's difference**. Alice's goal is to **maximize the difference** in the score.\n\nGiven an array of integers `stones` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **difference** in Alice and Bob's score if they both play **optimally**._\n\n",
          "input": "**Example 1:**\n\n**Input:** stones = \\[5,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \n- Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13, Bob = 0, stones = \\[5,3,1,4\\].\n- Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13, Bob = 8, stones = \\[3,1,4\\].\n- Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18, Bob = 8, stones = \\[1,4\\].\n- Bob removes 1 and gets 4 points. Alice = 18, Bob = 12, stones = \\[4\\].\n- Alice removes 4 and gets 0 points. Alice = 18, Bob = 12, stones = \\[\\].\nThe score difference is 18 - 12 = 6.\n\n**Example 2:**\n\n**Input:** stones = \\[7,90,5,1,100,10,10,2\\]\n**Output:** 122\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 1000`\n*   `1 <= stones[i] <= 1000`",
          "output": "def getMaxLen(nums):\n    maxLength = currentLen = currentNegLen = 0\n    \n    for num in nums:\n        if num > 0:\n            currentLen += 1\n            if currentNegLen > 0:\n                currentNegLen += 1\n        elif num < 0:\n            currentLen, currentNegLen = currentNegLen, currentLen + 1\n        else:\n            currentLen = currentNegLen = 0\n        maxLength = max(maxLength, currentLen)\n    \n    return maxLength\n"
     },
     {
          "instruction": "You are given a **0-indexed** integer array `nums` consisting of `n` non-negative integers.\n\nYou are also given an array `queries`, where `queries[i] = [xi, yi]`. The answer to the `ith` query is the sum of all `nums[j]` where `xi <= j < n` and `(j - xi)` is divisible by `yi`.\n\nReturn _an array_ `answer` _where_ `answer.length == queries.length` _and_ `answer[i]` _is the answer to the_ `ith` _query **modulo**_ `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[0,1,2,3,4,5,6,7\\], queries = \\[\\[0,3\\],\\[5,1\\],\\[4,2\\]\\]\n**Output:** \\[9,18,10\\]\n**Explanation:** The answers of the queries are as follows:\n1) The j indices that satisfy this query are 0, 3, and 6. nums\\[0\\] + nums\\[3\\] + nums\\[6\\] = 9\n2) The j indices that satisfy this query are 5, 6, and 7. nums\\[5\\] + nums\\[6\\] + nums\\[7\\] = 18\n3) The j indices that satisfy this query are 4 and 6. nums\\[4\\] + nums\\[6\\] = 10\n\n**Example 2:**\n\n**Input:** nums = \\[100,200,101,201,102,202,103,203\\], queries = \\[\\[0,7\\]\\]\n**Output:** \\[303\\]\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `0 <= nums[i] <= 109`\n*   `1 <= queries.length <= 1.5 * 105`\n*   `0 <= xi < n`\n*   `1 <= yi <= 5 * 104`",
          "output": "def reorder_spaces(text: str) -> str:\n    spaces = text.count(' ')\n    words = text.split()\n    \n    if len(words) == 1:\n        return words[0] + ' ' * spaces\n\n    space_between_words = spaces // (len(words) - 1)\n    extra_spaces = spaces % (len(words) - 1)\n    result = ''\n    \n    for i, word in enumerate(words):\n        result += word\n        if i < len(words) - 1:\n            result += ' ' * space_between_words\n    \n    result += ' ' * extra_spaces\n\n    return result\n"
     },
     {
          "instruction": "You are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move, you can jump at most `k` steps forward without going outside the boundaries of the array. That is, you can jump from index `i` to any index in the range `[i + 1, min(n - 1, i + k)]` **inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score** is the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the **maximum score** you can get_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,\\-1,-2,4,-7,3\\], k = 2\n**Output:** 7\n**Explanation:** You can choose your jumps forming the subsequence \\[1,-1,4,3\\] (underlined above). The sum is 7.\n\n**Example 2:**\n\n**Input:** nums = \\[10,-5,-2,4,0,3\\], k = 3\n**Output:** 17\n**Explanation:** You can choose your jumps forming the subsequence \\[10,4,3\\] (underlined above). The sum is 17.\n\n**Example 3:**\n\n**Input:** nums = \\[1,-5,-20,4,-1,3,-6,-3\\], k = 2\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= nums.length, k <= 105`\n*   `-104 <= nums[i] <= 104`",
          "output": "def isPrintable(targetGrid):\n    m, n = len(targetGrid), len(targetGrid[0])\n    top, bottom, left, right = [m]*61, [-1]*61, [n]*61, [-1]*61\n    vis = [[False]*n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            c = targetGrid[i][j]\n            top[c] = min(top[c], i)\n            bottom[c] = max(bottom[c], i)\n            left[c] = min(left[c], j)\n            right[c] = max(right[c], j)\n\n    def dfs(x):\n        i, j = x // n, x % n\n        if vis[i][j]: return True\n        c = targetGrid[i][j]\n        if i < top[c] or i > bottom[c] or j < left[c] or j > right[c]: return False\n        vis[i][j] = True\n        for k in range(1, 61):\n            if k == c: continue\n            if i >= top[k] and i <= bottom[k] and j >= left[k] and j <= right[k]: return False\n            if not dfs(((i-top[k])*(right[k]-left[k]+1)) + j - left[k]): return False\n        return True\n\n    for color in range(1, 61):\n        for i in range(top[color], bottom[color] + 1):\n            for j in range(left[color], right[color] + 1):\n                if not vis[i][j] and not dfs(i * n + j): return False\n\n    return True\n"
     },
     {
          "instruction": "A subsequence of a string `s` is considered a **good palindromic subsequence** if:\n\n*   It is a subsequence of `s`.\n*   It is a palindrome (has the same value if reversed).\n*   It has an **even** length.\n*   No two consecutive characters are equal, except the two middle ones.\n\nFor example, if `s = \"abcabcabb \"`, then `\"abba \"` is considered a **good palindromic subsequence**, while `\"bcb \"` (not even length) and `\"bbbb \"` (has equal consecutive characters) are not.\n\nGiven a string `s`, return _the **length** of the **longest good palindromic subsequence** in_ `s`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"bbabab \"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is  \"baab \".\n\n**Example 2:**\n\n**Input:** s =  \"dcbccacdb \"\n**Output:** 4\n**Explanation:** The longest good palindromic subsequence of s is  \"dccd \".\n\n**Constraints:**\n\n*   `1 <= s.length <= 250`\n*   `s` consists of lowercase English letters.",
          "output": "def most_visited(n, rounds):\n    visited = [0] * (n + 1)\n    \n    for i in range(1, len(rounds)):\n        start, end = rounds[i - 1], rounds[i]\n        while start != end:\n            visited[start] += 1\n            start = (start % n) + 1\n    visited[rounds[-1]] += 1\n    \n    max_visits = max(visited);\n    return [i for i in range(1, n + 1) if visited[i] == max_visits]\n"
     },
     {
          "instruction": "You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n",
          "input": "**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`",
          "output": "def max_achievable_requests(n, requests, idx=0, counts=None):\n    if counts is None:\n        counts = [0] * n\n    if idx == len(requests):\n        if all(count == 0 for count in counts):\n            return 0\n        return 0\n\n    ignored = max_achievable_requests(n, requests, idx+1, counts[:])\n    counts[requests[idx][0]] += 1\n    counts[requests[idx][1]] -= 1\n\n    accepted = 1 + max_achievable_requests(n, requests, idx+1, counts)\n\n    return max(ignored, accepted)\n"
     },
     {
          "instruction": "There are `n` **unique** candies (labeled `1` through `n`) and `k` bags. You are asked to distribute **all** the candies into the bags such that every bag has **at least** one candy.\n\nThere can be multiple ways to distribute the candies. Two ways are considered **different** if the candies in one bag in the first way are not all in the same bag in the second way. The order of the bags and the order of the candies within each bag do not matter.\n\nFor example, `(1), (2,3)` and `(2), (1,3)` are considered different because candies `2` and `3` in the bag `(2,3)` in the first way are not in the same bag in the second way (they are split between the bags `(2)` and `(1,3)`). However, `(1), (2,3)` and `(3,2), (1)` are considered the same because the candies in each bag are all in the same bags in both ways.\n\nGiven two integers, `n` and `k`, return _the **number** of different ways to distribute the candies_. As the answer may be too large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 3\n**Explanation:** You can distribute 3 candies into 2 bags in 3 ways:\n(1), (2,3)\n(1,2), (3)\n(1,3), (2)\n\n**Example 2:**\n\n**Input:** n = 4, k = 2\n**Output:** 7\n**Explanation:** You can distribute 4 candies into 2 bags in 7 ways:\n(1), (2,3,4)\n(1,2), (3,4)\n(1,3), (2,4)\n(1,4), (2,3)\n(1,2,3), (4)\n(1,2,4), (3)\n(1,3,4), (2)\n\n**Example 3:**\n\n**Input:** n = 20, k = 5\n**Output:** 206085257\n**Explanation:** You can distribute 20 candies into 5 bags in 1881780996 ways. 1881780996 modulo 109 + 7 = 206085257.\n\n**Constraints:**\n\n*   `1 <= k <= n <= 1000`",
          "output": "def numTrees(n: int) -> int:\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - 1 - j]\n            dp[i] %= (10**9 + 7)\n\n    return dp[n]\n"
     },
     {
          "instruction": "You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways **modulo** `109 + 7`.\n\nReturn _an integer array_ `answer` _where_ `answer.length == queries.length`_, and_ `answer[i]` _is the answer to the_ `ith` _query._\n\n",
          "input": "**Example 1:**\n\n**Input:** queries = \\[\\[2,6\\],\\[5,1\\],\\[73,660\\]\\]\n**Output:** \\[4,1,50734910\\]\n**Explanation:** Each query is independent.\n\\[2,6\\]: There are 4 ways to fill an array of size 2 that multiply to 6: \\[1,6\\], \\[2,3\\], \\[3,2\\], \\[6,1\\].\n\\[5,1\\]: There is 1 way to fill an array of size 5 that multiply to 1: \\[1,1,1,1,1\\].\n\\[73,660\\]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.\n\n**Example 2:**\n\n**Input:** queries = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\]\n**Output:** \\[1,2,3,10,5\\]\n\n**Constraints:**\n\n*   `1 <= queries.length <= 104`\n*   `1 <= ni, ki <= 104`",
          "output": "MOD = 10**9 + 7\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef ways(n, k, mem):\n    if n == 1:\n        return k\n    if (n_tuple := (n, k)) in mem:\n        return mem[n_tuple]\n    if k == 1:\n        mem[n_tuple] = 1\n        return 1\n    if n > k:\n        mem[n_tuple] = 0\n        return 0\n    res = mul(ways(n, k - 1, mem), n)\n    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD\n    mem[n_tuple] = res\n    return res\n\ndef waysToFillArray(queries):\n    mem = {}\n    ans = []\n    for q in queries:\n        ans.append(ways(q[0], q[1], mem))\n    return ans\n"
     },
     {
          "instruction": "You are given an integer array `nums`. The **absolute sum** of a subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is `abs(numsl + numsl+1 + ... + numsr-1 + numsr)`.\n\nReturn _the **maximum** absolute sum of any **(possibly empty)** subarray of_ `nums`.\n\nNote that `abs(x)` is defined as follows:\n\n*   If `x` is a negative integer, then `abs(x) = -x`.\n*   If `x` is a non-negative integer, then `abs(x) = x`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,-3,2,3,-4\\]\n**Output:** 5\n**Explanation:** The subarray \\[2,3\\] has absolute sum = abs(2+3) = abs(5) = 5.\n\n**Example 2:**\n\n**Input:** nums = \\[2,-5,1,-4,3,-2\\]\n**Output:** 8\n**Explanation:** The subarray \\[-5,1,-4\\] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
          "output": "def maxAbsoluteSum(nums):\n    max_sum = max_end = min_sum = min_end = 0\n    for num in nums:\n        max_end = max(max_end + num, num)\n        min_end = min(min_end + num, num)\n        max_sum = max(max_sum, max_end)\n        min_sum = min(min_sum, min_end)\n    return max(max_sum, -min_sum)\n"
     },
     {
          "instruction": "You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n",
          "input": "**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`",
          "output": "def slowestKey(releaseTimes, keysPressed):\n    max_key = keysPressed[0]\n    max_duration = releaseTimes[0]\n    for i in range(1, len(releaseTimes)):\n        duration = releaseTimes[i] - releaseTimes[i - 1]\n        if duration > max_duration or (duration == max_duration and keysPressed[i] > max_key):\n            max_key = keysPressed[i]\n            max_duration = duration\n    return max_key\n"
     },
     {
          "instruction": "Given a string `s`, return `true` _if it is possible to split the string_ `s` _into three **non-empty** palindromic substrings. Otherwise, return_ `false`.\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\n\nA string is said to be palindrome if it the same string when reversed.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"abcbdd \"\n**Output:** true\n**Explanation: ** \"abcbdd \" =  \"a \" +  \"bcb \" +  \"dd \", and all three substrings are palindromes.\n\n**Example 2:**\n\n**Input:** s =  \"bcbddxy \"\n**Output:** false\n**Explanation:** s cannot be split into 3 palindromes.\n\n**Constraints:**\n\n*   `3 <= s.length <= 2000`\n*   `s`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039 consists only of lowercase English letters.",
          "output": "def is_palindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef check_partitioning(s):\n    n = len(s)\n    for i in range(0, n - 2):\n        if is_palindrome(s, 0, i):\n            for j in range(i + 1, n - 1):\n                if is_palindrome(s, i + 1, j) and is_palindrome(s, j + 1, n - 1):\n                    return True\n    return False\n"
     },
     {
          "instruction": "You are given an integer array `nums` and an integer `goal`.\n\nYou want to choose a subsequence of `nums` such that the sum of its elements is the closest possible to `goal`. That is, if the sum of the subsequence's elements is `sum`, then you want to **minimize the absolute difference** `abs(sum - goal)`.\n\nReturn _the **minimum** possible value of_ `abs(sum - goal)`.\n\nNote that a subsequence of an array is an array formed by removing some elements **(possibly all or none)** of the original array.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[5,-7,3,5\\], goal = 6\n**Output:** 0\n**Explanation:** Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.\n\n**Example 2:**\n\n**Input:** nums = \\[7,-9,15,-2\\], goal = -5\n**Output:** 1\n**Explanation:** Choose the subsequence \\[7,-9,-2\\], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3\\], goal = -7\n**Output:** 7\n\n**Constraints:**\n\n*   `1 <= nums.length <= 40`\n*   `-107 <= nums[i] <= 107`\n*   `-109 <= goal <= 109`",
          "output": "def decrypt(code, k):\n    n = len(code)\n    result = [0] * n\n    if k == 0: return result\n    \n    for i in range(n):\n        sum = 0\n        for j in range(1, abs(k) + 1):\n            sum += code[(i + j) % n] if k > 0 else code[(i - j + n) % n]\n        result[i] = sum\n    return result\n"
     },
     {
          "instruction": "You are given an integer array `nums`. You must perform **exactly one** operation where you can **replace** one element `nums[i]` with `nums[i] * nums[i]`.\n\nReturn _the **maximum** possible subarray sum after **exactly one** operation_. The subarray must be non-empty.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[2,-1,-4,-3\\]\n**Output:** 17\n**Explanation:** You can perform the operation on index 2 (0-indexed) to make nums = \\[2,-1,**16**,-3\\]. Now, the maximum subarray sum is 2 + -1 + 16 = 17.\n\n**Example 2:**\n\n**Input:** nums = \\[1,-1,1,1,-1,-1,1\\]\n**Output:** 4\n**Explanation:** You can perform the operation on index 1 (0-indexed) to make nums = \\[1,**1**,1,1,-1,-1,1\\]. Now, the maximum subarray sum is 1 + 1 + 1 + 1 = 4.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
          "output": "def maxLengthBetweenEqualCharacters(s: str) -> int:\n    max_length = -1\n    char_index_map = {}\n\n    for i, char in enumerate(s):\n        if char in char_index_map:\n            max_length = max(max_length, i - char_index_map[char] - 1)\n        else:\n            char_index_map[char] = i\n\n    return max_length\n"
     },
     {
          "instruction": "You are given two **0-indexed** integer arrays `nums` and `multipliers` of size `n` and `m` respectively, where `n >= m`.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations. On the `ith` operation (**0-indexed**) you will:\n\n*   Choose one integer `x` from **either the start or the end** of the array `nums`.\n*   Add `multipliers[i] * x` to your score.\n    *   Note that `multipliers[0]` corresponds to the first operation, `multipliers[1]` to the second operation, and so on.\n*   Remove `x` from `nums`.\n\nReturn _the **maximum** score after performing_ `m` _operations._\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], multipliers = \\[3,2,1\\]\n**Output:** 14\n**Explanation:** An optimal solution is as follows:\n- Choose from the end, \\[1,2,**3**\\], adding 3 \\* 3 = 9 to the score.\n- Choose from the end, \\[1,**2**\\], adding 2 \\* 2 = 4 to the score.\n- Choose from the end, \\[**1**\\], adding 1 \\* 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n\n**Example 2:**\n\n**Input:** nums = \\[-5,-3,-3,-2,7,1\\], multipliers = \\[-10,-5,3,4,6\\]\n**Output:** 102\n**Explanation:** An optimal solution is as follows:\n- Choose from the start, \\[**\\-5**,-3,-3,-2,7,1\\], adding -5 \\* -10 = 50 to the score.\n- Choose from the start, \\[**\\-3**,-3,-2,7,1\\], adding -3 \\* -5 = 15 to the score.\n- Choose from the start, \\[**\\-3**,-2,7,1\\], adding -3 \\* 3 = -9 to the score.\n- Choose from the end, \\[-2,7,**1**\\], adding 1 \\* 4 = 4 to the score.\n- Choose from the end, \\[-2,**7**\\], adding 7 \\* 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `m == multipliers.length`\n*   `1 <= m <= 300`\n*   `m <= n <= 105`\n*   `-1000 <= nums[i], multipliers[i] <= 1000`",
          "output": "def min_deletions(s):\n    freq = collections.Counter(s)\n    used = set()\n    deletions = 0\n\n    for count in freq.values():\n        while count in used and count > 0:\n            deletions += 1\n            count -= 1\n        used.add(count)\n\n    return deletions\n"
     },
     {
          "instruction": "You are given two strings, `word1` and `word2`. You want to construct a string in the following manner:\n\n*   Choose some **non-empty** subsequence `subsequence1` from `word1`.\n*   Choose some **non-empty** subsequence `subsequence2` from `word2`.\n*   Concatenate the subsequences: `subsequence1 + subsequence2`, to make the string.\n\nReturn _the **length** of the longest **palindrome** that can be constructed in the described manner._ If no palindromes can be constructed, return `0`.\n\nA **subsequence** of a string `s` is a string that can be made by deleting some (possibly none) characters from `s` without changing the order of the remaining characters.\n\nA **palindrome** is a string that reads the same forward as well as backward.\n\n",
          "input": "**Example 1:**\n\n**Input:** word1 =  \"cacb \", word2 =  \"cbba \"\n**Output:** 5\n**Explanation:** Choose  \"ab \" from word1 and  \"cba \" from word2 to make  \"abcba \", which is a palindrome.\n\n**Example 2:**\n\n**Input:** word1 =  \"ab \", word2 =  \"ab \"\n**Output:** 3\n**Explanation:** Choose  \"ab \" from word1 and  \"a \" from word2 to make  \"aba \", which is a palindrome.\n\n**Example 3:**\n\n**Input:** word1 =  \"aa \", word2 =  \"bb \"\n**Output:** 0\n**Explanation:** You cannot construct a palindrome from the described method, so return 0.\n\n**Constraints:**\n\n*   `1 <= word1.length, word2.length <= 1000`\n*   `word1` and `word2` consist of lowercase English letters.",
          "output": "def maxProfit(inventory, orders):\n    mod = 10**9 + 7\n    inventory.sort(reverse=True)\n    inventory.append(0)\n    n, ans, count = len(inventory), 0, 1\n    for i in range(n - 1):\n        diff = inventory[i] - inventory[i + 1]\n        if count * diff < orders:\n            orders -= count * diff\n            ans = (ans + (((inventory[i] + inventory[i + 1] + 1) * diff) // 2) % mod * count) % mod\n        else:\n            q, r = divmod(orders, count)\n            ans = (ans + (((inventory[i] + inventory[i] - q + 1) * q) // 2) % mod * count) % mod\n            ans = (ans + r * (inventory[i] - q)) % mod\n            break\n        count += 1\n    return ans\n"
     },
     {
          "instruction": "You would like to make dessert and are preparing to buy the ingredients. You have `n` ice cream base flavors and `m` types of toppings to choose from. You must follow these rules when making your dessert:\n\n*   There must be **exactly one** ice cream base.\n*   You can add **one or more** types of topping or have no toppings at all.\n*   There are **at most two** of **each type** of topping.\n\nYou are given three inputs:\n\n*   `baseCosts`, an integer array of length `n`, where each `baseCosts[i]` represents the price of the `ith` ice cream base flavor.\n*   `toppingCosts`, an integer array of length `m`, where each `toppingCosts[i]` is the price of **one** of the `ith` topping.\n*   `target`, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to `target` as possible.\n\nReturn _the closest possible cost of the dessert to_ `target`. If there are multiple, return _the **lower** one._\n\n",
          "input": "**Example 1:**\n\n**Input:** baseCosts = \\[1,7\\], toppingCosts = \\[3,4\\], target = 10\n**Output:** 10\n**Explanation:** Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.\n\n**Example 2:**\n\n**Input:** baseCosts = \\[2,3\\], toppingCosts = \\[4,5,100\\], target = 18\n**Output:** 17\n**Explanation:** Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.\n\n**Example 3:**\n\n**Input:** baseCosts = \\[3,10\\], toppingCosts = \\[2,5\\], target = 9\n**Output:** 8\n**Explanation:** It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.\n\n**Constraints:**\n\n*   `n == baseCosts.length`\n*   `m == toppingCosts.length`\n*   `1 <= n, m <= 10`\n*   `1 <= baseCosts[i], toppingCosts[i] <= 104`\n*   `1 <= target <= 104`",
          "output": "from itertools import product\n\ndef closest_cost(base_costs, topping_costs, target):\n    closest = float('inf')\n    topping_combinations = list(product([0, 1, 2], repeat=len(topping_costs)))\n    \n    for base in base_costs:\n        for combination in topping_combinations:\n            combination_cost = sum(x * y for x, y in zip(topping_costs, combination))\n            diff = abs(target - (base + combination_cost))\n            if diff < closest:\n                closest = diff\n            if diff == 0:\n                return target\n\n    return target - closest\n"
     },
     {
          "instruction": "You are given `nums`, an array of positive integers of size `2 * n`. You must perform `n` operations on this array.\n\nIn the `ith` operation **(1-indexed)**, you will:\n\n*   Choose two elements, `x` and `y`.\n*   Receive a score of `i * gcd(x, y)`.\n*   Remove `x` and `y` from `nums`.\n\nReturn _the maximum score you can receive after performing_ `n` _operations._\n\nThe function `gcd(x, y)` is the greatest common divisor of `x` and `y`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 1\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(1, 2)) = 1\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,6,8\\]\n**Output:** 11\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(3, 6)) + (2 \\* gcd(4, 8)) = 3 + 8 = 11\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6\\]\n**Output:** 14\n**Explanation:** The optimal choice of operations is:\n(1 \\* gcd(1, 5)) + (2 \\* gcd(2, 4)) + (3 \\* gcd(3, 6)) = 1 + 4 + 9 = 14\n\n**Constraints:**\n\n*   `1 <= n <= 7`\n*   `nums.length == 2 * n`\n*   `1 <= nums[i] <= 106`",
          "output": "from typing import List\n\ndef minimumIncompatibility(nums: List[int], k: int) -> int:\n    n = len(nums)\n    if n % k != 0:\n        return -1\n    \n    nums.sort()\n    diffs = [nums[(i + 1) * (n // k) - 1] - nums[i * (n // k)] for i in range(k)]\n    \n    return sum(diffs)\n"
     },
     {
          "instruction": "There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.",
          "output": "def count_consistent_strings(allowed, words):\n    allowed_set = set(allowed)\n    count = 0\n    for word in words:\n        is_valid = True\n        for c in word:\n            if c not in allowed_set:\n                is_valid = False\n                break\n        if is_valid:\n            count += 1\n    return count\n"
     },
     {
          "instruction": "You are given an array `nums`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039 and an integer `k`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039. The XOR of a segment `[left, right]` where `left <= right` is the `XOR` of all the elements with indices between `left` and `right`, inclusive: `nums[left] XOR nums[left+1] XOR ... XOR nums[right]`.\n\nReturn _the minimum number of elements to change in the array_ such that the `XOR` of all segments of size `k`\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039 is equal to zero.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,0,3,0\\], k = 1\n**Output:** 3\n**Explanation:** Modify the array from \\[**1**,**2**,0,**3**,0\\] to from \\[**0**,**0**,0,**0**,0\\].\n\n**Example 2:**\n\n**Input:** nums = \\[3,4,5,2,1,7,3,4,7\\], k = 3\n**Output:** 3\n**Explanation:** Modify the array from \\[3,4,**5**,**2**,**1**,7,3,4,7\\] to \\[3,4,**7**,**3**,**4**,7,3,4,7\\].\n\n**Example 3:**\n\n**Input:** nums = \\[1,2,4,1,2,5,1,2,6\\], k = 3\n**Output:** 3\n**Explanation:** Modify the array from \\[1,2,**4,**1,2,**5**,1,2,**6**\\] to \\[1,2,**3**,1,2,**3**,1,2,**3**\\].\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 2000`\n*   `\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u2039\u00e2\u20ac\u20390 <= nums[i] < 210`",
          "output": "def calculate_summation_of_absolute_differences(nums):\n    n = len(nums)\n    result = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i] += abs(nums[i] - nums[j])\n\n    return result\n"
     },
     {
          "instruction": "There is a donuts shop that bakes donuts in batches of `batchSize`. They have a rule where they must serve **all** of the donuts of a batch before serving any donuts of the next batch. You are given an integer `batchSize` and an integer array `groups`, where `groups[i]` denotes that there is a group of `groups[i]` customers that will visit the shop. Each customer will get exactly one donut.\n\nWhen a group visits the shop, all customers of the group must be served before serving any of the following groups. A group will be happy if they all get fresh donuts. That is, the first customer of the group does not receive a donut that was left over from the previous group.\n\nYou can freely rearrange the ordering of the groups. Return _the **maximum** possible number of happy groups after rearranging the groups._\n\n",
          "input": "**Example 1:**\n\n**Input:** batchSize = 3, groups = \\[1,2,3,4,5,6\\]\n**Output:** 4\n**Explanation:** You can arrange the groups as \\[6,2,4,5,1,3\\]. Then the 1st, 2nd, 4th, and 6th groups will be happy.\n\n**Example 2:**\n\n**Input:** batchSize = 4, groups = \\[1,3,2,5,2,2,1,6\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= batchSize <= 9`\n*   `1 <= groups.length <= 30`\n*   `1 <= groups[i] <= 109`",
          "output": "from typing import List\n\ndef distanceLimitedPathsExist(n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\n    edgeList.sort(key=lambda x: x[2])\n    queries = sorted(enumerate(queries), key=lambda x: x[1][2])\n\n    def find(x: int, parent: List[int]) -> int:\n        if x != parent[x]:\n            parent[x] = find(parent[x], parent)\n        return parent[x]\n\n    parent = list(range(n))\n    res = [False] * len(queries)\n    idx = 0\n\n    for query_id, query in queries:\n        p, q, limit = query\n        while idx < len(edgeList) and edgeList[idx][2] < limit:\n            u, v = edgeList[idx][:2]\n            ru, rv = find(u, parent), find(v, parent)\n            if ru != rv:\n                parent[ru] = rv\n            idx += 1\n        res[query_id] = find(p, parent) == find(q, parent)\n\n    return res\n"
     },
     {
          "instruction": "There is a **3 lane road** of length `n` that consists of `n + 1` **points** labeled from `0` to `n`. A frog **starts** at point `0` in the **second** lane and wants to jump to point `n`. However, there could be obstacles along the way.\n\nYou are given an array `obstacles` of length `n + 1` where each `obstacles[i]` (**ranging from 0 to 3**) describes an obstacle on the lane `obstacles[i]` at point `i`. If `obstacles[i] == 0`, there are no obstacles at point `i`. There will be **at most one** obstacle in the 3 lanes at each point.\n\n*   For example, if `obstacles[2] == 1`, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point `i` to point `i + 1` on the same lane if there is not an obstacle on the lane at point `i + 1`. To avoid obstacles, the frog can also perform a **side jump** to jump to **another** lane (even if they are not adjacent) at the **same** point if there is no obstacle on the new lane.\n\n*   For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn _the **minimum number of side jumps** the frog needs to reach **any lane** at point n starting from lane `2` at point 0._\n\n**Note:** There will be no obstacles on points `0` and `n`.\n\n",
          "input": "**Example 1:**\n\n**Input:** obstacles = \\[0,1,2,3,0\\]\n**Output:** 2 \n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n\n**Example 2:**\n\n**Input:** obstacles = \\[0,1,1,3,3,0\\]\n**Output:** 0\n**Explanation:** There are no obstacles on lane 2. No side jumps are required.\n\n**Example 3:**\n\n**Input:** obstacles = \\[0,2,1,0,3,0\\]\n**Output:** 2\n**Explanation:** The optimal solution is shown by the arrows above. There are 2 side jumps.\n\n**Constraints:**\n\n*   `obstacles.length == n + 1`\n*   `1 <= n <= 5 * 105`\n*   `0 <= obstacles[i] <= 3`\n*   `obstacles[0] == obstacles[n] == 0`",
          "output": "import heapq\n\ndef eatenApples(apples, days):\n    n = len(apples)\n    pq = []\n    ans = 0\n\n    for i in range(n + 1):\n        if i < n and apples[i] > 0:\n            heapq.heappush(pq, (i + days[i], apples[i]))\n\n        while pq and pq[0][0] <= i:\n            heapq.heappop(pq)\n\n        if pq:\n            ans += 1\n            curr_apple = heapq.heappop(pq)\n            if curr_apple[1] > 1:\n                heapq.heappush(pq, (curr_apple[0], curr_apple[1] - 1))\n\n    return ans\n"
     },
     {
          "instruction": "There is a **directed graph** of `n` colored nodes and `m` edges. The nodes are numbered from `0` to `n - 1`.\n\nYou are given a string `colors` where `colors[i]` is a lowercase English letter representing the **color** of the `ith` node in this graph (**0-indexed**). You are also given a 2D array `edges` where `edges[j] = [aj, bj]` indicates that there is a **directed edge** from node `aj` to node `bj`.\n\nA valid **path** in the graph is a sequence of nodes `x1 -> x2 -> x3 -> ... -> xk` such that there is a directed edge from `xi` to `xi+1` for every `1 <= i < k`. The **color value** of the path is the number of nodes that are colored the **most frequently** occurring color along that path.\n\nReturn _the **largest color value** of any valid path in the given graph, or_ `-1` _if the graph contains a cycle_.\n\n",
          "input": "**Example 1:**\n\n**Input:** colors =  \"abaca \", edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 3\n**Explanation:** The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored ` \"a \" (red in the above image)`.\n\n**Example 2:**\n\n**Input:** colors =  \"a \", edges = \\[\\[0,0\\]\\]\n**Output:** -1\n**Explanation:** There is a cycle from 0 to 0.\n\n**Constraints:**\n\n*   `n == colors.length`\n*   `m == edges.length`\n*   `1 <= n <= 105`\n*   `0 <= m <= 105`\n*   `colors` consists of lowercase English letters.\n*   `0 <= aj, bj < n`",
          "output": "from collections import deque\n\ndef largestPathValue(colors: str, edges: List[List[int]]) -> int:\n    n = len(colors)\n    adj = [[] for _ in range(n)]\n    \n    in_degrees = [0] * n\n    for e in edges:\n        adj[e[0]].append(e[1])\n        in_degrees[e[1]] += 1\n        \n    color_counts = [[0] * 26 for _ in range(n)]\n    queue = deque()\n    \n    for i in range(n):\n        if in_degrees[i] == 0:\n            queue.append(i)\n            \n    visited_nodes = 0\n    max_color_value = 0\n    \n    while queue:\n        node = queue.pop()\n        color = ord(colors[node]) - ord('a')\n        visited_nodes += 1\n        \n        for neighbor in adj[node]:\n            for c in range(26):\n                count = color_counts[node][c] + (c == color)\n                color_counts[neighbor][c] = max(color_counts[neighbor][c], count)\n                max_color_value = max(max_color_value, count)\n                \n            in_degrees[neighbor] -= 1\n            if in_degrees[neighbor] == 0:\n                queue.append(neighbor)\n                \n    return max_color_value if visited_nodes == n else -1\n"
     },
     {
          "instruction": "You are given two integer arrays `nums1` and `nums2` of length `n`.\n\nThe **XOR sum** of the two integer arrays is `(nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])` (**0-indexed**).\n\n*   For example, the **XOR sum** of `[1,2,3]` and `[3,2,1]` is equal to `(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4`.\n\nRearrange the elements of `nums2` such that the resulting **XOR sum** is **minimized**.\n\nReturn _the **XOR sum** after the rearrangement_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[2,3\\]\n**Output:** 2\n**Explanation:** Rearrange `nums2` so that it becomes `[3,2]`.\nThe XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.\n\n**Example 2:**\n\n**Input:** nums1 = \\[1,0,3\\], nums2 = \\[5,3,4\\]\n**Output:** 8\n**Explanation:** Rearrange `nums2` so that it becomes `[5,4,3]`. \nThe XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.\n\n**Constraints:**\n\n*   `n == nums1.length`\n*   `n == nums2.length`\n*   `1 <= n <= 14`\n*   `0 <= nums1[i], nums2[i] <= 107`",
          "output": "def max_score(a: int, b: int, c: int) -> int:\n    return (a + b + c - max(a, b, c)) // 2\n"
     },
     {
          "instruction": "There are `n` uniquely-sized sticks whose lengths are integers from `1` to `n`. You want to arrange the sticks such that **exactly** `k` sticks are **visible** from the left. A stick is **visible** from the left if there are no **longer** sticks to the **left** of it.\n\n*   For example, if the sticks are arranged `[1,3,2,5,4]`, then the sticks with lengths `1`, `3`, and `5` are visible from the left.\n\nGiven `n` and `k`, return _the **number** of such arrangements_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 3\n**Explanation:** \\[1,3,2\\], \\[2,3,1\\], and \\[2,1,3\\] are the only arrangements such that exactly 2 sticks are visible.\nThe visible sticks are underlined.\n\n**Example 2:**\n\n**Input:** n = 5, k = 5\n**Output:** 1\n**Explanation:** \\[1,2,3,4,5\\] is the only arrangement such that all 5 sticks are visible.\nThe visible sticks are underlined.\n\n**Example 3:**\n\n**Input:** n = 20, k = 11\n**Output:** 647427950\n**Explanation:** There are 647427950 (mod 109 \\+ 7) ways to rearrange the sticks such that exactly 11 sticks are visible.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `1 <= k <= n`",
          "output": "from collections import defaultdict\n\ndef restoreArray(adjacentPairs):\n    graph = defaultdict(list)\n    for pair in adjacentPairs:\n        graph[pair[0]].append(pair[1])\n        graph[pair[1]].append(pair[0])\n\n    n = len(graph)\n    nums = [0] * n\n    for key, nodes in graph.items():\n        if len(nodes) == 1:\n            nums[0] = key\n            break\n\n    nums[1] = graph[nums[0]][0]\n    for i in range(2, n):\n        nums[i] = (graph[nums[i - 1]][1]\n                   if (nums[i - 2] == graph[nums[i - 1]][0])\n                   else graph[nums[i - 1]][0])\n\n    return nums\n"
     },
     {
          "instruction": "Alice and Bob take turns playing a game, with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn, while the number of stones is **more than one**, they will do the following:\n\n1.  Choose an integer `x > 1`, and **remove** the leftmost `x` stones from the row.\n2.  Add the **sum** of the **removed** stones' values to the player's score.\n3.  Place a **new stone**, whose value is equal to that sum, on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to **maximize** the score difference, and Bob's goal is the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone **from the left**, return _the **score difference** between Alice and Bob if they both play **optimally**._\n\n",
          "input": "**Example 1:**\n\n**Input:** stones = \\[-1,2,-3,4,-5\\]\n**Output:** 5\n**Explanation:**\n- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of\n  value 2 on the left. stones = \\[2,-5\\].\n- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on\n  the left. stones = \\[-3\\].\nThe difference between their scores is 2 - (-3) = 5.\n\n**Example 2:**\n\n**Input:** stones = \\[7,-6,5,10,5,-2,-6\\]\n**Output:** 13\n**Explanation:**\n- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a\n  stone of value 13 on the left. stones = \\[13\\].\nThe difference between their scores is 13 - 0 = 13.\n\n**Example 3:**\n\n**Input:** stones = \\[-10,-12\\]\n**Output:** -22\n**Explanation:**\n- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her\n  score and places a stone of value -22 on the left. stones = \\[-22\\].\nThe difference between their scores is (-22) - 0 = -22.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `2 <= n <= 105`\n*   `-104 <= stones[i] <= 104`",
          "output": "def can_eat(candiesCount, queries):\n    prefix_sum = [0] * (len(candiesCount) + 1)\n    for i in range(len(candiesCount)):\n        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]\n\n    result = [False] * len(queries)\n    for i in range(len(queries)):\n        favoriteType, favoriteDay, dailyCap = queries[i]\n        x1 = favoriteDay + 1\n        y1 = (favoriteDay + 1) * dailyCap\n\n        x2 = prefix_sum[favoriteType] + 1\n        y2 = prefix_sum[favoriteType + 1]\n\n        result[i] = not (x1 > y2 or y1 < x2)\n\n    return result\n"
     },
     {
          "instruction": "You are given a **valid** boolean expression as a string `expression` consisting of the characters `'1'`,`'0'`,`'&'` (bitwise **AND** operator),`'|'` (bitwise **OR** operator),`'('`, and `')'`.\n\n*   For example, `\"()1|1 \"` and `\"(1)&() \"` are **not valid** while `\"1 \"`, `\"(((1))|(0)) \"`, and `\"1|(0&(1)) \"` are **valid** expressions.\n\nReturn _the **minimum cost** to change the final value of the expression_.\n\n*   For example, if `expression = \"1|1|(0&0)&1 \"`, its **value** is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the **new** expression evaluates to `0`.\n\nThe **cost** of changing the final value of an expression is the **number of operations** performed on the expression. The types of **operations** are described as follows:\n\n*   Turn a `'1'` into a `'0'`.\n*   Turn a `'0'` into a `'1'`.\n*   Turn a `'&'` into a `'|'`.\n*   Turn a `'|'` into a `'&'`.\n\n**Note:** `'&'` does **not** take precedence over `'|'` in the **order of calculation**. Evaluate parentheses **first**, then in **left-to-right** order.\n\n",
          "input": "**Example 1:**\n\n**Input:** expression =  \"1&(0|1) \"\n**Output:** 1\n**Explanation:** We can turn  \"1&(0**|**1) \" into  \"1&(0**&**1) \" by changing the '|' to a '&' using 1 operation.\nThe new expression evaluates to 0. \n\n**Example 2:**\n\n**Input:** expression =  \"(0&0)&(0&0&0) \"\n**Output:** 3\n**Explanation:** We can turn  \"(0**&0**)**&**(0&0&0) \" into  \"(0**|1**)**|**(0&0&0) \" using 3 operations.\nThe new expression evaluates to 1.\n\n**Example 3:**\n\n**Input:** expression =  \"(0|(1|0&1)) \"\n**Output:** 1\n**Explanation:** We can turn  \"(0|(**1**|0&1)) \" into  \"(0|(**0**|0&1)) \" using 1 operation.\nThe new expression evaluates to 0.\n\n**Constraints:**\n\n*   `1 <= expression.length <= 105`\n*   `expression` only contains `'1'`,`'0'`,`'&'`,`'|'`,`'('`, and `')'`\n*   All parentheses are properly matched.\n*   There will be no empty parentheses (i.e: `\"() \"` is not a substring of `expression`).",
          "output": "def maximumScore(nums, multipliers):\n    n, m = len(nums), len(multipliers)\n    dp = [[0] * (m + 1) for _ in range(m + 1)]\n    maxScore = float('-inf')\n\n    for i in range(m + 1):\n        for j in range(m - i + 1):\n            if i == 0 and j == 0:\n                continue\n            score = 0\n            if i == 0:\n                score = dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1]\n            elif j == 0:\n                score = dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1]\n            else:\n                score = max(dp[i - 1][j] + nums[i - 1] * multipliers[i + j - 1],\n                            dp[i][j - 1] + nums[n - j] * multipliers[i + j - 1])\n            dp[i][j] = score\n            if i + j == m:\n                maxScore = max(maxScore, score)\n\n    return maxScore\n"
     },
     {
          "instruction": "You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in **kilometers**. In addition, you are given an integer `speed`, which is the speed (in **km/h**) you will travel at.\n\nAfter you travel road `i`, you must rest and wait for the **next integer hour** before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.\n\n*   For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait.\n\nHowever, you are allowed to **skip** some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.\n\n*   For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately.\n\nReturn _the **minimum number of skips required** to arrive at the meeting on time, or_ `-1` _if it is **impossible**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** dist = \\[1,3,2\\], speed = 4, hoursBefore = 2\n**Output:** 1\n**Explanation:**\nWithout skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\nYou can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.\nNote that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n\n**Example 2:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 2, hoursBefore = 10\n**Output:** 2\n**Explanation:**\nWithout skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\nYou can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.\n\n**Example 3:**\n\n**Input:** dist = \\[7,3,5,5\\], speed = 1, hoursBefore = 10\n**Output:** -1\n**Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests.\n\n**Constraints:**\n\n*   `n == dist.length`\n*   `1 <= n <= 1000`\n*   `1 <= dist[i] <= 105`\n*   `1 <= speed <= 106`\n*   `1 <= hoursBefore <= 107`",
          "output": "def minSkips(dist, speed, hoursBefore):\n    n = len(dist)\n    dp = [[1e9] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(i+1):\n            t = dist[i] / speed + (1 if j else 0)\n            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)\n            skipped_t = -(-dist[i] / speed) - dp[i][j]\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)\n\n    for i in range(n + 1):\n        if dp[n][i] <= hoursBefore:\n            return i\n    return -1\n"
     },
     {
          "instruction": "The **alternating sum** of a **0-indexed** array is defined as the **sum** of the elements at **even** indices **minus** the **sum** of the elements at **odd** indices.\n\n*   For example, the alternating sum of `[4,2,5,3]` is `(4 + 5) - (2 + 3) = 4`.\n\nGiven an array `nums`, return _the **maximum alternating sum** of any subsequence of_ `nums` _(after **reindexing** the elements of the subsequence)_.\n\nA **subsequence** of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, `[2,7,4]` is a subsequence of `[4,2,3,7,2,1,4]` (the underlined elements), while `[2,4,2]` is not.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[4,2,5,3\\]\n**Output:** 7\n**Explanation:** It is optimal to choose the subsequence \\[4,2,5\\] with alternating sum (4 + 5) - 2 = 7.\n\n**Example 2:**\n\n**Input:** nums = \\[5,6,7,8\\]\n**Output:** 8\n**Explanation:** It is optimal to choose the subsequence \\[8\\] with alternating sum 8.\n\n**Example 3:**\n\n**Input:** nums = \\[6,2,1,2,4,5\\]\n**Output:** 10\n**Explanation:** It is optimal to choose the subsequence \\[6,1,5\\] with alternating sum (6 + 5) - 1 = 10.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 105`",
          "output": "def min_elements(nums, limit, goal):\n    total_sum = sum(nums)\n    diff = abs(goal - total_sum)\n    return (diff + limit - 1) // limit\n"
     },
     {
          "instruction": "There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their **initial** standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.\n\n*   For example, if the row consists of players `1, 2, 4, 6, 7`\n    *   Player `1` competes against player `7`.\n    *   Player `2` competes against player `6`.\n    *   Player `4` automatically advances to the next round.\n\nAfter each round is over, the winners are lined back up in the row based on the **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may **choose** the outcome of this round.\n\nGiven the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the **earliest** possible round number and the **latest** possible round number in which these two players will compete against each other, respectively_.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 11, firstPlayer = 2, secondPlayer = 4\n**Output:** \\[3,4\\]\n**Explanation:**\nOne possible scenario which leads to the earliest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 2, 3, 4, 5, 6, 11\nThird round: 2, 3, 4\nOne possible scenario which leads to the latest round number:\nFirst round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nSecond round: 1, 2, 3, 4, 5, 6\nThird round: 1, 2, 4\nFourth round: 2, 4\n\n**Example 2:**\n\n**Input:** n = 5, firstPlayer = 1, secondPlayer = 5\n**Output:** \\[1,1\\]\n**Explanation:** The players numbered 1 and 5 compete in the first round.\nThere is no way to make them compete in any other round.\n\n**Constraints:**\n\n*   `2 <= n <= 28`\n*   `1 <= firstPlayer < secondPlayer <= n`",
          "output": "def closest_cost(base_costs, topping_costs, target):\n    closest = base_costs[0]\n    \n    for base in base_costs:\n        cost = base\n        \n        for i in range(1 << (len(topping_costs) * 2)):\n            bit_mask = i\n            \n            for j, topping_cost in enumerate(topping_costs):\n                cost += (bit_mask & 3) * topping_cost\n                bit_mask >>= 2\n                \n            if abs(target - cost) < abs(target - closest):\n                closest = cost\n            elif abs(target - cost) == abs(target - closest) and cost < closest:\n                closest = cost\n                \n            cost = base\n            \n    return closest\n"
     },
     {
          "instruction": "You are given **two identical** eggs and you have access to a building with `n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg dropped at a floor **higher** than `f` will **break**, and any egg dropped **at or below** floor `f` will **not break**.\n\nIn each move, you may take an **unbroken** egg and drop it from any floor `x` (where `1 <= x <= n`). If the egg breaks, you can no longer use it. However, if the egg does not break, you may **reuse** it in future moves.\n\nReturn _the **minimum number of moves** that you need to determine **with certainty** what the value of_ `f` is.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.\n\n**Example 2:**\n\n**Input:** n = 100\n**Output:** 14\n**Explanation:** One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f.\n\n**Constraints:**\n\n*   `1 <= n <= 1000`",
          "output": "def min_operations_to_alternate(s: str) -> int:\n    count_a, count_b = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c == '0':\n                count_a += 1\n            else:\n                count_b += 1\n        else:\n            if c == '0':\n                count_b += 1\n            else:\n                count_a += 1\n    return min(count_a, count_b)\n"
     },
     {
          "instruction": "There is a country of `n` cities numbered from `0` to `n - 1` where **all the cities are connected** by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.\n\nEach time you pass through a city, you must pay a passing fee. This is represented as a **0-indexed** integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.\n\nIn the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` **minutes or less**. The **cost** of your journey is the **summation of passing fees** for each city that you passed through at some moment of your journey (**including** the source and destination cities).\n\nGiven `maxTime`, `edges`, and `passingFees`, return _the **minimum cost** to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.\n\n",
          "input": "**Example 1:**\n\n**Input:** maxTime = 30, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 11\n**Explanation:** The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees.\n\n**Example 2:**\n\n**Input:** maxTime = 29, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** 48\n**Explanation:** The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees.\nYou cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n\n**Example 3:**\n\n**Input:** maxTime = 25, edges = \\[\\[0,1,10\\],\\[1,2,10\\],\\[2,5,10\\],\\[0,3,1\\],\\[3,4,10\\],\\[4,5,15\\]\\], passingFees = \\[5,1,2,20,20,3\\]\n**Output:** -1\n**Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n\n**Constraints:**\n\n*   `1 <= maxTime <= 1000`\n*   `n == passingFees.length`\n*   `2 <= n <= 1000`\n*   `n - 1 <= edges.length <= 1000`\n*   `0 <= xi, yi <= n - 1`\n*   `1 <= timei <= 1000`\n*   `1 <= passingFees[j] <= 1000`\n*   The graph may contain multiple edges between two nodes.\n*   The graph does not contain self loops.",
          "output": "from heapq import heappush, heappop\n\ndef getNumberOfBacklogOrders(orders):\n    buy, sell = [], []\n\n    for price, amount, orderType in orders:\n        if orderType == 0:\n            while amount > 0 and sell and -sell[0][0] <= price:\n                executedAmount = min(amount, sell[0][1])\n                amount -= executedAmount\n                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]\n                if sell[0][1] == 0:\n                    heappop(sell)\n            if amount:\n                heappush(buy, [-price, amount])\n        else:\n            while amount > 0 and buy and buy[0][0] >= price:\n                executedAmount = min(amount, buy[0][1])\n                amount -= executedAmount\n                buy[0] = [buy[0][0], buy[0][1] - executedAmount]\n                if buy[0][1] == 0:\n                    heappop(buy)\n            if amount:\n                heappush(sell, [-price, amount])\n\n    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)\n    return res % 1000000007\n"
     },
     {
          "instruction": "You are given two integers `m` and `n`. Consider an `m x n` grid where each cell is initially white. You can paint each cell **red**, **green**, or **blue**. All cells **must** be painted.\n\nReturn _the number of ways to color the grid with **no two adjacent cells having the same color**_. Since the answer can be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 3\n**Explanation:** The three possible colorings are shown in the image above.\n\n**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 6\n**Explanation:** The six possible colorings are shown in the image above.\n\n**Example 3:**\n\n**Input:** m = 5, n = 5\n**Output:** 580986\n\n**Constraints:**\n\n*   `1 <= m <= 5`\n*   `1 <= n <= 1000`",
          "output": "def numOfWays(m, n):\n    mod = 1000000007\n    a, b, c, d = 6, 6, 3, 3\n    while n > 1:\n        n -= 1\n        temp_a = a\n        temp_c = c\n        a = (a * 3 + b * 2) % mod\n        b = (temp_a * 2 + b * 2) % mod\n        c = (c * 3 + d * 2) % mod\n        d = (temp_c * 2 + d * 2) % mod\n    return b if m == 1 else (a + c) % mod\n"
     },
     {
          "instruction": "Alice and Bob take turns playing a game with **Alice starting first**.\n\nIn this game, there are `n` piles of stones. On each player's turn, the player should remove any **positive** number of stones from a non-empty pile **of his or her choice**. The first player who cannot make a move loses, and the other player wins.\n\nGiven an integer array `piles`, where `piles[i]` is the number of stones in the `ith` pile, return `true` _if Alice wins, or_ `false` _if Bob wins_.\n\nBoth Alice and Bob play **optimally**.\n\n",
          "input": "**Example 1:**\n\n**Input:** piles = \\[1\\]\n**Output:** true\n**Explanation:** There is only one possible scenario:\n- On the first turn, Alice removes one stone from the first pile. piles = \\[0\\].\n- On the second turn, there are no stones left for Bob to remove. Alice wins.\n\n**Example 2:**\n\n**Input:** piles = \\[1,1\\]\n**Output:** false\n**Explanation:** It can be proven that Bob will always win. One possible scenario is:\n- On the first turn, Alice removes one stone from the first pile. piles = \\[0,1\\].\n- On the second turn, Bob removes one stone from the second pile. piles = \\[0,0\\].\n- On the third turn, there are no stones left for Alice to remove. Bob wins.\n\n**Example 3:**\n\n**Input:** piles = \\[1,2,3\\]\n**Output:** false\n**Explanation:** It can be proven that Bob will always win. One possible scenario is:\n- On the first turn, Alice removes three stones from the third pile. piles = \\[1,2,0\\].\n- On the second turn, Bob removes one stone from the second pile. piles = \\[1,1,0\\].\n- On the third turn, Alice removes one stone from the first pile. piles = \\[0,1,0\\].\n- On the fourth turn, Bob removes one stone from the second pile. piles = \\[0,0,0\\].\n- On the fifth turn, there are no stones left for Alice to remove. Bob wins.\n\n**Constraints:**\n\n*   `n == piles.length`\n*   `1 <= n <= 7`\n*   `1 <= piles[i] <= 7`\n\n**Follow-up:** Could you find a linear time solution? Although the linear time solution may be beyond the scope of an interview, it could be interesting to know.",
          "output": "def alice_wins(piles):\n    xor_sum = 0\n    for pile in piles:\n        xor_sum ^= pile\n    return xor_sum != 0\n"
     },
     {
          "instruction": "You are given an `m x n` integer matrix `points` (**0-indexed**). Starting with `0` points, you want to **maximize** the number of points you can get from the matrix.\n\nTo gain points, you must pick one cell in **each row**. Picking the cell at coordinates `(r, c)` will **add** `points[r][c]` to your score.\n\nHowever, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows `r` and `r + 1` (where `0 <= r < m - 1`), picking cells at coordinates `(r, c1)` and `(r + 1, c2)` will **subtract** `abs(c1 - c2)` from your score.\n\nReturn _the **maximum** number of points you can achieve_.\n\n`abs(x)` is defined as:\n\n*   `x` for `x >= 0`.\n*   `-x` for `x < 0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** points = \\[\\[1,2,3\\],\\[1,5,1\\],\\[3,1,1\\]\\]\n**Output:** 9\n**Explanation:**\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,5\\],\\[2,3\\],\\[4,2\\]\\]\n**Output:** 11\n**Explanation:**\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n\n**Constraints:**\n\n*   `m == points.length`\n*   `n == points[r].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `0 <= points[r][c] <= 105`",
          "output": "def maxPoints(points):\n    m, n = len(points), len(points[0])\n    dp = [0] * n\n    for row in points:\n        next_dp = [0] * n\n        for c1 in range(n):\n            score = dp[c1] + row[c1] - c1\n            for c2 in range(n):\n                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)\n        dp = next_dp\n    return max(dp)\n"
     },
     {
          "instruction": "There is a survey that consists of `n` questions where each question's answer is either `0` (no) or `1` (yes).\n\nThe survey was given to `m` students numbered from `0` to `m - 1` and `m` mentors numbered from `0` to `m - 1`. The answers of the students are represented by a 2D integer array `students` where `students[i]` is an integer array that contains the answers of the `ith` student (**0-indexed**). The answers of the mentors are represented by a 2D integer array `mentors` where `mentors[j]` is an integer array that contains the answers of the `jth` mentor (**0-indexed**).\n\nEach student will be assigned to **one** mentor, and each mentor will have **one** student assigned to them. The **compatibility score** of a student-mentor pair is the number of answers that are the same for both the student and the mentor.\n\n*   For example, if the student's answers were `[1, 0, 1]` and the mentor's answers were `[0, 0, 1]`, then their compatibility score is 2 because only the second and the third answers are the same.\n\nYou are tasked with finding the optimal student-mentor pairings to **maximize** the **sum of the compatibility scores**.\n\nGiven `students` and `mentors`, return _the **maximum compatibility score sum** that can be achieved._\n\n",
          "input": "**Example 1:**\n\n**Input:** students = \\[\\[1,1,0\\],\\[1,0,1\\],\\[0,0,1\\]\\], mentors = \\[\\[1,0,0\\],\\[0,0,1\\],\\[1,1,0\\]\\]\n**Output:** 8\n**Explanation:** We assign students to mentors in the following way:\n- student 0 to mentor 2 with a compatibility score of 3.\n- student 1 to mentor 0 with a compatibility score of 2.\n- student 2 to mentor 1 with a compatibility score of 3.\nThe compatibility score sum is 3 + 2 + 3 = 8.\n\n**Example 2:**\n\n**Input:** students = \\[\\[0,0\\],\\[0,0\\],\\[0,0\\]\\], mentors = \\[\\[1,1\\],\\[1,1\\],\\[1,1\\]\\]\n**Output:** 0\n**Explanation:** The compatibility score of any student-mentor pair is 0.\n\n**Constraints:**\n\n*   `m == students.length == mentors.length`\n*   `n == students[i].length == mentors[j].length`\n*   `1 <= m, n <= 8`\n*   `students[i][k]` is either `0` or `1`.\n*   `mentors[j][k]` is either `0` or `1`.",
          "output": "def count_different_subsequence_GCDs(nums):\n    maximum = max(nums)\n    gcd_count = [0] * (maximum + 1)\n    \n    for num in nums:\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                gcd_count[i] += 1\n                if i * i != num:\n                    gcd_count[num // i] += 1\n                    \n    different_GCDs = sum(1 for count in gcd_count if count > 0)\n    \n    return different_GCDs\n"
     },
     {
          "instruction": "You are currently designing a dynamic array. You are given a **0-indexed** integer array `nums`, where `nums[i]` is the number of elements that will be in the array at time `i`. In addition, you are given an integer `k`, the **maximum** number of times you can **resize** the array (to **any** size).\n\nThe size of the array at time `t`, `sizet`, must be at least `nums[t]` because there needs to be enough space in the array to hold all the elements. The **space wasted** at time `t` is defined as `sizet - nums[t]`, and the **total** space wasted is the **sum** of the space wasted across every time `t` where `0 <= t < nums.length`.\n\nReturn _the **minimum** **total space wasted** if you can resize the array at most_ `k` _times_.\n\n**Note:** The array can have **any size** at the start and does **not** count towards the number of resizing operations.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[10,20\\], k = 0\n**Output:** 10\n**Explanation:** size = \\[20,20\\].\nWe can set the initial size to be 20.\nThe total wasted space is (20 - 10) + (20 - 20) = 10.\n\n**Example 2:**\n\n**Input:** nums = \\[10,20,30\\], k = 1\n**Output:** 10\n**Explanation:** size = \\[20,20,30\\].\nWe can set the initial size to be 20 and resize to 30 at time 2. \nThe total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10.\n\n**Example 3:**\n\n**Input:** nums = \\[10,20,15,30,20\\], k = 2\n**Output:** 15\n**Explanation:** size = \\[10,20,20,30,30\\].\nWe can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3.\nThe total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 106`\n*   `0 <= k <= nums.length - 1`",
          "output": "def minSpaceWastedKResizing(nums, k):\n    n = len(nums)\n    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]\n    sum_nums = [0] * (n + 1)\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        sum_nums[i] = sum_nums[i - 1] + nums[i - 1]\n        max_val = nums[i - 1]\n        for j in range(i - 1, -1, -1):\n            max_val = max(max_val, nums[j])\n            waste = max_val * (i - j) - (sum_nums[i] - sum_nums[j])\n            for c in range(k):\n                dp[i][c + 1] = min(dp[i][c + 1], dp[j][c] + waste)\n\n    return dp[n][k]\n"
     },
     {
          "instruction": "You are given a string `sentence` containing words separated by spaces, and an integer `k`. Your task is to separate `sentence` into **rows** where the number of characters in each row is **at most** `k`. You may assume that `sentence` does not begin or end with a space, and the words in `sentence` are separated by a single space.\n\nYou can split `sentence` into rows by inserting line breaks between words in `sentence`. A word **cannot** be split between two rows. Each word must be used exactly once, and the word order cannot be rearranged. Adjacent words in a row should be separated by a single space, and rows should not begin or end with spaces.\n\nThe **cost** of a row with length `n` is `(k - n)2`, and the **total cost** is the sum of the **costs** for all rows **except** the last one.\n\n*   For example if `sentence = \"i love leetcode \"` and `k = 12`:\n    *   Separating `sentence` into `\"i \"`, `\"love \"`, and `\"leetcode \"` has a cost of `(12 - 1)2 + (12 - 4)2 = 185`.\n    *   Separating `sentence` into `\"i love \"`, and `\"leetcode \"` has a cost of `(12 - 6)2 = 36`.\n    *   Separating `sentence` into `\"i \"`, and `\"love leetcode \"` is not possible because the length of `\"love leetcode \"` is greater than `k`.\n\nReturn _the **minimum** possible total cost of separating_ `sentence` _into rows._\n\n",
          "input": "**Example 1:**\n\n**Input:** sentence =  \"i love leetcode \", k = 12\n**Output:** 36\n**Explanation:**\nSeparating sentence into  \"i \",  \"love \", and  \"leetcode \" has a cost of (12 - 1)2 + (12 - 4)2 = 185.\nSeparating sentence into  \"i love \", and  \"leetcode \" has a cost of (12 - 6)2 = 36.\nSeparating sentence into  \"i \",  \"love leetcode \" is not possible because  \"love leetcode \" has length 13.\n36 is the minimum possible total cost so return it.\n\n**Example 2:**\n\n**Input:** sentence =  \"apples and bananas taste great \", k = 7\n**Output:** 21\n**Explanation**\nSeparating sentence into  \"apples \",  \"and \",  \"bananas \",  \"taste \", and  \"great \" has a cost of (7 - 6)2 + (7 - 3)2 + (7 - 7)2 + (7 - 5)2 \\= 21.\n21 is the minimum possible total cost so return it.\n\n**Example 3:**\n\n**Input:** sentence =  \"a \", k = 5\n**Output:** 0\n**Explanation:**\nThe cost of the last row is not included in the total cost, and since there is only one row, return 0.\n\n**Constraints:**\n\n*   `1 <= sentence.length <= 5000`\n*   `1 <= k <= 5000`\n*   The length of each word in `sentence` is at most `k`.\n*   `sentence` consists of only lowercase English letters and spaces.\n*   `sentence` does not begin or end with a space.\n*   Words in `sentence` are separated by a single space.",
          "output": "def minCost(sentence: str, k: int) -> int:\n    words = sentence.split()\n    dp = [float('inf')] * (len(words) + 1)\n    dp[0] = 0\n    for i in range(len(words)):\n        length = 0\n        j = i\n        while j >= 0:\n            length += len(words[j])\n            if length + (i - j) <= k:\n                dp[i + 1] = min(dp[i + 1], dp[j] + (k - length - (i - j)) * (k - length - (i - j)))\n            else:\n                break\n            length += 1\n            j -= 1\n    return dp[-1]\n"
     },
     {
          "instruction": "A sequence is **special** if it consists of a **positive** number of `0`s, followed by a **positive** number of `1`s, then a **positive** number of `2`s.\n\n*   For example, `[0,1,2]` and `[0,0,1,1,1,2]` are special.\n*   In contrast, `[2,1,0]`, `[1]`, and `[0,1,2,0]` are not special.\n\nGiven an array `nums` (consisting of **only** integers `0`, `1`, and `2`), return _the **number of different subsequences** that are special_. Since the answer may be very large, **return it modulo** `109 + 7`.\n\nA **subsequence** of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are **different** if the **set of indices** chosen are different.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** The special subsequences are bolded \\[**0**,**1**,**2**,2\\], \\[**0**,**1**,2,**2**\\], and \\[**0**,**1**,**2**,**2**\\].\n\n**Example 2:**\n\n**Input:** nums = \\[2,2,0,0\\]\n**Output:** 0\n**Explanation:** There are no special subsequences in \\[2,2,0,0\\].\n\n**Example 3:**\n\n**Input:** nums = \\[0,1,2,0,1,2\\]\n**Output:** 7\n**Explanation:** The special subsequences are bolded:\n- \\[**0**,**1**,**2**,0,1,2\\]\n- \\[**0**,**1**,2,0,1,**2**\\]\n- \\[**0**,**1**,**2**,0,1,**2**\\]\n- \\[**0**,**1**,2,0,**1**,**2**\\]\n- \\[**0**,1,2,**0**,**1**,**2**\\]\n- \\[**0**,1,2,0,**1**,**2**\\]\n- \\[0,1,2,**0**,**1**,**2**\\]\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 2`",
          "output": "import heapq\n\nclass SeatManager:\n    def __init__(self, n: int):\n        self.available_seats = [i for i in range(1, n + 1)]\n        heapq.heapify(self.available_seats)\n\n    def reserve(self) -> int:\n        return heapq.heappop(self.available_seats)\n\n    def unreserve(self, seatNumber: int) -> None:\n        heapq.heappush(self.available_seats, seatNumber)\n"
     },
     {
          "instruction": "You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u00e2\u017e\u009d 6\n- 0 \u00e2\u017e\u009d 4 \u00e2\u017e\u009d 6\n- 0 \u00e2\u017e\u009d 1 \u00e2\u017e\u009d 2 \u00e2\u017e\u009d 5 \u00e2\u017e\u009d 6\n- 0 \u00e2\u017e\u009d 1 \u00e2\u017e\u009d 3 \u00e2\u017e\u009d 5 \u00e2\u017e\u009d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.",
          "output": "def can_split_string(s: str) -> bool:\n    count = [0] * 10\n\n    for c in s:\n        count[int(c)] += 1\n\n    for i in range(1, 10):\n        if count[i] > 0 and count[i] == count[i - 1]:\n            return True\n\n    return False\n"
     },
     {
          "instruction": "You wrote down many **positive** integers in a string called `num`. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was **non-decreasing** and that **no** integer had leading zeros.\n\nReturn _the **number of possible lists of integers** that you could have written down to get the string_ `num`. Since the answer may be large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** num =  \"327 \"\n**Output:** 2\n**Explanation:** You could have written down the numbers:\n3, 27\n327\n\n**Example 2:**\n\n**Input:** num =  \"094 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n**Example 3:**\n\n**Input:** num =  \"0 \"\n**Output:** 0\n**Explanation:** No numbers can have leading zeros and all numbers must be positive.\n\n**Constraints:**\n\n*   `1 <= num.length <= 3500`\n*   `num` consists of digits `'0'` through `'9'`.",
          "output": "def intervalFinding(intervals, queries):\n    intervals.sort(key=lambda x: x[0])\n    ans = []\n    for q in queries:\n        min_size = float('inf')\n        for interval in intervals:\n            if interval[0] <= q <= interval[1]:\n                min_size = min(min_size, interval[1] - interval[0] + 1)\n        ans.append(-1 if min_size == float('inf') else min_size)\n    return ans\n"
     },
     {
          "instruction": "You are given an integer array `nums`. We call a subset of `nums` **good** if its product can be represented as a product of one or more **distinct prime** numbers.\n\n*   For example, if `nums = [1, 2, 3, 4]`:\n    *   `[2, 3]`, `[1, 2, 3]`, and `[1, 3]` are **good** subsets with products `6 = 2*3`, `6 = 2*3`, and `3 = 3` respectively.\n    *   `[1, 4]` and `[4]` are not **good** subsets with products `4 = 2*2` and `4 = 2*2` respectively.\n\nReturn _the number of different **good** subsets in_ `nums` _**modulo**_ `109 + 7`.\n\nA **subset** of `nums` is any array that can be obtained by deleting some (possibly none or all) elements from `nums`. Two subsets are different if and only if the chosen indices to delete are different.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 6\n**Explanation:** The good subsets are:\n- \\[1,2\\]: product is 2, which is the product of distinct prime 2.\n- \\[1,2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[1,3\\]: product is 3, which is the product of distinct prime 3.\n- \\[2\\]: product is 2, which is the product of distinct prime 2.\n- \\[2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[3\\]: product is 3, which is the product of distinct prime 3.\n\n**Example 2:**\n\n**Input:** nums = \\[4,2,3,15\\]\n**Output:** 5\n**Explanation:** The good subsets are:\n- \\[2\\]: product is 2, which is the product of distinct prime 2.\n- \\[2,3\\]: product is 6, which is the product of distinct primes 2 and 3.\n- \\[2,15\\]: product is 30, which is the product of distinct primes 2, 3, and 5.\n- \\[3\\]: product is 3, which is the product of distinct prime 3.\n- \\[15\\]: product is 15, which is the product of distinct primes 3 and 5.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 30`",
          "output": "def min_swaps(s: str) -> int:\n    zeros, ones = 0, 0\n    for c in s:\n        if c == '0':\n            zeros += 1\n        else:\n            ones += 1\n\n    if abs(zeros - ones) > 1:\n        return -1\n\n    mismatch_count1, mismatch_count2 = 0, 0\n    for i, c in enumerate(s):\n        if i % 2 == 0:\n            if c != '0': mismatch_count1 += 1\n            if c != '1': mismatch_count2 += 1\n        else:\n            if c != '1': mismatch_count1 += 1\n            if c != '0': mismatch_count2 += 1\n\n    return min(mismatch_count1, mismatch_count2) // 2\n"
     },
     {
          "instruction": "You are given an `m x n` integer matrix `mat` and an integer `target`.\n\nChoose one integer from **each row** in the matrix such that the **absolute difference** between `target` and the **sum** of the chosen elements is **minimized**.\n\nReturn _the **minimum absolute difference**_.\n\nThe **absolute difference** between two numbers `a` and `b` is the absolute value of `a - b`.\n\n",
          "input": "**Example 1:**\n\n**Input:** mat = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], target = 13\n**Output:** 0\n**Explanation:** One possible choice is to:\n- Choose 1 from the first row.\n- Choose 5 from the second row.\n- Choose 7 from the third row.\nThe sum of the chosen elements is 13, which equals the target, so the absolute difference is 0.\n\n**Example 2:**\n\n**Input:** mat = \\[\\[1\\],\\[2\\],\\[3\\]\\], target = 100\n**Output:** 94\n**Explanation:** The best possible choice is to:\n- Choose 1 from the first row.\n- Choose 2 from the second row.\n- Choose 3 from the third row.\nThe sum of the chosen elements is 6, and the absolute difference is 94.\n\n**Example 3:**\n\n**Input:** mat = \\[\\[1,2,9,8,7\\]\\], target = 6\n**Output:** 1\n**Explanation:** The best choice is to choose 7 from the first row.\nThe absolute difference is 1.\n\n**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 70`\n*   `1 <= mat[i][j] <= 70`\n*   `1 <= target <= 800`",
          "output": "def minimizeTheDifference(mat, target):\n    m, n = len(mat), len(mat[0])\n    dp = [[0 for _ in range(800 * 70 + 1)] for _ in range(m)]\n    dp[0] = mat[0]\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(800 * 70, 0, -1):\n                if k - mat[i][j] >= 0 and dp[i - 1][k - mat[i][j]]:\n                    dp[i][k] = 1\n\n    min_diff = float('inf')\n    for k in range(800 * 70 + 1):\n        if dp[-1][k]:\n            min_diff = min(min_diff, abs(k - target))\n\n    return min_diff\n"
     },
     {
          "instruction": "There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n",
          "input": "**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`",
          "output": "from collections import defaultdict\n\n\ndef largestPathValue(colors, edges):\n    def dfs(node):\n        if not cache[node][ord(colors[node]) - ord('a')]:\n            cache[node][ord(colors[node]) - ord('a')] = 1\n            for neighbor in graph[node]:\n                cache[node][ord(colors[node]) - ord('a')] = max(cache[node][ord(colors[node]) - ord('a')],\n                                                               1 + dfs(neighbor))\n        return cache[node][ord(colors[node]) - ord('a')]\n\n    n = len(colors)\n    graph = [set() for _ in range(n)]\n    for a, b in edges:\n        graph[a].add(b)\n\n    cache = [[0] * 26 for _ in range(n)]\n    in_degree = [0] * n\n    for a, b in edges:\n        in_degree[b] += 1\n    res = -1\n    for i in range(n):\n        if in_degree[i] == 0:\n            res = max(res, dfs(i))\n    return res\n"
     },
     {
          "instruction": "You are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0 \"`).\n\nFind the number of **unique good subsequences** of `binary`.\n\n*   For example, if `binary = \"001 \"`, then all the **good** subsequences are `[ \"0 \", \"0 \", \"1 \"]`, so the **unique** good subsequences are `\"0 \"` and `\"1 \"`. Note that subsequences `\"00 \"`, `\"01 \"`, and `\"001 \"` are not good because they have leading zeros.\n\nReturn _the number of **unique good subsequences** of_ `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n",
          "input": "**Example 1:**\n\n**Input:** binary =  \"001 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"0 \",  \"0 \",  \"1 \"\\].\nThe unique good subsequences are  \"0 \" and  \"1 \".\n\n**Example 2:**\n\n**Input:** binary =  \"11 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"1 \",  \"11 \"\\].\nThe unique good subsequences are  \"1 \" and  \"11 \".\n\n**Example 3:**\n\n**Input:** binary =  \"101 \"\n**Output:** 5\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"0 \",  \"1 \",  \"10 \",  \"11 \",  \"101 \"\\]. \nThe unique good subsequences are  \"0 \",  \"1 \",  \"10 \",  \"11 \", and  \"101 \".\n\n**Constraints:**\n\n*   `1 <= binary.length <= 105`\n*   `binary` consists of only `'0'`s and `'1'`s.",
          "output": "def count_good_substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            count += 1\n    return count\n"
     },
     {
          "instruction": "There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi.\n\nThe passengers are represented by a **0-indexed** 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip.\n\nFor **each** passenger `i` you pick up, you **earn** `endi - starti + tipi` dollars. You may only drive **at most one** passenger at a time.\n\nGiven `n` and `rides`, return _the **maximum** number of dollars you can earn by picking up the passengers optimally._\n\n**Note:** You may drop off a passenger and pick up a different passenger at the same point.\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 5, rides = \\[\\[2,5,4\\],\\[1,5,1\\]\\]\n**Output:** 7\n**Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n\n**Example 2:**\n\n**Input:** n = 20, rides = \\[\\[1,6,1\\],\\[3,10,2\\],\\[10,12,3\\],\\[11,12,2\\],\\[12,15,2\\],\\[13,18,1\\]\\]\n**Output:** 20\n**Explanation:** We will pick up the following passengers:\n- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\nWe earn 9 + 5 + 6 = 20 dollars in total.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= rides.length <= 3 * 104`\n*   `rides[i].length == 3`\n*   `1 <= starti < endi <= n`\n*   `1 <= tipi <= 105`",
          "output": "def minOperationsToFlip(expression: str) -> int:\n    zero, one, op = [0], [0], []\n    for c in expression:\n        if c == '&':\n            op.append(1)\n        elif c == '|':\n            op.append(2)\n        elif c.isdigit():\n            if c == '0':\n                one.append(1)\n                zero.append(0)\n            else:\n                zero.append(1)\n                one.append(0)\n        elif c == ')':\n            cur_op = op.pop()\n            x = zero.pop()\n            y = one.pop() + 1\n            if cur_op == 1:\n                new_zero = max(x, y)\n                new_one = one[-1] + min(x, zero[-1])\n            else:\n                new_zero = zero[-1] + min(x, one[-1])\n                new_one = max(y, one[-1])\n            zero.pop()\n            one.pop()\n            zero.append(new_zero)\n            one.append(new_one)\n    return zero[-1] + 1\n"
     },
     {
          "instruction": "There are `n` rooms you need to visit, labeled from `0` to `n - 1`. Each day is labeled, starting from `0`. You will go in and visit one room a day.\n\nInitially on day `0`, you visit room `0`. The **order** you visit the rooms for the coming days is determined by the following **rules** and a given **0-indexed** array `nextVisit` of length `n`:\n\n*   Assuming that on a day, you visit room `i`,\n*   if you have been in room `i` an **odd** number of times (**including** the current visit), on the **next** day you will visit a room with a **lower or equal room number** specified by `nextVisit[i]` where `0 <= nextVisit[i] <= i`;\n*   if you have been in room `i` an **even** number of times (**including** the current visit), on the **next** day you will visit room `(i + 1) mod n`.\n\nReturn _the label of the **first** day where you have been in **all** the rooms_. It can be shown that such a day exists. Since the answer may be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** nextVisit = \\[0,0\\]\n**Output:** 2\n**Explanation:**\n- On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd.\n  On the next day you will visit room nextVisit\\[0\\] = 0\n- On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even.\n  On the next day you will visit room (0 + 1) mod 2 = 1\n- On day 2, you visit room 1. This is the first day where you have been in all the rooms.\n\n**Example 2:**\n\n**Input:** nextVisit = \\[0,0,2\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,0,0,1,2,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Example 3:**\n\n**Input:** nextVisit = \\[0,1,2,0\\]\n**Output:** 6\n**Explanation:**\nYour room visiting order for each day is: \\[0,0,1,1,2,2,3,...\\].\nDay 6 is the first day where you have been in all the rooms.\n\n**Constraints:**\n\n*   `n == nextVisit.length`\n*   `2 <= n <= 105`\n*   `0 <= nextVisit[i] <= i`",
          "output": "def firstDayBeenInAllRooms(nextVisit):\n    n = len(nextVisit)\n    MOD = 10**9 + 7\n    dp = [0] * n\n\n    for i in range(1, n):\n        dp[i] = (dp[i - 1] * 2 - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[n - 1]\n"
     },
     {
          "instruction": "Given a string `s`, find two **disjoint palindromic subsequences** of `s` such that the **product** of their lengths is **maximized**. The two subsequences are **disjoint** if they do not both pick a character at the same index.\n\nReturn _the **maximum** possible **product** of the lengths of the two palindromic subsequences_.\n\nA **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is **palindromic** if it reads the same forward and backward.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"leetcodecom \"\n**Output:** 9\n**Explanation**: An optimal solution is to choose  \"ete \" for the 1st subsequence and  \"cdc \" for the 2nd subsequence.\nThe product of their lengths is: 3 \\* 3 = 9.\n\n**Example 2:**\n\n**Input:** s =  \"bb \"\n**Output:** 1\n**Explanation**: An optimal solution is to choose  \"b \" (the first character) for the 1st subsequence and  \"b \" (the second character) for the 2nd subsequence.\nThe product of their lengths is: 1 \\* 1 = 1.\n\n**Example 3:**\n\n**Input:** s =  \"accbcaxxcxx \"\n**Output:** 25\n**Explanation**: An optimal solution is to choose  \"accca \" for the 1st subsequence and  \"xxcxx \" for the 2nd subsequence.\nThe product of their lengths is: 5 \\* 5 = 25.\n\n**Constraints:**\n\n*   `2 <= s.length <= 12`\n*   `s` consists of lowercase English letters only.",
          "output": "def stoneGameVII(stones):\n    n = len(stones)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            dp[i][j] = max(stones[i] - dp[i + 1][j], stones[j] - dp[i][j - 1])\n\n    return dp[0][n - 1]\n"
     },
     {
          "instruction": "There is a **family tree** rooted at `0` consisting of `n` nodes numbered `0` to `n - 1`. You are given a **0-indexed** integer array `parents`, where `parents[i]` is the parent for node `i`. Since node `0` is the **root**, `parents[0] == -1`.\n\nThere are `105` genetic values, each represented by an integer in the **inclusive** range `[1, 105]`. You are given a **0-indexed** integer array `nums`, where `nums[i]` is a **distinct** genetic value for node `i`.\n\nReturn _an array_ `ans` _of length_ `n` _where_ `ans[i]` _is_ _the **smallest** genetic value that is **missing** from the subtree rooted at node_ `i`.\n\nThe **subtree** rooted at a node `x` contains node `x` and all of its **descendant** nodes.\n\n",
          "input": "**Example 1:**\n\n**Input:** parents = \\[-1,0,0,2\\], nums = \\[1,2,3,4\\]\n**Output:** \\[5,1,1,1\\]\n**Explanation:** The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes \\[0,1,2,3\\] with values \\[1,2,3,4\\]. 5 is the smallest missing value.\n- 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value.\n- 2: The subtree contains nodes \\[2,3\\] with values \\[3,4\\]. 1 is the smallest missing value.\n- 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value.\n\n**Example 2:**\n\n**Input:** parents = \\[-1,0,1,0,3,3\\], nums = \\[5,4,6,2,1,3\\]\n**Output:** \\[7,1,1,4,2,1\\]\n**Explanation:** The answer for each subtree is calculated as follows:\n- 0: The subtree contains nodes \\[0,1,2,3,4,5\\] with values \\[5,4,6,2,1,3\\]. 7 is the smallest missing value.\n- 1: The subtree contains nodes \\[1,2\\] with values \\[4,6\\]. 1 is the smallest missing value.\n- 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value.\n- 3: The subtree contains nodes \\[3,4,5\\] with values \\[2,1,3\\]. 4 is the smallest missing value.\n- 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value.\n- 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value.\n\n**Example 3:**\n\n**Input:** parents = \\[-1,2,3,0,2,4,1\\], nums = \\[2,3,4,5,6,7,8\\]\n**Output:** \\[1,1,1,1,1,1,1\\]\n**Explanation:** The value 1 is missing from all the subtrees.\n\n**Constraints:**\n\n*   `n == parents.length == nums.length`\n*   `2 <= n <= 105`\n*   `0 <= parents[i] <= n - 1` for `i != 0`\n*   `parents[0] == -1`\n*   `parents` represents a valid tree.\n*   `1 <= nums[i] <= 105`\n*   Each `nums[i]` is distinct.",
          "output": "from collections import defaultdict\n\ndef smallestMissingValueSubtree(parents, nums):\n    n = len(parents)\n    children = defaultdict(set)\n    for i in range(1, n):\n        children[parents[i]].add(nums[i])\n\n    ans = [0] * n\n    dfs(0, parents, nums, children, ans)\n    return ans\n\ndef dfs(node, parents, nums, children, ans):\n    for child in list(children[node]):\n        dfs(child, parents, nums, children, ans)\n        children[node].remove(child)\n        children[node].add(ans[child])\n    it = next((x for x in children[node] if x > nums[node]), nums[node] + 1)\n    ans[node] = it - 1 if it != nums[node] + 1 else it\n"
     },
     {
          "instruction": "You are given a string `s` that contains digits `0-9`, addition symbols `'+'`, and multiplication symbols `'*'` **only**, representing a **valid** math expression of **single digit numbers** (e.g., `3+5*2`). This expression was given to `n` elementary school students. The students were instructed to get the answer of the expression by following this **order of operations**:\n\n1.  Compute **multiplication**, reading from **left to right**; Then,\n2.  Compute **addition**, reading from **left to right**.\n\nYou are given an integer array `answers` of length `n`, which are the submitted answers of the students in no particular order. You are asked to grade the `answers`, by following these **rules**:\n\n*   If an answer **equals** the correct answer of the expression, this student will be rewarded `5` points;\n*   Otherwise, if the answer **could be interpreted** as if the student applied the operators **in the wrong order** but had **correct arithmetic**, this student will be rewarded `2` points;\n*   Otherwise, this student will be rewarded `0` points.\n\nReturn _the sum of the points of the students_.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"7+3\\*1\\*2 \", answers = \\[20,13,42\\]\n**Output:** 7\n**Explanation:** As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: \\[20,**13**,42\\]\nA student might have applied the operators in this wrong order: ((7+3)\\*1)\\*2 = 20. Therefore one student is rewarded 2 points: \\[**20**,13,42\\]\nThe points for the students are: \\[2,5,0\\]. The sum of the points is 2+5+0=7.\n\n**Example 2:**\n\n**Input:** s =  \"3+5\\*2 \", answers = \\[13,0,10,13,13,16,16\\]\n**Output:** 19\n**Explanation:** The correct answer of the expression is 13, therefore three students are rewarded 5 points each: \\[**13**,0,10,**13**,**13**,16,16\\]\nA student might have applied the operators in this wrong order: ((3+5)\\*2 = 16. Therefore two students are rewarded 2 points: \\[13,0,10,13,13,**16**,**16**\\]\nThe points for the students are: \\[5,0,0,5,5,2,2\\]. The sum of the points is 5+0+0+5+5+2+2=19.\n\n**Example 3:**\n\n**Input:** s =  \"6+0\\*1 \", answers = \\[12,9,6,4,8,6\\]\n**Output:** 10\n**Explanation:** The correct answer of the expression is 6.\nIf a student had incorrectly done (6+0)\\*1, the answer would also be 6.\nBy the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points.\nThe points for the students are: \\[0,0,5,0,0,5\\]. The sum of the points is 10.\n\n**Constraints:**\n\n*   `3 <= s.length <= 31`\n*   `s` represents a valid expression that contains only digits `0-9`, `'+'`, and `'*'` only.\n*   All the integer operands in the expression are in the **inclusive** range `[0, 9]`.\n*   `1 <=` The count of all operators (`'+'` and `'*'`) in the math expression `<= 15`\n*   Test data are generated such that the correct answer of the expression is in the range of `[0, 1000]`.\n*   `n == answers.length`\n*   `1 <= n <= 104`\n*   `0 <= answers[i] <= 1000`",
          "output": "def sumOfPoints(s: str, answers: List[int]) -> int:\n    correct = 0\n    mul = 1\n    add = 0\n    for i in range(len(s)):\n        if s[i].isdigit():\n            num = int(s[i])\n            mul *= num\n            if i == len(s) - 1 or s[i + 1] == '+':\n                add += mul\n                mul = 1\n    correct = add\n\n    wrongOrder = int(s[0])\n    for i in range(2, len(s), 2):\n        if s[i - 1] == '+':\n            wrongOrder += int(s[i])\n        else:\n            wrongOrder *= int(s[i])\n\n    return sum(5 * (ans == correct) + 2 * (ans == wrongOrder) for ans in answers)\n"
     },
     {
          "instruction": "A **Fibonacci** tree is a binary tree created using the order function `order(n)`:\n\n*   `order(0)` is the empty tree.\n*   `order(1)` is a binary tree with only **one node**.\n*   `order(n)` is a binary tree that consists of a root node with the left subtree as `order(n - 2)` and the right subtree as `order(n - 1)`.\n\nAlice and Bob are playing a game with a **Fibonacci** tree with Alice staring first. On each turn, a player selects a node and removes that node **and** its subtree. The player that is forced to delete `root` loses.\n\nGiven the integer `n`, return `true` if Alice wins the game or `false` if Bob wins, assuming both players play optimally.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\n\n",
          "input": "**Example 1:**  \n\n**Input:** n = 3\n**Output:** true\n**Explanation:**\nAlice takes the node 1 in the right subtree.\nBob takes either the 1 in the left subtree or the 2 in the right subtree.\nAlice takes whichever node Bob doesn't take.\nBob is forced to take the root node 3, so Bob will lose.\nReturn true because Alice wins.\n\n**Example 2:**  \n\n**Input:** n = 1\n**Output:** false\n**Explanation:**\nAlice is forced to take the root node 1, so Alice will lose.\nReturn false because Alice loses.\n\n**Example 3:**  \n\n**Input:** n = 2\n**Output:** true\n**Explanation:**\nAlice takes the node 1.\nBob is forced to take the root node 2, so Bob will lose.\nReturn true because Alice wins.\n\n**Constraints:**\n\n*   `1 <= n <= 100`",
          "output": "def is_covered(ranges, left, right):\n    for i in range(left, right + 1):\n        is_covered = False\n        for range_ in ranges:\n            if i >= range_[0] and i <= range_[1]:\n                is_covered = True\n                break\n        if not is_covered:\n            return False\n    return True\n"
     },
     {
          "instruction": "You are given an integer array `nums` of `2 * n` integers. You need to partition `nums` into **two** arrays of length `n` to **minimize the absolute difference** of the **sums** of the arrays. To partition `nums`, put each element of `nums` into **one** of the two arrays.\n\nReturn _the **minimum** possible absolute difference_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,9,7,3\\]\n**Output:** 2\n**Explanation:** One optimal partition is: \\[3,9\\] and \\[7,3\\].\nThe absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.\n\n**Example 2:**\n\n**Input:** nums = \\[-36,36\\]\n**Output:** 72\n**Explanation:** One optimal partition is: \\[-36\\] and \\[36\\].\nThe absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.\n\n**Example 3:**\n\n**Input:** nums = \\[2,-1,0,4,-2,-9\\]\n**Output:** 0\n**Explanation:** One optimal partition is: \\[2,4,-9\\] and \\[-1,0,-2\\].\nThe absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.\n\n**Constraints:**\n\n*   `1 <= n <= 15`\n*   `nums.length == 2 * n`\n*   `-107 <= nums[i] <= 107`",
          "output": "def countSubIslands(grid1, grid2):\n    def dfs(i, j):\n        if i < 0 or i >= len(grid1) or j < 0 or j >= len(grid1[0]) or grid2[i][j] == 0:\n            return True\n\n        grid2[i][j] = 0\n\n        isSubIsland = grid1[i][j] == 1\n        isSubIsland &= dfs(i + 1, j)\n        isSubIsland &= dfs(i - 1, j)\n        isSubIsland &= dfs(i, j + 1)\n        isSubIsland &= dfs(i, j - 1)\n\n        return isSubIsland\n\n    count = 0\n\n    for i in range(len(grid1)):\n        for j in range(len(grid1[0])):\n            if grid2[i][j] == 1 and dfs(i, j):\n                count += 1\n\n    return count\n"
     },
     {
          "instruction": "You are given a **0-indexed** 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose **at most** **two** **non-overlapping** events to attend such that the sum of their values is **maximized**.\n\nReturn _this **maximum** sum._\n\nNote that the start time and end time is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.\n\n",
          "input": "**Example 1:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[2,4,3\\]\\]\n**Output:** 4\n**Explanation:** Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,3,2\\],\\[4,5,2\\],\\[1,5,5\\]\\]\n**Output:** 5\n**Explanation:** Choose event 2 for a sum of 5.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,5,3\\],\\[1,5,1\\],\\[6,6,5\\]\\]\n**Output:** 8\n**Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n**Constraints:**\n\n*   `2 <= events.length <= 105`\n*   `events[i].length == 3`\n*   `1 <= startTimei <= endTimei <= 109`\n*   `1 <= valuei <= 106`",
          "output": "def find_chair(times, target_friend):\n    n = len(times)\n    events = []\n    for i, (arrival, leaving) in enumerate(times):\n        events.append((arrival, i))\n        events.append((leaving, ~i))\n    events.sort()\n    chairs = [-1] * n\n    available_chairs = sorted(range(n))\n    for time, friend_id in events:\n        if friend_id >= 0:\n            chairs[friend_id] = available_chairs.pop(0)\n            if friend_id == target_friend:\n                return chairs[friend_id]\n        else:\n            available_chairs.append(chairs[~friend_id])\n            available_chairs.sort()\n    return -1\n"
     },
     {
          "instruction": "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n",
          "input": "**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.",
          "output": "def count_good_digit_strings(n):\n    mod = 10 ** 9 + 7\n    even_digits, prime_digits = 5, 4\n    total = 1\n    for i in range(n):\n        total = total * (even_digits if i % 2 == 0 else prime_digits) % mod\n    return total\n"
     },
     {
          "instruction": "An original string, consisting of lowercase English letters, can be encoded by the following steps:\n\n*   Arbitrarily **split** it into a **sequence** of some number of **non-empty** substrings.\n*   Arbitrarily choose some elements (possibly none) of the sequence, and **replace** each with **its length** (as a numeric string).\n*   **Concatenate** the sequence as the encoded string.\n\nFor example, **one way** to encode an original string `\"abcdefghijklmnop \"` might be:\n\n*   Split it as a sequence: `[ \"ab \", \"cdefghijklmn \", \"o \", \"p \"]`.\n*   Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes `[ \"ab \", \"12 \", \"1 \", \"p \"]`.\n*   Concatenate the elements of the sequence to get the encoded string: `\"ab121p \"`.\n\nGiven two encoded strings `s1` and `s2`, consisting of lowercase English letters and digits `1-9` (inclusive), return `true` _if there exists an original string that could be encoded as **both**_ `s1` _and_ `s2`_. Otherwise, return_ `false`.\n\n**Note**: The test cases are generated such that the number of consecutive digits in `s1` and `s2` does not exceed `3`.\n\n",
          "input": "**Example 1:**\n\n**Input:** s1 =  \"internationalization \", s2 =  \"i18n \"\n**Output:** true\n**Explanation:** It is possible that  \"internationalization \" was the original string.\n-  \"internationalization \" \n  -> Split:       \\[ \"internationalization \"\\]\n  -> Do not replace any element\n  -> Concatenate:   \"internationalization \", which is s1.\n-  \"internationalization \"\n  -> Split:       \\[ \"i \",  \"nternationalizatio \",  \"n \"\\]\n  -> Replace:     \\[ \"i \",  \"18 \",                  \"n \"\\]\n  -> Concatenate:   \"i18n \", which is s2\n\n**Example 2:**\n\n**Input:** s1 =  \"l123e \", s2 =  \"44 \"\n**Output:** true\n**Explanation:** It is possible that  \"leetcode \" was the original string.\n-  \"leetcode \" \n  -> Split:      \\[ \"l \",  \"e \",  \"et \",  \"cod \",  \"e \"\\]\n  -> Replace:    \\[ \"l \",  \"1 \",  \"2 \",   \"3 \",    \"e \"\\]\n  -> Concatenate:  \"l123e \", which is s1.\n-  \"leetcode \" \n  -> Split:      \\[ \"leet \",  \"code \"\\]\n  -> Replace:    \\[ \"4 \",     \"4 \"\\]\n  -> Concatenate:  \"44 \", which is s2.\n\n**Example 3:**\n\n**Input:** s1 =  \"a5b \", s2 =  \"c5b \"\n**Output:** false\n**Explanation:** It is impossible.\n- The original string encoded as s1 must start with the letter 'a'.\n- The original string encoded as s2 must start with the letter 'c'.\n\n**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 40`\n*   `s1` and `s2` consist of digits `1-9` (inclusive), and lowercase English letters only.\n*   The number of consecutive digits in `s1` and `s2` does not exceed `3`.",
          "output": "def merge_trees(trees):\n    while len(trees) > 1:\n        tree1 = trees.pop()\n        tree2 = trees.pop()\n\n        if tree1.val < tree2.val:\n            tree1.right = tree2\n            trees.append(tree1)\n        else:\n            tree2.right = tree1\n            trees.append(tree2)\n    return None if not trees else trees[0]\n"
     },
     {
          "instruction": "Given a string `word`, return _the **sum of the number of vowels** (_`'a'`, `'e'`_,_ `'i'`_,_ `'o'`_, and_ `'u'`_)_ _in every substring of_ `word`.\n\nA **substring** is a contiguous (non-empty) sequence of characters within a string.\n\n**Note:** Due to the large constraints, the answer may not fit in a signed 32-bit integer. Please be careful during the calculations.\n\n",
          "input": "**Example 1:**\n\n**Input:** word =  \"aba \"\n**Output:** 6\n**Explanation:** \nAll possible substrings are:  \"a \",  \"ab \",  \"aba \",  \"b \",  \"ba \", and  \"a \".\n-  \"b \" has 0 vowels in it\n-  \"a \",  \"ab \",  \"ba \", and  \"a \" have 1 vowel each\n-  \"aba \" has 2 vowels in it\nHence, the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. \n\n**Example 2:**\n\n**Input:** word =  \"abc \"\n**Output:** 3\n**Explanation:** \nAll possible substrings are:  \"a \",  \"ab \",  \"abc \",  \"b \",  \"bc \", and  \"c \".\n-  \"a \",  \"ab \", and  \"abc \" have 1 vowel each\n-  \"b \",  \"bc \", and  \"c \" have 0 vowels each\nHence, the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.\n\n**Example 3:**\n\n**Input:** word =  \"ltcd \"\n**Output:** 0\n**Explanation:** There are no vowels in any substring of  \"ltcd \".\n\n**Constraints:**\n\n*   `1 <= word.length <= 105`\n*   `word` consists of lowercase English letters.",
          "output": "def count_vowels(word):\n    sum = 0\n    count = 0\n    for letter in word:\n        if letter in \"aeiou\":\n            count += 1\n        sum += count\n    return sum\n\ndef count_vowels_in_substrings(word):\n    return count_vowels(word)\n"
     },
     {
          "instruction": "A farmer has a **rectangular grid** of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either **fertile** (represented by a `1`) or **barren** (represented by a `0`). All cells outside the grid are considered barren.\n\nA **pyramidal plot** of land can be defined as a set of cells with the following criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h - 1` **and** `c - (i - r) <= j <= c + (i - r)`.\n\nAn **inverse pyramidal plot** of land can be defined as a set of cells with similar criteria:\n\n1.  The number of cells in the set has to be **greater than** `1` and all cells must be **fertile**.\n2.  The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r - h + 1 <= i <= r` **and** `c - (r - i) <= j <= c + (r - i)`.\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.\n\nGiven a **0-indexed** `m x n` binary matrix `grid` representing the farmland, return _the **total number** of pyramidal and inverse pyramidal plots that can be found in_ `grid`.\n\n",
          "input": "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[1,1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively.\nThere are no inverse pyramidal plots in this grid. \nHence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[1,1,1\\]\\]\n**Output:** 2\n**Explanation:** The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. \nHence the total number of plots is 1 + 1 = 2.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1,1,0\\],\\[1,1,1,1,1\\],\\[1,1,1,1,1\\],\\[0,1,0,0,1\\]\\]\n**Output:** 13\n**Explanation:** There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.\nThere are 6 inverse pyramidal plots, 2 of which are shown in the last figure.\nThe total number of plots is 7 + 6 = 13.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `grid[i][j]` is either `0` or `1`.",
          "output": "def min_time_to_type(word: str) -> int:\n    time, prev = 0, 0\n    for c in word:\n        pos = ord(c) - ord('a')\n        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1\n        prev = pos\n    return time\n"
     },
     {
          "instruction": "You and a gang of thieves are planning on robbing a bank. You are given a **0-indexed** integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`.\n\nThe `ith` day is a good day to rob the bank if:\n\n*   There are at least `time` days before and after the `ith` day,\n*   The number of guards at the bank for the `time` days **before** `i` are **non-increasing**, and\n*   The number of guards at the bank for the `time` days **after** `i` are **non-decreasing**.\n\nMore formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]`.\n\nReturn _a list of **all** days **(0-indexed)** that are good days to rob the bank_. _The order that the days are returned in does **not** matter._\n\n",
          "input": "**Example 1:**\n\n**Input:** security = \\[5,3,3,3,5,6,2\\], time = 2\n**Output:** \\[2,3\\]\n**Explanation:**\nOn day 2, we have security\\[0\\] >= security\\[1\\] >= security\\[2\\] <= security\\[3\\] <= security\\[4\\].\nOn day 3, we have security\\[1\\] >= security\\[2\\] >= security\\[3\\] <= security\\[4\\] <= security\\[5\\].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\n**Example 2:**\n\n**Input:** security = \\[1,1,1,1,1\\], time = 0\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:**\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\n**Example 3:**\n\n**Input:** security = \\[1,2,3,4,5,6\\], time = 2\n**Output:** \\[\\]\n**Explanation:**\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n**Constraints:**\n\n*   `1 <= security.length <= 105`\n*   `0 <= security[i], time <= 105`",
          "output": "def minNonZeroProduct(p):\n    MOD = 10**9 + 7\n    prod = 1\n    a = (1 << p) - 2\n    b = ((1 << p) - 1) % MOD\n       \n    while a > 0:\n        if a % 2:\n            prod = (prod * b) % MOD\n        b = (b * b) % MOD\n        a //= 2\n    return prod\n"
     },
     {
          "instruction": "You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.\n\nA **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.\n\nReturn _the number of **smooth descent periods**_.\n\n",
          "input": "**Example 1:**\n\n**Input:** prices = \\[3,2,1,4\\]\n**Output:** 7\n**Explanation:** There are 7 smooth descent periods:\n\\[3\\], \\[2\\], \\[1\\], \\[4\\], \\[3,2\\], \\[2,1\\], and \\[3,2,1\\]\nNote that a period with one day is a smooth descent period by the definition.\n\n**Example 2:**\n\n**Input:** prices = \\[8,6,7,7\\]\n**Output:** 4\n**Explanation:** There are 4 smooth descent periods: \\[8\\], \\[6\\], \\[7\\], and \\[7\\]\nNote that \\[8,6\\] is not a smooth descent period as 8 - 6 \u00e2\u2030\u00a0 1.\n\n**Example 3:**\n\n**Input:** prices = \\[1\\]\n**Output:** 1\n**Explanation:** There is 1 smooth descent period: \\[1\\]\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `1 <= prices[i] <= 105`",
          "output": "def num_smooth_descent_periods(prices):\n    result = 0\n    count = 0\n    for i in range(1, len(prices)):\n        if prices[i] == prices[i - 1] - 1:\n            count += 1\n        else:\n            count = 0\n        result += count + 1\n    return result + 1\n"
     },
     {
          "instruction": "Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.\n\nOne room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way.\n\nReturn _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`.\n\n",
          "input": "**Example 1:**\n\n**Input:** corridor =  \"SSPPSPS \"\n**Output:** 3\n**Explanation:** There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, **each** section has exactly **two** seats.\n\n**Example 2:**\n\n**Input:** corridor =  \"PPSPSP \"\n**Output:** 1\n**Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n**Example 3:**\n\n**Input:** corridor =  \"S \"\n**Output:** 0\n**Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n**Constraints:**\n\n*   `n == corridor.length`\n*   `1 <= n <= 105`\n*   `corridor[i]` is either `'S'` or `'P'`.",
          "output": "def sum_of_points(s, answers):\n    total_points = 0\n    result = 0\n    term = 1\n    sign = \"+\"\n\n    for char in s:\n        if char.isdigit():\n            number = int(char)\n            if sign == \"+\":\n                result += term\n                term = number\n            elif sign == \"*\":\n                term *= number\n        else:\n            sign = char\n\n    result += term\n\n    for ans in answers:\n        total_points += (ans == result)\n\n    return total_points\n"
     },
     {
          "instruction": "You are given a **0-indexed** 2D integer array `questions` where `questions[i] = [pointsi, brainpoweri]`.\n\nThe array describes the questions of an exam, where you have to process the questions **in order** (i.e., starting from question `0`) and make a decision whether to **solve** or **skip** each question. Solving question `i` will **earn** you `pointsi` points but you will be **unable** to solve each of the next `brainpoweri` questions. If you skip question `i`, you get to make the decision on the next question.\n\n*   For example, given `questions = [[3, 2], [4, 3], [4, 4], [2, 5]]`:\n    *   If question `0` is solved, you will earn `3` points but you will be unable to solve questions `1` and `2`.\n    *   If instead, question `0` is skipped and question `1` is solved, you will earn `4` points but you will be unable to solve questions `2` and `3`.\n\nReturn _the **maximum** points you can earn for the exam_.\n\n",
          "input": "**Example 1:**\n\n**Input:** questions = \\[\\[3,2\\],\\[4,3\\],\\[4,4\\],\\[2,5\\]\\]\n**Output:** 5\n**Explanation:** The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n\n**Example 2:**\n\n**Input:** questions = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\],\\[4,4\\],\\[5,5\\]\\]\n**Output:** 7\n**Explanation:** The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n\n**Constraints:**\n\n*   `1 <= questions.length <= 105`\n*   `questions[i].length == 2`\n*   `1 <= pointsi, brainpoweri <= 105`",
          "output": "def longest_subsequence_repeated_k(s, k):\n    counts = [0] * 26\n    for c in s:\n        counts[ord(c) - ord('a')] += 1\n    seq = ''.join([chr(i + ord('a')) * (counts[i] // k) for i in range(25, -1, -1)])\n    return seq\n"
     },
     {
          "instruction": "You are given a **0-indexed** integer array `nums` consisting of `3 * n` elements.\n\nYou are allowed to remove any **subsequence** of elements of size **exactly** `n` from `nums`. The remaining `2 * n` elements will be divided into two **equal** parts:\n\n*   The first `n` elements belonging to the first part and their sum is `sumfirst`.\n*   The next `n` elements belonging to the second part and their sum is `sumsecond`.\n\nThe **difference in sums** of the two parts is denoted as `sumfirst - sumsecond`.\n\n*   For example, if `sumfirst = 3` and `sumsecond = 2`, their difference is `1`.\n*   Similarly, if `sumfirst = 2` and `sumsecond = 3`, their difference is `-1`.\n\nReturn _the **minimum difference** possible between the sums of the two parts after the removal of_ `n` _elements_.\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[3,1,2\\]\n**Output:** -1\n**Explanation:** Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums\\[0\\] = 3, the array will be \\[1,2\\]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums\\[1\\] = 1, the array will be \\[3,2\\]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums\\[2\\] = 2, the array will be \\[3,1\\]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1. \n\n**Example 2:**\n\n**Input:** nums = \\[7,9,5,8,1,3\\]\n**Output:** 1\n**Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums\\[2\\] = 5 and nums\\[3\\] = 8, the resultant array will be \\[7,9,1,3\\]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums\\[1\\] = 9 and nums\\[4\\] = 1. The resultant array becomes \\[7,5,8,3\\]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1.\n\n**Constraints:**\n\n*   `nums.length == 3 * n`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= 105`",
          "output": "def kth_distinct_string(arr, k):\n    frequency = {}\n    for s in arr:\n        frequency[s] = frequency.get(s, 0) + 1\n\n    count = 0\n    for s in arr:\n        if frequency[s] == 1:\n            count += 1\n            if count == k:\n                return s\n\n    return \"\"\n"
     },
     {
          "instruction": "You are given two **0-indexed** integer arrays `nums1` and `nums2` of length `n`.\n\nA range `[l, r]` (**inclusive**) where `0 <= l <= r < n` is **balanced** if:\n\n*   For every `i` in the range `[l, r]`, you pick either `nums1[i]` or `nums2[i]`.\n*   The sum of the numbers you pick from `nums1` equals to the sum of the numbers you pick from `nums2` (the sum is considered to be `0` if you pick no numbers from an array).\n\nTwo **balanced** ranges from `[l1, r1]` and `[l2, r2]` are considered to be **different** if at least one of the following is true:\n\n*   `l1 != l2`\n*   `r1 != r2`\n*   `nums1[i]` is picked in the first range, and `nums2[i]` is picked in the second range or **vice versa** for at least one `i`.\n\nReturn _the number of **different** ranges that are balanced._ Since the answer may be very large, return it **modulo** `109 + 7`_._\n\n",
          "input": "**Example 1:**\n\n**Input:** nums1 = \\[1,2,5\\], nums2 = \\[2,6,3\\]\n**Output:** 3\n**Explanation:** The balanced ranges are:\n- \\[0, 1\\] where we choose nums2\\[0\\], and nums1\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 2 = 2.\n- \\[0, 2\\] where we choose nums1\\[0\\], nums2\\[1\\], and nums1\\[2\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 1 + 5 = 6.\n- \\[0, 2\\] where we choose nums1\\[0\\], nums1\\[1\\], and nums2\\[2\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 1 + 2 = 3.\nNote that the second and third balanced ranges are different.\nIn the second balanced range, we choose nums2\\[1\\] and in the third balanced range, we choose nums1\\[1\\].\n\n**Example 2:**\n\n**Input:** nums1 = \\[0,1\\], nums2 = \\[1,0\\]\n**Output:** 4\n**Explanation:** The balanced ranges are:\n- \\[0, 0\\] where we choose nums1\\[0\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 0 = 0.\n- \\[1, 1\\] where we choose nums2\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 0 = 0.\n- \\[0, 1\\] where we choose nums1\\[0\\] and nums2\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 0 = 0.\n- \\[0, 1\\] where we choose nums2\\[0\\] and nums1\\[1\\].\n  The sum of the numbers chosen from nums1 equals the sum of the numbers chosen from nums2: 1 = 1.\n\n**Constraints:**\n\n*   `n == nums1.length == nums2.length`\n*   `1 <= n <= 100`\n*   `0 <= nums1[i], nums2[i] <= 100`",
          "output": "def numberOfBalancedRanges(nums1, nums2):\n    MOD = 10**9 + 7\n    dp = [[[0] * (101) for _ in range(101)] for _ in range(101)]\n\n    dp[0][0] = 2\n    sums1, sums2 = [0] * (len(nums1) + 1), [0] * (len(nums1) + 1)\n    for i, (a, b) in enumerate(zip(nums1, nums2)):\n        sums1[i + 1], sums2[i + 1] = sums1[i] + a, sums2[i] + b\n\n    ans = 0\n    for r in range(len(nums1)):\n        for l in range(r, -1, -1):\n            for k in range(l, r + 1):\n                leftSum1 = sums1[l]\n                rightSum1 = sums1[len(nums1)] - sums1[k + 1]\n                leftSum2 = sums2[l]\n                rightSum2 = sums2[len(nums1)] - sums2[r + 1]\n\n                if leftSum1 + rightSum2 == leftSum2 and leftSum1 + rightSum1 == rightSum2:\n                    for last in range(3):\n                        ans += dp[l][r][k][last]\n                        ans %= MOD\n                        next = k + 1 if last == 2 else k\n                        dp[next][k if k else r + 1][k - 1 if k else r +\n                                                   2][last] += dp[l][r][k][last]\n                        dp[l][r][k][last] = (dp[l][r][k][last] +\n                                             ((!last) or last == 2)) % MOD\n    return ans\n"
     },
     {
          "instruction": "You are given a **0-indexed** binary string `s` which represents a sequence of train cars. `s[i] = '0'` denotes that the `ith` car does **not** contain illegal goods and `s[i] = '1'` denotes that the `ith` car does contain illegal goods.\n\nAs the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations **any** number of times:\n\n1.  Remove a train car from the **left** end (i.e., remove `s[0]`) which takes 1 unit of time.\n2.  Remove a train car from the **right** end (i.e., remove `s[s.length - 1]`) which takes 1 unit of time.\n3.  Remove a train car from **anywhere** in the sequence which takes 2 units of time.\n\nReturn _the **minimum** time to remove all the cars containing illegal goods_.\n\nNote that an empty sequence of cars is considered to have no cars containing illegal goods.\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"**11**00**1**0**1** \"\n**Output:** 5\n**Explanation:** \nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 2 times. Time taken is 2 \\* 1 = 2.\n- remove a car from the right end. Time taken is 1.\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2 + 1 + 2 = 5. \n\nAn alternative way is to\n- remove a car from the left end 2 times. Time taken is 2 \\* 1 = 2.\n- remove a car from the right end 3 times. Time taken is 3 \\* 1 = 3.\nThis also obtains a total time of 2 + 3 = 5.\n\n5 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n\n**Example 2:**\n\n**Input:** s =  \"00**1**0 \"\n**Output:** 2\n**Explanation:**\nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 3 times. Time taken is 3 \\* 1 = 3.\nThis obtains a total time of 3.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to \n- remove a car from the right end 2 times. Time taken is 2 \\* 1 = 2. \nThis obtains a total time of 2.\n\n2 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s[i]` is either `'0'` or `'1'`.",
          "output": "def min_time_to_remove_illegal_goods(s: str) -> int:\n    ones = twos = 0\n    for c in s:\n        if c == '1':\n            twos += ones\n            ones += 1\n    return ones + min(ones, twos)\n"
     },
     {
          "instruction": "You are given an array `points` where `points[i] = [xi, yi]` represents a point on an **X-Y** plane.\n\n**Straight lines** are going to be added to the **X-Y** plane, such that every point is covered by at **least** one line.\n\nReturn _the **minimum** number of **straight lines** needed to cover all the points_.\n\n",
          "input": "**Example 1:**\n\n**Input:** points = \\[\\[0,1\\],\\[2,3\\],\\[4,5\\],\\[4,3\\]\\]\n**Output:** 2\n**Explanation:** The minimum number of straight lines needed is two. One possible solution is to add:\n- One line connecting the point at (0, 1) to the point at (4, 5).\n- Another line connecting the point at (2, 3) to the point at (4, 3).\n\n**Example 2:**\n\n**Input:** points = \\[\\[0,2\\],\\[-2,-2\\],\\[1,4\\]\\]\n**Output:** 1\n**Explanation:** The minimum number of straight lines needed is one. The only solution is to add:\n- One line connecting the point at (-2, -2) to the point at (1, 4).\n\n**Constraints:**\n\n*   `1 <= points.length <= 10`\n*   `points[i].length == 2`\n*   `-100 <= xi, yi <= 100`\n*   All the `points` are **unique**.",
          "output": "from math import gcd\nfrom itertools import combinations\n\ndef minStraightLines(points):\n    lines = set()\n    for p1, p2 in combinations(points, 2):\n        dy, dx = p2[1] - p1[1], p2[0] - p1[0]\n        g = gcd(dx, dy)\n        lines.add((dy // g, dx // g))\n    return len(lines)\n"
     },
     {
          "instruction": "You are given an integer array `nums` of length `n` and an integer `numSlots` such that `2 * numSlots >= n`. There are `numSlots` slots numbered from `1` to `numSlots`.\n\nYou have to place all `n` integers into the slots such that each slot contains at **most** two numbers. The **AND sum** of a given placement is the sum of the **bitwise** `AND` of every number with its respective slot number.\n\n*   For example, the **AND sum** of placing the numbers `[1, 3]` into slot `1` and `[4, 6]` into slot `2` is equal to `(1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4`.\n\nReturn _the maximum possible **AND sum** of_ `nums` _given_ `numSlots` _slots._\n\n",
          "input": "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6\\], numSlots = 3\n**Output:** 9\n**Explanation:** One possible placement is \\[1, 4\\] into slot 1, \\[2, 6\\] into slot 2, and \\[3, 5\\] into slot 3. \nThis gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n\n**Example 2:**\n\n**Input:** nums = \\[1,3,10,4,7,1\\], numSlots = 9\n**Output:** 24\n**Explanation:** One possible placement is \\[1, 1\\] into slot 1, \\[3\\] into slot 3, \\[4\\] into slot 4, \\[7\\] into slot 7, and \\[10\\] into slot 9.\nThis gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\nNote that slots 2, 5, 6, and 8 are empty which is permitted.\n\n**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= numSlots <= 9`\n*   `1 <= n <= 2 * numSlots`\n*   `1 <= nums[i] <= 15`",
          "output": "def max_and_sum(nums, num_slots, idx, used, sum):\n    if idx == len(nums):\n        return sum\n    max_sum = 0\n    for i in range(1, num_slots + 1):\n        if not used & (1 << (i - 1)):\n            new_sum = sum + (nums[idx] & i)\n            new_used = used | (1 << (i - 1))\n            max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 1, new_used, new_sum))\n            if idx + 1 < len(nums):\n                new_sum = new_sum + (nums[idx + 1] & i)\n                max_sum = max(max_sum, max_and_sum(nums, num_slots, idx + 2, new_used, new_sum))\n    return max_sum\n\ndef max_and_sum(nums, num_slots):\n    return max_and_sum(nums, num_slots, 0, 0, 0)\n"
     },
     {
          "instruction": "You are given a **0-indexed** 2D integer array `tires` where `tires[i] = [fi, ri]` indicates that the `ith` tire can finish its `xth` successive lap in `fi * ri(x-1)` seconds.\n\n*   For example, if `fi = 3` and `ri = 2`, then the tire would finish its `1st` lap in `3` seconds, its `2nd` lap in `3 * 2 = 6` seconds, its `3rd` lap in `3 * 22 = 12` seconds, etc.\n\nYou are also given an integer `changeTime` and an integer `numLaps`.\n\nThe race consists of `numLaps` laps and you may start the race with **any** tire. You have an **unlimited** supply of each tire and after every lap, you may **change** to any given tire (including the current tire type) if you wait `changeTime` seconds.\n\nReturn _the **minimum** time to finish the race._\n\n",
          "input": "**Example 1:**\n\n**Input:** tires = \\[\\[2,3\\],\\[3,4\\]\\], changeTime = 5, numLaps = 4\n**Output:** 21\n**Explanation:** \nLap 1: Start with tire 0 and finish the lap in 2 seconds.\nLap 2: Continue with tire 0 and finish the lap in 2 \\* 3 = 6 seconds.\nLap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 0 and finish the lap in 2 \\* 3 = 6 seconds.\nTotal time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\nThe minimum time to complete the race is 21 seconds.\n\n**Example 2:**\n\n**Input:** tires = \\[\\[1,10\\],\\[2,2\\],\\[3,4\\]\\], changeTime = 6, numLaps = 5\n**Output:** 25\n**Explanation:** \nLap 1: Start with tire 1 and finish the lap in 2 seconds.\nLap 2: Continue with tire 1 and finish the lap in 2 \\* 2 = 4 seconds.\nLap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\nLap 4: Continue with tire 1 and finish the lap in 2 \\* 2 = 4 seconds.\nLap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\nTotal time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\nThe minimum time to complete the race is 25 seconds. \n\n**Constraints:**\n\n*   `1 <= tires.length <= 105`\n*   `tires[i].length == 2`\n*   `1 <= fi, changeTime <= 105`\n*   `2 <= ri <= 105`\n*   `1 <= numLaps <= 1000`",
          "output": "def min_x(n, quantities):\n    total_products = sum(quantities)\n    return (total_products + n - 1) // n\n"
     },
     {
          "instruction": "You are given a **0-indexed binary** string `floor`, which represents the colors of tiles on a floor:\n\n*   `floor[i] = '0'` denotes that the `ith` tile of the floor is colored **black**.\n*   On the other hand, `floor[i] = '1'` denotes that the `ith` tile of the floor is colored **white**.\n\nYou are also given `numCarpets` and `carpetLen`. You have `numCarpets` **black** carpets, each of length `carpetLen` tiles. Cover the tiles with the given carpets such that the number of **white** tiles still visible is **minimum**. Carpets may overlap one another.\n\nReturn _the **minimum** number of white tiles still visible._\n\n",
          "input": "**Example 1:**\n\n**Input:** floor =  \"10110101 \", numCarpets = 2, carpetLen = 2\n**Output:** 2\n**Explanation:** \nThe figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\nNo other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n\n**Example 2:**\n\n**Input:** floor =  \"11111 \", numCarpets = 2, carpetLen = 3\n**Output:** 0\n**Explanation:** \nThe figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\nNote that the carpets are able to overlap one another.\n\n**Constraints:**\n\n*   `1 <= carpetLen <= floor.length <= 1000`\n*   `floor[i]` is either `'0'` or `'1'`.\n*   `1 <= numCarpets <= 1000`",
          "output": "def minVisibleWhiteTiles(floor: str, numCarpets: int, carpetLen: int) -> int:\n    n, res = len(floor), len(floor)\n    for i in range(n - carpetLen + 1):\n        count = sum(1 for j in range(carpetLen) if floor[i + j] == '1')\n        for k in range(1, numCarpets + 1):\n            if k * carpetLen - 1 <= i + carpetLen:\n                res = min(res, n - count * k)\n                if i + carpetLen < n:\n                    count -= floor[i + carpetLen - k * carpetLen] == '1'\n                    count += floor[i + carpetLen] == '1'\n    return res\n"
     },
     {
          "instruction": "You are given integers `height` and `width` which specify the dimensions of a brick wall you are building. You are also given a **0-indexed** array of **unique** integers `bricks`, where the `ith` brick has a height of `1` and a width of `bricks[i]`. You have an **infinite** supply of each type of brick and bricks may **not** be rotated.\n\nEach row in the wall must be exactly `width` units long. For the wall to be **sturdy**, adjacent rows in the wall should **not** join bricks at the same location, except at the ends of the wall.\n\nReturn _the number of ways to build a **sturdy** wall._ Since the answer may be very large, return it **modulo** `109 + 7`.\n\n",
          "input": "**Example 1:**\n\n**Input:** height = 2, width = 3, bricks = \\[1,2\\]\n**Output:** 2\n**Explanation:**\nThe first two walls in the diagram show the only two ways to build a sturdy brick wall.\nNote that the third wall in the diagram is not sturdy because adjacent rows join bricks 2 units from the left.\n\n**Example 2:**\n\n**Input:** height = 1, width = 1, bricks = \\[5\\]\n**Output:** 0\n**Explanation:**\nThere are no ways to build a sturdy wall because the only type of brick we have is longer than the width of the wall.\n\n**Constraints:**\n\n*   `1 <= height <= 100`\n*   `1 <= width <= 10`\n*   `1 <= bricks.length <= 10`\n*   `1 <= bricks[i] <= 10`\n*   All the values of `bricks` are **unique**.",
          "output": "def are_encoded_strings_equal(s1: str, s2: str) -> bool:\n    decoded1, decoded2 = \"\", \"\"\n\n    for i, c in enumerate(s1):\n        if c.isdigit():\n            count = int(c)\n            decoded1 += s1[i - 1] * count\n        else:\n            decoded1 += c\n\n    for i, c in enumerate(s2):\n        if c.isdigit():\n            count = int(c)\n            decoded2 += s2[i - 1] * count\n        else:\n            decoded2 += c\n\n    return decoded1 == decoded2\n"
     },
     {
          "instruction": "You are given a **0-indexed** binary string `s` which represents the types of buildings along a street where:\n\n*   `s[i] = '0'` denotes that the `ith` building is an office and\n*   `s[i] = '1'` denotes that the `ith` building is a restaurant.\n\nAs a city official, you would like to **select** 3 buildings for random inspection. However, to ensure variety, **no two consecutive** buildings out of the **selected** buildings can be of the same type.\n\n*   For example, given `s = \"0**0**1**1**0**1** \"`, we cannot select the `1st`, `3rd`, and `5th` buildings as that would form `\"0**11** \"` which is **not** allowed due to having two consecutive buildings of the same type.\n\nReturn _the **number of valid ways** to select 3 buildings._\n\n",
          "input": "**Example 1:**\n\n**Input:** s =  \"001101 \"\n**Output:** 6\n**Explanation:** \nThe following sets of indices selected are valid:\n- \\[0,2,4\\] from  \"**0**0**1**1**0**1 \" forms  \"010 \"\n- \\[0,3,4\\] from  \"**0**01**10**1 \" forms  \"010 \"\n- \\[1,2,4\\] from  \"0**01**1**0**1 \" forms  \"010 \"\n- \\[1,3,4\\] from  \"0**0**1**10**1 \" forms  \"010 \"\n- \\[2,4,5\\] from  \"00**1**1**01** \" forms  \"101 \"\n- \\[3,4,5\\] from  \"001**101** \" forms  \"101 \"\nNo other selection is valid. Thus, there are 6 total ways.\n\n**Example 2:**\n\n**Input:** s =  \"11100 \"\n**Output:** 0\n**Explanation:** It can be shown that there are no valid selections.\n\n**Constraints:**\n\n*   `3 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.",
          "output": "def abbreviated_product(left: int, right: int) -> str:\n    product = 1\n    for i in range(left, right + 1):\n        product *= i\n    return str(product)\n"
     }
]