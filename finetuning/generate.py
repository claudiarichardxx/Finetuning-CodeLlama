import re

class Generate:


    def generate(self, taskid, prompt, device, model, tokenizer):

        """
        Generate text from a prompt using the specified model and tokenizer.

        Input arguments:
            taskid (int): 
                An identifier for the task, used for printing and logging purposes.
            
            prompt (str): 
                The input text prompt that the model will use to generate a response.
            
            device (torch.device): 
                The device on which the model and tokenization operations will be performed (e.g., 'cpu' or 'cuda').
            
            model (PreTrainedModel): 
                The language model used to generate text from the prompt.
            
            tokenizer (PreTrainedTokenizer): 
                The tokenizer used to tokenize the prompt and decode the generated output.

        What it does:
            - Tokenizes the prompt using the provided `tokenizer`.
            - Passes the tokenized prompt to the model for generating text with greedy decoding.
            - Decodes the generated tokens back into text.
            - Processes the generated output using the `processOutput` function to perform any additional processing.
            - Logs the task ID and the generated text before and after processing.

        Returns:
            tuple: 
                - `output` (str): The raw text generated by the model.
                - `after` (str): The processed output, after passing through the `processOutput` function. 
                If processing fails, `output` is returned as-is.
        """

        
        model_inputs = tokenizer(prompt, return_tensors='pt').to(device)
        print("Task ID: " + str(taskid) + "\n" + 100 * '-')
        
        
        greedy_output = model.generate(model_inputs['input_ids'], max_length = 1000, eos_token_id=tokenizer.eos_token_id, pad_token_id = tokenizer.pad_token_id)
        print("Generating...")
        
        
        output = tokenizer.decode(greedy_output[0])
        print('Before processing\n',output)
        
        try:
            after = self.processOutput(output)
            print('After processing\n', after)
            
        except:
            after = output
            print('Could not process')
            
        return output, after


    def processOutput(self, output):

        """
        Process the text generated by the language model to clean and prepare it for execution as Python code.

        Input arguments:
            output (str): 
                The raw, unprocessed text generated by the language model, often containing special tags, instructions, and formatting that need to be removed.

        What it does:
            - Removes special tags like `<s>` and `</s>`.
            - Replaces double quotation marks (") with single quotation marks (').
            - Deletes the sentence "Let's think step by step." if present.
            - Removes instructions enclosed in triple single quotes (''') and comments starting with hashtags (#).
            - Trims the code if it contains the line "if __name__ == '__main__':".
            - If there are more function definitions (`def`) than return statements, it assumes incomplete code and removes the extra function.
            - Attempts to execute the cleaned code. If execution fails, it further checks for issues like incomplete return statements or additional statements after a function and removes problematic lines.

        Returns:
            str: The processed and cleaned Python code ready for execution. 
                If errors are found during execution, attempts to clean up the code further and return a more executable version.
        """
            
        possible_starters = ['### Response:', '### Output:']
            
        for starter in possible_starters:
            if(starter in output):
                output = output[output.find(starter)+len(starter):]

        output = output.replace('<s>','').replace('</s>','').strip()
        output = output.replace('"',"'")
        output = output.replace('\nLet\'s think step by step.\n\n',"")
        output = output.replace('Answer:',"")
        output = self.remove_text_inside_quotes(output, "'''")
        output = self.remove_lines_starting_with_hashtag(output)
        deff = [m.start() for m in re.finditer(r"def ",output)] # finds the occurrences of 'def'(the starting indices)
        ret = [m.start() for m in re.finditer(r"return",output)] # finds the occurrences of 'return'(the starting indices)

        if("'''" in output):
            output = output[:deff[len(deff)-1]]
        if("if __name__ == '__main__':" in output):
            main = [m.start() for m in re.finditer(r"if __name__ == '__main__':",output)][0]
            output = output[:main]

        if (len(ret)==0):
            return output

        #if function starts but theres no return statement
        if (ret[len(ret)-1] < deff[len(deff)-1]):
            #print('funct not over!')
            output = output[:deff[len(deff)-1]]

        try:
            #execute the output
            exec(output)

        except:
            #Function starts and there is a return statement but there is a statement that doesn't end

            last_return = ret[len(ret)-1]
            try:
                #there are additional statements after the end of the function
                #sol : stop till the last return statement
                end = last_return + [m.start() for m in re.finditer("\n",output[last_return:])][0]
                output = output[:end]
            except:
                #the return statement is not complete
                #sol : stop till before the last def line
                output = output[:deff[len(deff)-1]]


        
        return (output)

    
    def remove_text_inside_quotes(self, input_string, quote):

        """
        Remove all text enclosed within a specified quote from the input string.

        Input arguments:
            input_string (str): 
                The input text which may contain quoted sections.
            quote (str): 
                The type of quotation mark used to enclose the text you want to remove (e.g., single quote, double quote, triple quotes).

        What it does:
            - Utilizes a regular expression pattern to identify and remove all text found between pairs of the specified quotation mark (`quote`).
            - Deletes everything between the matching quotation marks, including the quotes themselves.

        Returns:
            str: The input text with all sections enclosed by the specified quotes removed.
        """

        exp = quote +'(.*?)' + quote
        pattern = re.compile(exp, re.DOTALL)
        result = re.sub(pattern, '', input_string)
        return result
    

    def remove_lines_starting_with_hashtag(self, input_string):

        """
        Remove all lines from the input string that start with a hashtag (#).

        Input arguments:
            input_string (str): 
                The input text which may contain lines starting with a hashtag (#), typically comments.

        What it does:
            - Reads the input string line by line.
            - Filters out any lines that start with a hashtag (#), commonly used for comments.
            - Joins the remaining lines back into a single string.

        Returns:
            str: The input text with all lines starting with a hashtag removed.
        """

        lines = input_string.split('\n')
        filtered_lines = [line for line in lines if not line.startswith('#')]
        result_string = '\n'.join(filtered_lines)
        return result_string